////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIjQuery", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIjQuery-3.0.332907.0
/////////////////////////
// BEGIN FILE jquery.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * @license jQuery JavaScript Library v1.6.4
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Amazon elects to use jQuery and Sizzle under the MIT license.
 *
 * Date: Mon Sep 12 18:54:48 2011 -0400
 */

// [TT-0099714324] Gracefully downgrading (no jQuery and most AUI) for incompatible "browsers"
// to avoid unnecessary error churning on unhealthy browser APIs.
if (window.navigator && window.navigator.userAgent) {

// The reason we don't use 'P.register' here is to make sure jQuery plugins concatenated later on in this
// package can execute immediately
P.declare('jQuery', function () {
    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
        navigator = window.navigator,
        location = window.location;
    var jQuery = (function() {

    // Define a local copy of jQuery
    var jQuery = function( selector, context ) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init( selector, context, rootjQuery );
        },

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$,

        // A central reference to the root jQuery(document)
        rootjQuery,

        // A simple way to check for HTML strings or ID strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Check if a string has a non-whitespace character in it
        rnotwhite = /\S/,

        // Used for trimming whitespace
        trimLeft = /^\s+/,
        trimRight = /\s+$/,

        // Check for digits
        rdigit = /\d/,

        // Match a standalone tag
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

        // JSON RegExp
        rvalidchars = /^[\],:{}\s]*$/,
        rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
        rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
        rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

        // Useragent RegExp
        rwebkit = /(webkit)[ \/]([\w.]+)/,
        ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
        rmsie = /(msie) ([\w.]+)/,
        rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

        // Matches dashed string for camelizing
        rdashAlpha = /-([a-z]|[0-9])/ig,
        rmsPrefix = /^-ms-/,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return ( letter + "" ).toUpperCase();
        },

        // Keep a UserAgent string for use with jQuery.browser
        userAgent = navigator.userAgent,

        // For matching the engine and version of the browser
        browserMatch,

        // The deferred used on DOM ready
        readyList,

        // The ready event handler
        DOMContentLoaded,

        // Save a reference to some core methods
        toString = Object.prototype.toString,
        hasOwn = Object.prototype.hasOwnProperty,
        push = Array.prototype.push,
        slice = Array.prototype.slice,
        trim = String.prototype.trim,
        indexOf = Array.prototype.indexOf,

        // [[Class]] -> type pairs
        class2type = {};

    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function( selector, context, rootjQuery ) {
            var match, elem, ret, doc;

            // Handle $(""), $(null), or $(undefined)
            if ( !selector ) {
                return this;
            }

            // Handle $(DOMElement)
            if ( selector.nodeType ) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

            // The body element only exists once, optimize finding it
            if ( selector === "body" && !context && document.body ) {
                this.context = document;
                this[0] = document.body;
                this.selector = selector;
                this.length = 1;
                return this;
            }

            // Handle HTML strings
            if ( typeof selector === "string" ) {
                // Are we dealing with HTML string or an ID?
                if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];

                } else {
                    match = quickExpr.exec( selector );
                }

                // Verify a match, and that no context was specified for #id
                if ( match && (match[1] || !context) ) {

                    // HANDLE: $(html) -> $(array)
                    if ( match[1] ) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = (context ? context.ownerDocument || context : document);

                        // If a single string is passed in and it's a single tag
                        // just do a createElement and skip the rest
                        ret = rsingleTag.exec( selector );

                        if ( ret ) {
                            if ( jQuery.isPlainObject( context ) ) {
                                selector = [ document.createElement( ret[1] ) ];
                                jQuery.fn.attr.call( selector, context, true );

                            } else {
                                selector = [ doc.createElement( ret[1] ) ];
                            }

                        } else {
                            ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
                            selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                        }

                        return jQuery.merge( this, selector );

                    // HANDLE: $("#id")
                    } else {
                        elem = document.getElementById( match[2] );

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if ( elem && elem.parentNode ) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if ( elem.id !== match[2] ) {
                                return rootjQuery.find( selector );
                            }

                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return (context || rootjQuery).find( selector );

                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }

            // HANDLE: $(function)
            // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return rootjQuery.ready( selector );
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray( selector, this );
        },

        // Start with an empty selector
        selector: "",

        // The current version of jQuery being used
        jquery: "1.6.4",

        // The default length of a jQuery object is 0
        length: 0,

        // The number of elements contained in the matched element set
        size: function() {
            return this.length;
        },

        toArray: function() {
            return slice.call( this, 0 );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num == null ?

                // Return a 'clean' array
                this.toArray() :

                // Return just the object
                ( num < 0 ? this[ this.length + num ] : this[ num ] );
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems, name, selector ) {
            // Build a new jQuery matched element set
            var ret = this.constructor();

            if ( jQuery.isArray( elems ) ) {
                push.apply( ret, elems );

            } else {
                jQuery.merge( ret, elems );
            }

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            ret.context = this.context;

            if ( name === "find" ) {
                ret.selector = this.selector + (this.selector ? " " : "") + selector;
            } else if ( name ) {
                ret.selector = this.selector + "." + name + "(" + selector + ")";
            }

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function( callback, args ) {
            return jQuery.each( this, callback, args );
        },

        ready: function( fn ) {
            // Attach the listeners
            jQuery.bindReady();

            // Add the callback
            readyList.done( fn );

            return this;
        },

        eq: function( i ) {
            return i === -1 ?
                this.slice( i ) :
                this.slice( i, +i + 1 );
        },

        first: function() {
            return this.eq( 0 );
        },

        last: function() {
            return this.eq( -1 );
        },

        slice: function() {
            return this.pushStack( slice.apply( this, arguments ),
                "slice", slice.call(arguments).join(",") );
        },

        map: function( callback ) {
            return this.pushStack( jQuery.map(this, function( elem, i ) {
                return callback.call( elem, i, elem );
            }));
        },

        end: function() {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: [].sort,
        splice: [].splice
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if ( length === i ) {
            target = this;
            --i;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent Object.prototype pollution
                    // Prevent never-ending loop
                    if ( name === "__proto__" || target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                    // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        noConflict: function( deep ) {
            if ( window.$ === jQuery ) {
                window.$ = _$;
            }

            if ( deep && window.jQuery === jQuery ) {
                window.jQuery = _jQuery;
            }

            return jQuery;
        },

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },

        // Handle when the DOM is ready
        ready: function( wait ) {
            // Either a released hold or an DOMready/load event and not yet ready
            if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if ( !document.body ) {
                    return setTimeout( jQuery.ready, 1 );
                }

                // Remember that the DOM is ready
                jQuery.isReady = true;

                // If a normal DOM Ready event fired, decrement, and wait if need be
                if ( wait !== true && --jQuery.readyWait > 0 ) {
                    return;
                }

                // If there are functions bound, to execute
                readyList.resolveWith( document, [ jQuery ] );

                // Trigger any bound ready events
                if ( jQuery.fn.trigger ) {
                    jQuery( document ).trigger( "ready" ).unbind( "ready" );
                }
            }
        },

        bindReady: function() {
            if ( readyList ) {
                return;
            }

            readyList = jQuery._Deferred();

            // Catch cases where $(document).ready() is called after the
            // browser event has already occurred.
            if ( document.readyState === "complete" ) {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                return setTimeout( jQuery.ready, 1 );
            }

            // Mozilla, Opera and webkit nightlies currently support this event
            if ( document.addEventListener ) {
                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

                // A fallback to window.onload, that will always work
                window.addEventListener( "load", jQuery.ready, false );

            // If IE event model is used
            } else if ( document.attachEvent ) {
                // ensure firing before onload,
                // maybe late but safe also for iframes
                document.attachEvent( "onreadystatechange", DOMContentLoaded );

                // A fallback to window.onload, that will always work
                window.attachEvent( "onload", jQuery.ready );

                // If IE and not a frame
                // continually check to see if the document is ready
                var toplevel = false;

                try {
                    toplevel = window.frameElement == null;
                } catch(e) {}

                if ( document.documentElement.doScroll && toplevel ) {
                    doScrollCheck();
                }
            }
        },

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function( obj ) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray || function( obj ) {
            return jQuery.type(obj) === "array";
        },

        // A crude way of determining if an object is a window
        isWindow: function( obj ) {
            return obj && typeof obj === "object" && "setInterval" in obj;
        },

        isNaN: function( obj ) {
            return obj == null || !rdigit.test( obj ) || isNaN( obj );
        },

        type: function( obj ) {
            return obj == null ?
                String( obj ) :
                class2type[ toString.call(obj) ] || "object";
        },

        isPlainObject: function( obj ) {
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }

            try {
                // Not own constructor property must be Object
                if ( obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                    return false;
                }
            } catch ( e ) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.

            var key;
            for ( key in obj ) {}

            return key === undefined || hasOwn.call( obj, key );
        },

        isEmptyObject: function( obj ) {
            for ( var name in obj ) {
                return false;
            }
            return true;
        },

        error: function( msg ) {
            throw msg;
        },

        parseJSON: function( data ) {
            if ( typeof data !== "string" || !data ) {
                return null;
            }

            // Make sure leading/trailing whitespace is removed (IE can't handle it)
            data = jQuery.trim( data );

            // Attempt to parse using the native JSON parser first
            if ( window.JSON && window.JSON.parse ) {
                return window.JSON.parse( data );
            }

            // Make sure the incoming data is actual JSON
            // Logic borrowed from http://json.org/json2.js
            if ( rvalidchars.test( data.replace( rvalidescape, "@" )
                .replace( rvalidtokens, "]" )
                .replace( rvalidbraces, "")) ) {

                return (new Function( "return " + data ))();

            }
            jQuery.error( "Invalid JSON: " + data );
        },

        // Cross-browser xml parsing
        parseXML: function( data ) {
            var xml, tmp;
            try {
                if ( window.DOMParser ) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString( data , "text/xml" );
                } else { // IE
                    xml = new ActiveXObject( "Microsoft.XMLDOM" );
                    xml.async = "false";
                    xml.loadXML( data );
                }
            } catch( e ) {
                xml = undefined;
            }
            if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
                jQuery.error( "Invalid XML: " + data );
            }
            return xml;
        },

        noop: function() {},

        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function( data ) {
            if ( data && rnotwhite.test( data ) ) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                ( window.execScript || function( data ) {
                    window[ "eval" ].call( window, data );
                } )( data );
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },

        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
        },

        // args is for internal usage only
        each: function( object, callback, args ) {
            var name, i = 0,
                length = object.length,
                isObj = length === undefined || jQuery.isFunction( object );

            if ( args ) {
                if ( isObj ) {
                    for ( name in object ) {
                        if ( callback.apply( object[ name ], args ) === false ) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if ( callback.apply( object[ i++ ], args ) === false ) {
                            break;
                        }
                    }
                }

            // A special, fast, case for the most common use of each
            } else {
                if ( isObj ) {
                    for ( name in object ) {
                        if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
                            break;
                        }
                    }
                } else {
                    for ( ; i < length; ) {
                        if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
                            break;
                        }
                    }
                }
            }

            return object;
        },

        // Use native String.trim function wherever possible
        trim: trim ?
            function( text ) {
                return text == null ?
                    "" :
                    trim.call( text );
            } :

            // Otherwise use our own trimming functionality
            function( text ) {
                return text == null ?
                    "" :
                    text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
            },

        // results is for internal usage only
        makeArray: function( array, results ) {
            var ret = results || [];

            if ( array != null ) {
                // The window, strings (and functions) also have 'length'
                // The extra typeof function check is to prevent crashes
                // in Safari 2 (See: #3039)
                // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                var type = jQuery.type( array );

                if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
                    push.call( ret, array );
                } else {
                    jQuery.merge( ret, array );
                }
            }

            return ret;
        },

        inArray: function( elem, array ) {
            if ( !array ) {
                return -1;
            }

            if ( indexOf ) {
                return indexOf.call( array, elem );
            }

            for ( var i = 0, length = array.length; i < length; i++ ) {
                if ( array[ i ] === elem ) {
                    return i;
                }
            }

            return -1;
        },

        merge: function( first, second ) {
            var i = first.length,
                j = 0;

            if ( typeof second.length === "number" ) {
                for ( var l = second.length; j < l; j++ ) {
                    first[ i++ ] = second[ j ];
                }

            } else {
                while ( second[j] !== undefined ) {
                    first[ i++ ] = second[ j++ ];
                }
            }

            first.length = i;

            return first;
        },

        grep: function( elems, callback, inv ) {
            var ret = [], retVal;
            inv = !!inv;

            // Go through the array, only saving the items
            // that pass the validator function
            for ( var i = 0, length = elems.length; i < length; i++ ) {
                retVal = !!callback( elems[ i ], i );
                if ( inv !== retVal ) {
                    ret.push( elems[ i ] );
                }
            }

            return ret;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var value, key, ret = [],
                i = 0,
                length = elems.length,
                // jquery objects are treated as arrays
                isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

            // Go through the array, translating each of the items to their
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret[ ret.length ] = value;
                    }
                }

            // Go through every key on the object,
            } else {
                for ( key in elems ) {
                    value = callback( elems[ key ], key, arg );

                    if ( value != null ) {
                        ret[ ret.length ] = value;
                    }
                }
            }

            // Flatten any nested arrays
            return ret.concat.apply( [], ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            if ( typeof context === "string" ) {
                var tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }

            // Simulated bind
            var args = slice.call( arguments, 2 ),
                proxy = function() {
                    return fn.apply( context, args.concat( slice.call( arguments ) ) );
                };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

            return proxy;
        },

        // Mutifunctional method to get and set values to a collection
        // The value/s can optionally be executed if it's a function
        access: function( elems, key, value, exec, fn, pass ) {
            var length = elems.length;

            // Setting many attributes
            if ( typeof key === "object" ) {
                for ( var k in key ) {
                    jQuery.access( elems, k, key[k], exec, fn, value );
                }
                return elems;
            }

            // Setting one attribute
            if ( value !== undefined ) {
                // Optionally, function values get executed if exec is true
                exec = !pass && exec && jQuery.isFunction(value);

                for ( var i = 0; i < length; i++ ) {
                    fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
                }

                return elems;
            }

            // Getting an attribute
            return length ? fn( elems[0], key ) : undefined;
        },

        now: function() {
            return (new Date()).getTime();
        },

        // Use of jQuery.browser is frowned upon.
        // More details: http://docs.jquery.com/Utilities/jQuery.browser
        uaMatch: function( ua ) {
            ua = ua.toLowerCase();

            var match = rwebkit.exec( ua ) ||
                ropera.exec( ua ) ||
                rmsie.exec( ua ) ||
                ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
                [];

            return { browser: match[1] || "", version: match[2] || "0" };
        },

        sub: function() {
            function jQuerySub( selector, context ) {
                return new jQuerySub.fn.init( selector, context );
            }
            jQuery.extend( true, jQuerySub, this );
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init( selector, context ) {
                if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
                    context = jQuerySub( context );
                }

                return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        },

        browser: {}
    });

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
    });

    browserMatch = jQuery.uaMatch( userAgent );
    if ( browserMatch.browser ) {
        jQuery.browser[ browserMatch.browser ] = true;
        jQuery.browser.version = browserMatch.version;
    }

    // Deprecated, use jQuery.browser.webkit instead
    if ( jQuery.browser.webkit ) {
        jQuery.browser.safari = true;
    }

    // IE doesn't match non-breaking spaces with \s
    if ( rnotwhite.test( "\xA0" ) ) {
        trimLeft = /^[\s\xA0]+/;
        trimRight = /[\s\xA0]+$/;
    }

    // All jQuery objects should point back to these
    rootjQuery = jQuery(document);

    // Cleanup functions for the document ready method
    if ( document.addEventListener ) {
        DOMContentLoaded = function() {
            document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            jQuery.ready();
        };

    } else if ( document.attachEvent ) {
        DOMContentLoaded = function() {
            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if ( document.readyState === "complete" ) {
                document.detachEvent( "onreadystatechange", DOMContentLoaded );
                jQuery.ready();
            }
        };
    }

    // The DOM ready check for Internet Explorer
    function doScrollCheck() {
        if ( jQuery.isReady ) {
            return;
        }

        try {
            // If IE is used, use the trick by Diego Perini
            // http://javascript.nwbox.com/IEContentLoaded/
            document.documentElement.doScroll("left");
        } catch(e) {
            setTimeout( doScrollCheck, 1 );
            return;
        }

        // and execute any waiting functions
        jQuery.ready();
    }

    return jQuery;

    })();


    var // Promise methods
        promiseMethods = "done fail isResolved isRejected promise then always pipe".split( " " ),
        // Static reference to slice
        sliceDeferred = [].slice;

    jQuery.extend({
        // Create a simple deferred (one callbacks list)
        _Deferred: function() {
            var // callbacks list
                callbacks = [],
                // stored [ context , args ]
                fired,
                // to avoid firing when already doing so
                firing,
                // flag to know if the deferred has been cancelled
                cancelled,
                // the deferred itself
                deferred  = {

                    // done( f1, f2, ...)
                    done: function() {
                        if ( !cancelled ) {
                            var args = arguments,
                                i,
                                length,
                                elem,
                                type,
                                _fired;
                            if ( fired ) {
                                _fired = fired;
                                fired = 0;
                            }
                            for ( i = 0, length = args.length; i < length; i++ ) {
                                elem = args[ i ];
                                type = jQuery.type( elem );
                                if ( type === "array" ) {
                                    deferred.done.apply( deferred, elem );
                                } else if ( type === "function" ) {
                                    callbacks.push( elem );
                                }
                            }
                            if ( _fired ) {
                                deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
                            }
                        }
                        return this;
                    },

                    // resolve with given context and args
                    resolveWith: function( context, args ) {
                        if ( !cancelled && !fired && !firing ) {
                            // make sure args are available (#8421)
                            args = args || [];
                            firing = 1;
                            try {
                                while( callbacks[ 0 ] ) {
                                    callbacks.shift().apply( context, args );
                                }
                            }
                            finally {
                                fired = [ context, args ];
                                firing = 0;
                            }
                        }
                        return this;
                    },

                    // resolve with this as context and given arguments
                    resolve: function() {
                        deferred.resolveWith( this, arguments );
                        return this;
                    },

                    // Has this deferred been resolved?
                    isResolved: function() {
                        return !!( firing || fired );
                    },

                    // Cancel
                    cancel: function() {
                        cancelled = 1;
                        callbacks = [];
                        return this;
                    }
                };

            return deferred;
        },

        // Full fledged deferred (two callbacks list)
        Deferred: function( func ) {
            var deferred = jQuery._Deferred(),
                failDeferred = jQuery._Deferred(),
                promise;
            // Add errorDeferred methods, then and promise
            jQuery.extend( deferred, {
                then: function( doneCallbacks, failCallbacks ) {
                    deferred.done( doneCallbacks ).fail( failCallbacks );
                    return this;
                },
                always: function() {
                    return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );
                },
                fail: failDeferred.done,
                rejectWith: failDeferred.resolveWith,
                reject: failDeferred.resolve,
                isRejected: failDeferred.isResolved,
                pipe: function( fnDone, fnFail ) {
                    return jQuery.Deferred(function( newDefer ) {
                        jQuery.each( {
                            done: [ fnDone, "resolve" ],
                            fail: [ fnFail, "reject" ]
                        }, function( handler, data ) {
                            var fn = data[ 0 ],
                                action = data[ 1 ],
                                returned;
                            if ( jQuery.isFunction( fn ) ) {
                                deferred[ handler ](function() {
                                    returned = fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise().then( newDefer.resolve, newDefer.reject );
                                    } else {
                                        newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                                    }
                                });
                            } else {
                                deferred[ handler ]( newDefer[ action ] );
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    if ( obj == null ) {
                        if ( promise ) {
                            return promise;
                        }
                        promise = obj = {};
                    }
                    var i = promiseMethods.length;
                    while( i-- ) {
                        obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
                    }
                    return obj;
                }
            });
            // Make sure only one callback list will be used
            deferred.done( failDeferred.cancel ).fail( deferred.cancel );
            // Unexpose cancel
            delete deferred.cancel;
            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }
            return deferred;
        },

        // Deferred helper
        when: function( firstParam ) {
            var args = arguments,
                i = 0,
                length = args.length,
                count = length,
                deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
                    firstParam :
                    jQuery.Deferred();
            function resolveFunc( i ) {
                return function( value ) {
                    args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                    if ( !( --count ) ) {
                        // Strange bug in FF4:
                        // Values changed onto the arguments object sometimes end up as undefined values
                        // outside the $.when method. Cloning the object into a fresh array solves the issue
                        deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );
                    }
                };
            }
            if ( length > 1 ) {
                for( ; i < length; i++ ) {
                    if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {
                        args[ i ].promise().then( resolveFunc(i), deferred.reject );
                    } else {
                        --count;
                    }
                }
                if ( !count ) {
                    deferred.resolveWith( deferred, args );
                }
            } else if ( deferred !== firstParam ) {
                deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
            }
            return deferred.promise();
        }
    });



    jQuery.support = (function() {

        var div = document.createElement( "div" ),
            documentElement = document.documentElement,
            all,
            a,
            select,
            opt,
            input,
            marginDiv,
            support,
            fragment,
            body,
            testElementParent,
            testElement,
            testElementStyle,
            tds,
            events,
            eventName,
            i,
            isSupported;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";


        all = div.getElementsByTagName( "*" );
        a = div.getElementsByTagName( "a" )[ 0 ];

        // Can't get basic test support
        if ( !all || !all.length || !a ) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement( "select" );
        opt = select.appendChild( document.createElement("option") );
        input = div.getElementsByTagName( "input" )[ 0 ];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: ( div.firstChild.nodeType === 3 ),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName( "tbody" ).length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName( "link" ).length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test( a.getAttribute("style") ),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: ( a.getAttribute( "href" ) === "/a" ),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test( a.style.opacity ),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: ( input.value === "on" ),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode( true ).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }

        if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
            div.attachEvent( "onclick", function() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode( true ).fireEvent( "onclick" );
        }

        // Check if a radio maintains it's value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild( input );
        fragment = document.createDocumentFragment();
        fragment.appendChild( div.firstChild );

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

        div.innerHTML = "";

        // Figure out if the W3C box model works as expected
        div.style.width = div.style.paddingLeft = "1px";

        body = document.getElementsByTagName( "body" )[ 0 ];
        // We use our own, invisible, body unless the body is already present
        // in which case we use a div (#9239)
        testElement = document.createElement( body ? "div" : "body" );
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if ( body ) {
            jQuery.extend( testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for ( i in testElementStyle ) {
            testElement.style[ i ] = testElementStyle[ i ];
        }
        testElement.appendChild( div );
        testElementParent = body || documentElement;
        testElementParent.insertBefore( testElement, testElementParent.firstChild );

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
        jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

        if ( "zoom" in div.style ) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.style.display = "inline";
            div.style.zoom = 1;
            support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "";
            div.innerHTML = "<div style='width:4px;'></div>";
            support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
        }

        div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName( "td" );

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        isSupported = ( tds[ 0 ].offsetHeight === 0 );

        tds[ 0 ].style.display = "";
        tds[ 1 ].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE < 8 fail this test)
        support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if ( document.defaultView && document.defaultView.getComputedStyle ) {
            marginDiv = document.createElement( "div" );
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.appendChild( marginDiv );
            support.reliableMarginRight =
                ( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
        }

        // Remove the body element we added
        testElement.innerHTML = "";
        testElementParent.removeChild( testElement );

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if ( div.attachEvent ) {
            for( i in {
                submit: 1,
                change: 1,
                focusin: 1
            } ) {
                eventName = "on" + i;
                isSupported = ( eventName in div );
                if ( !isSupported ) {
                    div.setAttribute( eventName, "return;" );
                    isSupported = ( typeof div[ eventName ] === "function" );
                }
                support[ i + "Bubbles" ] = isSupported;
            }
        }

        // Null connected elements to avoid leaks in IE
        testElement = fragment = select = opt = body = marginDiv = div = input = null;

        return support;
    })();

    var rbrace = /^(?:\{.*\}|\[.*\])$/,
        rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function( elem ) {
            elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];

            return !!elem && !isEmptyDataObject( elem );
        },

        data: function( elem, name, data, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var thisCache, ret,
                internalKey = jQuery.expando,
                getByName = typeof name === "string",

                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,

                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,

                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ( (!id || (pvt && id && (cache[ id ] && !cache[ id ][ internalKey ]))) && getByName && data === undefined ) {
                return;
            }

            if ( !id ) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if ( isNode ) {
                    elem[ jQuery.expando ] = id = ++jQuery.uuid;
                } else {
                    id = jQuery.expando;
                }
            }

            if ( !cache[ id ] ) {
                cache[ id ] = {};

                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if ( !isNode ) {
                    cache[ id ].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if ( typeof name === "object" || typeof name === "function" ) {
                if ( pvt ) {
                    cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
                } else {
                    cache[ id ] = jQuery.extend(cache[ id ], name);
                }
            }

            thisCache = cache[ id ];

            // Internal jQuery data is stored in a separate object inside the object's data
            // cache in order to avoid key collisions between internal data and user-defined
            // data
            if ( pvt ) {
                if ( !thisCache[ internalKey ] ) {
                    thisCache[ internalKey ] = {};
                }

                thisCache = thisCache[ internalKey ];
            }

            if ( data !== undefined ) {
                thisCache[ jQuery.camelCase( name ) ] = data;
            }

            // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
            // not attempt to inspect the internal events object using jQuery.data, as this
            // internal data object is undocumented and subject to change.
            if ( name === "events" && !thisCache[name] ) {
                return thisCache[ internalKey ] && thisCache[ internalKey ].events;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if ( getByName ) {

                // First Try to find as-is property data
                ret = thisCache[ name ];

                // Test for null|undefined property data
                if ( ret == null ) {

                    // Try to find the camelCased property
                    ret = thisCache[ jQuery.camelCase( name ) ];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function( elem, name, pvt /* Internal Use Only */ ) {
            if ( !jQuery.acceptData( elem ) ) {
                return;
            }

            var thisCache,

                // Reference to internal data cache key
                internalKey = jQuery.expando,

                isNode = elem.nodeType,

                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,

                // See jQuery.data for more information
                id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if ( !cache[ id ] ) {
                return;
            }

            if ( name ) {

                thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];

                if ( thisCache ) {

                    // Support interoperable removal of hyphenated or camelcased keys
                    if ( !thisCache[ name ] ) {
                        name = jQuery.camelCase( name );
                    }

                    delete thisCache[ name ];

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if ( !isEmptyDataObject(thisCache) ) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if ( pvt ) {
                delete cache[ id ][ internalKey ];

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if ( !isEmptyDataObject(cache[ id ]) ) {
                    return;
                }
            }

            var internalCache = cache[ id ][ internalKey ];

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            // Ensure that `cache` is not a window object #10080
            if ( jQuery.support.deleteExpando || !cache.setInterval ) {
                delete cache[ id ];
            } else {
                cache[ id ] = null;
            }

            // We destroyed the entire user cache at once because it's faster than
            // iterating through each key, but we need to continue to persist internal
            // data if it existed
            if ( internalCache ) {
                cache[ id ] = {};
                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if ( !isNode ) {
                    cache[ id ].toJSON = jQuery.noop;
                }

                cache[ id ][ internalKey ] = internalCache;

            // Otherwise, we need to eliminate the expando on the node to avoid
            // false lookups in the cache for entries that no longer exist
            } else if ( isNode ) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if ( jQuery.support.deleteExpando ) {
                    delete elem[ jQuery.expando ];
                } else if ( elem.removeAttribute ) {
                    elem.removeAttribute( jQuery.expando );
                } else {
                    elem[ jQuery.expando ] = null;
                }
            }
        },

        // For internal use only.
        _data: function( elem, name, data ) {
            return jQuery.data( elem, name, data, true );
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function( elem ) {
            if ( elem.nodeName ) {
                var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

                if ( match ) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function( key, value ) {
            var data = null;

            if ( typeof key === "undefined" ) {
                if ( this.length ) {
                    data = jQuery.data( this[0] );

                    if ( this[0].nodeType === 1 ) {
                    var attr = this[0].attributes, name;
                        for ( var i = 0, l = attr.length; i < l; i++ ) {
                            name = attr[i].name;

                            if ( name.indexOf( "data-" ) === 0 ) {
                                name = jQuery.camelCase( name.substring(5) );

                                dataAttr( this[0], name, data[ name ] );
                            }
                        }
                    }
                }

                return data;

            } else if ( typeof key === "object" ) {
                return this.each(function() {
                    jQuery.data( this, key );
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if ( value === undefined ) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if ( data === undefined && this.length ) {
                    data = jQuery.data( this[0], key );
                    data = dataAttr( this[0], key, data );
                }

                return data === undefined && parts[1] ?
                    this.data( parts[0] ) :
                    data;

            } else {
                return this.each(function() {
                    var $this = jQuery( this ),
                        args = [ parts[0], value ];

                    $this.triggerHandler( "setData" + parts[1] + "!", args );
                    jQuery.data( this, key, value );
                    $this.triggerHandler( "changeData" + parts[1] + "!", args );
                });
            }
        },

        removeData: function( key ) {
            return this.each(function() {
                jQuery.removeData( this, key );
            });
        }
    });

    function dataAttr( elem, key, data ) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {

            var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                    data === "false" ? false :
                    data === "null" ? null :
                    !jQuery.isNaN( data ) ? parseFloat( data ) :
                        rbrace.test( data ) ? jQuery.parseJSON( data ) :
                        data;
                } catch( e ) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data( elem, key, data );

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
    // property to be considered empty objects; this property always exists in
    // order to make sure JSON.stringify does not expose internal metadata
    function isEmptyDataObject( obj ) {
        for ( var name in obj ) {
            if ( name !== "toJSON" ) {
                return false;
            }
        }

        return true;
    }




    function handleQueueMarkDefer( elem, type, src ) {
        var deferDataKey = type + "defer",
            queueDataKey = type + "queue",
            markDataKey = type + "mark",
            defer = jQuery.data( elem, deferDataKey, undefined, true );
        if ( defer &&
            ( src === "queue" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&
            ( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout( function() {
                if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&
                    !jQuery.data( elem, markDataKey, undefined, true ) ) {
                    jQuery.removeData( elem, deferDataKey, true );
                    defer.resolve();
                }
            }, 0 );
        }
    }

    jQuery.extend({

        _mark: function( elem, type ) {
            if ( elem ) {
                type = (type || "fx") + "mark";
                jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );
            }
        },

        _unmark: function( force, elem, type ) {
            if ( force !== true ) {
                type = elem;
                elem = force;
                force = false;
            }
            if ( elem ) {
                type = type || "fx";
                var key = type + "mark",
                    count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );
                if ( count ) {
                    jQuery.data( elem, key, count, true );
                } else {
                    jQuery.removeData( elem, key, true );
                    handleQueueMarkDefer( elem, type, "mark" );
                }
            }
        },

        queue: function( elem, type, data ) {
            if ( elem ) {
                type = (type || "fx") + "queue";
                var q = jQuery.data( elem, type, undefined, true );
                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !q || jQuery.isArray(data) ) {
                        q = jQuery.data( elem, type, jQuery.makeArray(data), true );
                    } else {
                        q.push( data );
                    }
                }
                return q || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                fn = queue.shift(),
                defer;

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
            }

            if ( fn ) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function() {
                    jQuery.dequeue(elem, type);
                });
            }

            if ( !queue.length ) {
                jQuery.removeData( elem, type + "queue", true );
                handleQueueMarkDefer( elem, type, "queue" );
            }
        }
    });

    jQuery.fn.extend({
        queue: function( type, data ) {
            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
            }

            if ( data === undefined ) {
                return jQuery.queue( this[0], type );
            }
            return this.each(function() {
                var queue = jQuery.queue( this, type, data );

                if ( type === "fx" && queue[0] !== "inprogress" ) {
                    jQuery.dequeue( this, type );
                }
            });
        },
        dequeue: function( type ) {
            return this.each(function() {
                jQuery.dequeue( this, type );
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function( time, type ) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue( type, function() {
                var elem = this;
                setTimeout(function() {
                    jQuery.dequeue( elem, type );
                }, time );
            });
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, object ) {
            if ( typeof type !== "string" ) {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
                elements = this,
                i = elements.length,
                count = 1,
                deferDataKey = type + "defer",
                queueDataKey = type + "queue",
                markDataKey = type + "mark",
                tmp;
            function resolve() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            }
            while( i-- ) {
                if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
                        ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
                            jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
                        jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {
                    count++;
                    tmp.done( resolve );
                }
            }
            resolve();
            return defer.promise();
        }
    });




    var rclass = /[\n\t\r]/g,
        rspace = /\s+/,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        nodeHook, boolHook;

    jQuery.fn.extend({
        attr: function( name, value ) {
            return jQuery.access( this, name, value, true, jQuery.attr );
        },

        removeAttr: function( name ) {
            return this.each(function() {
                jQuery.removeAttr( this, name );
            });
        },

        prop: function( name, value ) {
            return jQuery.access( this, name, value, true, jQuery.prop );
        },

        removeProp: function( name ) {
            name = jQuery.propFix[ name ] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[ name ] = undefined;
                    delete this[ name ];
                } catch( e ) {}
            });
        },

        addClass: function( value ) {
            var classNames, i, l, elem,
                setClass, c, cl;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).addClass( value.call(this, j, this.className) );
                });
            }

            if ( value && typeof value === "string" ) {
                classNames = value.split( rspace );

                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];

                    if ( elem.nodeType === 1 ) {
                        if ( !elem.className && classNames.length === 1 ) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
                                    setClass += classNames[ c ] + " ";
                                }
                            }
                            elem.className = jQuery.trim( setClass );
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classNames, i, l, elem, className, c, cl;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).removeClass( value.call(this, j, this.className) );
                });
            }

            if ( (value && typeof value === "string") || value === undefined ) {
                classNames = (value || "").split( rspace );

                for ( i = 0, l = this.length; i < l; i++ ) {
                    elem = this[ i ];

                    if ( elem.nodeType === 1 && elem.className ) {
                        if ( value ) {
                            className = (" " + elem.className + " ").replace( rclass, " " );
                            for ( c = 0, cl = classNames.length; c < cl; c++ ) {
                                className = className.replace(" " + classNames[ c ] + " ", " ");
                            }
                            elem.className = jQuery.trim( className );

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value,
                isBool = typeof stateVal === "boolean";

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
            }

            return this.each(function() {
                if ( type === "string" ) {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery( this ),
                        state = stateVal,
                        classNames = value.split( rspace );

                    while ( (className = classNames[ i++ ]) ) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass( className );
                        self[ state ? "addClass" : "removeClass" ]( className );
                    }

                } else if ( type === "undefined" || type === "boolean" ) {
                    if ( this.className ) {
                        // store className if set
                        jQuery._data( this, "__className__", this.className );
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                }
            });
        },

        hasClass: function( selector ) {
            var className = " " + selector + " ";
            for ( var i = 0, l = this.length; i < l; i++ ) {
                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
                    return true;
                }
            }

            return false;
        },

        val: function( value ) {
            var hooks, ret,
                elem = this[0];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return undefined;
            }

            var isFunction = jQuery.isFunction( value );

            return this.each(function( i ) {
                var self = jQuery(this), val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( isFunction ) {
                    val = value.call( this, i, self.val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";
                } else if ( typeof val === "number" ) {
                    val += "";
                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map(val, function ( value ) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function( elem ) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function( elem ) {
                    var value,
                        index = elem.selectedIndex,
                        values = [],
                        options = elem.options,
                        one = elem.type === "select-one";

                    // Nothing was selected
                    if ( index < 0 ) {
                        return null;
                    }

                    // Loop through all the selected options
                    for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
                        var option = options[ i ];

                        // Don't return options that are disabled or in a disabled optgroup
                        if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                    if ( one && !values.length && options.length ) {
                        return jQuery( options[ index ] ).val();
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var values = jQuery.makeArray( value );

                    jQuery(elem).find("option").each(function() {
                        this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
                    });

                    if ( !values.length ) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attrFix: {
            // Always normalize to ensure hook usage
            tabindex: "tabIndex"
        },

        attr: function( elem, name, value, pass ) {
            var nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return undefined;
            }

            if ( pass && name in jQuery.attrFn ) {
                return jQuery( elem )[ name ]( value );
            }

            // Fallback to prop when attributes are not supported
            if ( !("getAttribute" in elem) ) {
                return jQuery.prop( elem, name, value );
            }

            var ret, hooks,
                notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            // Normalize the name if needed
            if ( notxml ) {
                name = jQuery.attrFix[ name ] || name;

                hooks = jQuery.attrHooks[ name ];

                if ( !hooks ) {
                    // Use boolHook for boolean attributes
                    if ( rboolean.test( name ) ) {
                        hooks = boolHook;

                    // Use nodeHook if available( IE6/7 )
                    } else if ( nodeHook ) {
                        hooks = nodeHook;
                    }
                }
            }

            if ( value !== undefined ) {

                if ( value === null ) {
                    jQuery.removeAttr( elem, name );
                    return undefined;

                } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    elem.setAttribute( name, "" + value );
                    return value;
                }

            } else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
                return ret;

            } else {

                ret = elem.getAttribute( name );

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function( elem, name ) {
            var propName;
            if ( elem.nodeType === 1 ) {
                name = jQuery.attrFix[ name ] || name;

                jQuery.attr( elem, name, "" );
                elem.removeAttribute( name );

                // Set corresponding property to false for boolean attributes
                if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {
                    elem[ propName ] = false;
                }
            }
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
                        jQuery.error( "type property can't be changed" );
                    } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function( elem, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.get( elem, name );
                    }
                    return name in elem ?
                        elem.value :
                        null;
                },
                set: function( elem, value, name ) {
                    if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
                        return nodeHook.set( elem, value, name );
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function( elem, name, value ) {
            var nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return undefined;
            }

            var ret, hooks,
                notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    return (elem[ name ] = value);
                }

            } else {
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                    return ret;

                } else {
                    return elem[ name ];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");

                    return attributeNode && attributeNode.specified ?
                        parseInt( attributeNode.value, 10 ) :
                        rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            undefined;
                }
            }
        }
    });

    // Add the tabindex propHook to attrHooks for back-compat
    jQuery.attrHooks.tabIndex = jQuery.propHooks.tabIndex;

    // Hook for boolean attributes
    boolHook = {
        get: function( elem, name ) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode;
            return jQuery.prop( elem, name ) === true || ( attrNode = elem.getAttributeNode( name ) ) && attrNode.nodeValue !== false ?
                name.toLowerCase() :
                undefined;
        },
        set: function( elem, value, name ) {
            var propName;
            if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[ name ] || name;
                if ( propName in elem ) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[ propName ] = true;
                }

                elem.setAttribute( name, name.toLowerCase() );
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if ( !jQuery.support.getSetAttribute ) {

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function( elem, name ) {
                var ret;
                ret = elem.getAttributeNode( name );
                // Return undefined if nodeValue is empty string
                return ret && ret.nodeValue !== "" ?
                    ret.nodeValue :
                    undefined;
            },
            set: function( elem, value, name ) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode( name );
                if ( !ret ) {
                    ret = document.createAttribute( name );
                    elem.setAttributeNode( ret );
                }
                return (ret.nodeValue = value + "");
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each([ "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                set: function( elem, value ) {
                    if ( value === "" ) {
                        elem.setAttribute( name, "auto" );
                        return value;
                    }
                }
            });
        });
    }


    // Some attributes require a special call on IE
    if ( !jQuery.support.hrefNormalized ) {
        jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                get: function( elem ) {
                    var ret = elem.getAttribute( name, 2 );
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if ( !jQuery.support.style ) {
        jQuery.attrHooks.style = {
            get: function( elem ) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function( elem, value ) {
                return (elem.style.cssText = "" + value);
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if ( !jQuery.support.optSelected ) {
        jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
            get: function( elem ) {
                var parent = elem.parentNode;

                if ( parent ) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }

    // Radios and checkboxes getter/setter
    if ( !jQuery.support.checkOn ) {
        jQuery.each([ "radio", "checkbox" ], function() {
            jQuery.valHooks[ this ] = {
                get: function( elem ) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);
                }
            }
        });
    });




    var rnamespaces = /\.(.*)$/,
        rformElems = /^(?:textarea|input|select)$/i,
        rperiod = /\./g,
        rspaces = / /g,
        rescape = /[^\w\s.|`]/g,
        fcleanup = function( nm ) {
            return nm.replace(rescape, "\\$&");
        };

/*
     * A number of helper functions used for managing events.
     * Many of the ideas behind this code originated from
     * Dean Edwards' addEvent library.
     */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function( elem, types, handler, data ) {
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            if ( handler === false ) {
                handler = returnFalse;
            } else if ( !handler ) {
                // Fixes bug #7229. Fix recommended by jdalton
                return;
            }

            var handleObjIn, handleObj;

            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery._data( elem );

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if ( !elemData ) {
                return;
            }

            var events = elemData.events,
                eventHandle = elemData.handle;

            if ( !events ) {
                elemData.events = events = {};
            }

            if ( !eventHandle ) {
                elemData.handle = eventHandle = function( e ) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                        jQuery.event.handle.apply( eventHandle.elem, arguments ) :
                        undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ( (type = types[ i++ ]) ) {
                handleObj = handleObjIn ?
                    jQuery.extend({}, handleObjIn) :
                    { handler: handler, data: data };

                // Namespaced event handlers
                if ( type.indexOf(".") > -1 ) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if ( !handleObj.guid ) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[ type ],
                    special = jQuery.event.special[ type ] || {};

                // Init the event handler queue
                if ( !handlers ) {
                    handlers = events[ type ] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                        // Bind the global event handler to the element
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle, false );

                        } else if ( elem.attachEvent ) {
                            elem.attachEvent( "on" + type, eventHandle );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push( handleObj );

                // Keep track of which events have been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, pos ) {
            // don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            if ( handler === false ) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
                elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
                events = elemData && elemData.events;

            if ( !elemData || !events ) {
                return;
            }

            // types is actually an event object here
            if ( types && types.type ) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
                types = types || "";

                for ( type in events ) {
                    jQuery.event.remove( elem, type + types );
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ( (type = types[ i++ ]) ) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if ( !all ) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
                        jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[ type ];

                if ( !eventType ) {
                    continue;
                }

                if ( !handler ) {
                    for ( j = 0; j < eventType.length; j++ ) {
                        handleObj = eventType[ j ];

                        if ( all || namespace.test( handleObj.namespace ) ) {
                            jQuery.event.remove( elem, origType, handleObj.handler, j );
                            eventType.splice( j--, 1 );
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[ type ] || {};

                for ( j = pos || 0; j < eventType.length; j++ ) {
                    handleObj = eventType[ j ];

                    if ( handler.guid === handleObj.guid ) {
                        // remove the given handler for the given type
                        if ( all || namespace.test( handleObj.namespace ) ) {
                            if ( pos == null ) {
                                eventType.splice( j--, 1 );
                            }

                            if ( special.remove ) {
                                special.remove.call( elem, handleObj );
                            }
                        }

                        if ( pos != null ) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
                    if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    ret = null;
                    delete events[ type ];
                }
            }

            // Remove the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                var handle = elemData.handle;
                if ( handle ) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if ( jQuery.isEmptyObject( elemData ) ) {
                    jQuery.removeData( elem, undefined, true );
                }
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function( event, data, elem, onlyHandlers ) {
            // Event object or event type
            var type = event.type || event,
                namespaces = [],
                exclusive;

            if ( type.indexOf("!") >= 0 ) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if ( type.indexOf(".") >= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
                // jQuery.Event object
                event[ jQuery.expando ] ? event :
                // Object literal
                new jQuery.Event( type, event ) :
                // Just the event type (string)
                new jQuery.Event( type );

            event.type = type;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

            // triggerHandler() and global events don't bubble or run the default action
            if ( onlyHandlers || !elem ) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Handle a global trigger
            if ( !elem ) {
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                jQuery.each( jQuery.cache, function() {
                    // internalKey variable is just used to make it easier to find
                    // and potentially change this stuff later; currently it just
                    // points to jQuery.expando
                    var internalKey = jQuery.expando,
                        internalCache = this[ internalKey ];
                    if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
                        jQuery.event.trigger( event, data, internalCache.handle.elem );
                    }
                });
                return;
            }

            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            event.target = elem;

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray( data ) : [];
            data.unshift( event );

            var cur = elem,
                // IE doesn't like method names with a colon (#3533, #8272)
                ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Fire event on the current element, then bubble up the DOM tree
            do {
                var handle = jQuery._data( cur, "handle" );

                event.currentTarget = cur;
                if ( handle ) {
                    handle.apply( cur, data );
                }

                // Trigger an inline bound script
                if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {
                    event.result = false;
                    event.preventDefault();
                }

                // Bubble up to document, then to window
                cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
            } while ( cur && !event.isPropagationStopped() );

            // If nobody prevented the default action, do it now
            if ( !event.isDefaultPrevented() ) {
                var old,
                    special = jQuery.event.special[ type ] || {};

                if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&
                    !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction)() check here because IE6/7 fails that test.
                    // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                    try {
                        if ( ontype && elem[ type ] ) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            old = elem[ ontype ];

                            if ( old ) {
                                elem[ ontype ] = null;
                            }

                            jQuery.event.triggered = type;
                            elem[ type ]();
                        }
                    } catch ( ieError ) {}

                    if ( old ) {
                        elem[ ontype ] = old;
                    }

                    jQuery.event.triggered = undefined;
                }
            }

            return event.result;
        },

        handle: function( event ) {
            event = jQuery.event.fix( event || window.event );
            // Snapshot the handlers list since a called handler may add/remove events.
            var handlers = ((jQuery._data( this, "events" ) || {})[ event.type ] || []).slice(0),
                run_all = !event.exclusive && !event.namespace,
                args = Array.prototype.slice.call( arguments, 0 );

            // Use the fix-ed Event rather than the (read-only) native event
            args[0] = event;
            event.currentTarget = this;

            for ( var j = 0, l = handlers.length; j < l; j++ ) {
                var handleObj = handlers[ j ];

                // Triggered event must 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event.
                if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply( this, args );

                    if ( ret !== undefined ) {
                        event.result = ret;
                        if ( ret === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if ( event.isImmediatePropagationStopped() ) {
                        break;
                    }
                }
            }
            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event( originalEvent );

            for ( var i = this.props.length, prop; i; ) {
                prop = this.props[ --i ];
                event[ prop ] = originalEvent[ prop ];
            }

            // Fix target property, if necessary
            if ( !event.target ) {
                // Fixes #1925 where srcElement might not be defined either
                event.target = event.srcElement || document;
            }

            // check if target is a textnode (safari)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if ( !event.relatedTarget && event.fromElement ) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null && event.clientX != null ) {
                var eventDocument = event.target.ownerDocument || document,
                    doc = eventDocument.documentElement,
                    body = eventDocument.body;

                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
            }

            // Add which for key events
            if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if ( !event.metaKey && event.ctrlKey ) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event.which && event.button !== undefined ) {
                event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function( handleObj ) {
                    jQuery.event.add( this,
                        liveConvert( handleObj.origType, handleObj.selector ),
                        jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
                },

                remove: function( handleObj ) {
                    jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
                }
            },

            beforeunload: {
                setup: function( data, namespaces, eventHandle ) {
                    // We only want to do this special case on windows
                    if ( jQuery.isWindow( this ) ) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function ( namespaces, eventHandle ) {
                    if ( this.onbeforeunload === eventHandle ) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
        function( elem, type, handle ) {
            if ( elem.removeEventListener ) {
                elem.removeEventListener( type, handle, false );
            }
        } :
        function( elem, type, handle ) {
            if ( elem.detachEvent ) {
                elem.detachEvent( "on" + type, handle );
            }
        };

    jQuery.Event = function( src, props ) {
        // Allow instantiation without the 'new' keyword
        if ( !this.preventDefault ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
                src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

        // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if ( !e ) {
                return;
            }

            // if preventDefault exists run it on the original event
            if ( e.preventDefault ) {
                e.preventDefault();

            // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if ( !e ) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if ( e.stopPropagation ) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function( event ) {

        // Check if mouse(over|out) are still within the same parent element
        var related = event.relatedTarget,
            inside = false,
            eventType = event.type;

        event.type = event.data;

        if ( related !== this ) {

            if ( related ) {
                inside = jQuery.contains( this, related );
            }

            if ( !inside ) {

                jQuery.event.handle.apply( this, arguments );

                event.type = eventType;
            }
        }
    },

    // In case of event delegation, we only need to rename the event.type,
    // liveHandler will take care of the rest.
    delegate = function( event ) {
        event.type = event.data;
        jQuery.event.handle.apply( this, arguments );
    };

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            setup: function( data ) {
                jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
            },
            teardown: function( data ) {
                jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
            }
        };
    });

    // submit delegation
    if ( !jQuery.support.submitBubbles ) {

        jQuery.event.special.submit = {
            setup: function( data, namespaces ) {
                if ( !jQuery.nodeName( this, "form" ) ) {
                    jQuery.event.add(this, "click.specialSubmit", function( e ) {
                        // Avoid triggering error on non-existent type attribute in IE VML (#7071)
                        var elem = e.target,
                            type = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.type : "";

                        if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
                            trigger( "submit", this, arguments );
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
                        var elem = e.target,
                            type = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.type : "";

                        if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
                            trigger( "submit", this, arguments );
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function( namespaces ) {
                jQuery.event.remove( this, ".specialSubmit" );
            }
        };

    }

    // change delegation, happens here so we have bind.
    if ( !jQuery.support.changeBubbles ) {

        var changeFilters,

        getVal = function( elem ) {
            var type = jQuery.nodeName( elem, "input" ) ? elem.type : "",
                val = elem.value;

            if ( type === "radio" || type === "checkbox" ) {
                val = elem.checked;

            } else if ( type === "select-multiple" ) {
                val = elem.selectedIndex > -1 ?
                    jQuery.map( elem.options, function( elem ) {
                        return elem.selected;
                    }).join("-") :
                    "";

            } else if ( jQuery.nodeName( elem, "select" ) ) {
                val = elem.selectedIndex;
            }

            return val;
        },

        testChange = function testChange( e ) {
            var elem = e.target, data, val;

            if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
                return;
            }

            data = jQuery._data( elem, "_change_data" );
            val = getVal(elem);

            // the current data will be also retrieved by beforeactivate
            if ( e.type !== "focusout" || elem.type !== "radio" ) {
                jQuery._data( elem, "_change_data", val );
            }

            if ( data === undefined || val === data ) {
                return;
            }

            if ( data != null || val ) {
                e.type = "change";
                e.liveFired = undefined;
                jQuery.event.trigger( e, arguments[1], elem );
            }
        };

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function( e ) {
                    var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

                    if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
                        testChange.call( this, e );
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function( e ) {
                    var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

                    if ( (e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
                        (e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
                        type === "select-multiple" ) {
                        testChange.call( this, e );
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function( e ) {
                    var elem = e.target;
                    jQuery._data( elem, "_change_data", getVal(elem) );
                }
            },

            setup: function( data, namespaces ) {
                if ( this.type === "file" ) {
                    return false;
                }

                for ( var type in changeFilters ) {
                    jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
                }

                return rformElems.test( this.nodeName );
            },

            teardown: function( namespaces ) {
                jQuery.event.remove( this, ".specialChange" );

                return rformElems.test( this.nodeName );
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger( type, elem, args ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        // Don't pass args or remember liveFired; they apply to the donor event.
        var event = jQuery.extend( {}, args[ 0 ] );
        event.type = type;
        event.originalEvent = {};
        event.liveFired = undefined;
        jQuery.event.handle.call( elem, event );
        if ( event.isDefaultPrevented() ) {
            args[ 0 ].preventDefault();
        }
    }

    // Create "bubbling" focus and blur events
    if ( !jQuery.support.focusinBubbles ) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0;

            jQuery.event.special[ fix ] = {
                setup: function() {
                    if ( attaches++ === 0 ) {
                        document.addEventListener( orig, handler, true );
                    }
                },
                teardown: function() {
                    if ( --attaches === 0 ) {
                        document.removeEventListener( orig, handler, true );
                    }
                }
            };

            function handler( donor ) {
                // Donor event is always a native one; fix it and switch its type.
                // Let focusin/out handler cancel the donor focus/blur event.
                var e = jQuery.event.fix( donor );
                e.type = fix;
                e.originalEvent = {};
                jQuery.event.trigger( e, null, e.target );
                if ( e.isDefaultPrevented() ) {
                    donor.preventDefault();
                }
            }
        });
    }

    jQuery.each(["bind", "one"], function( i, name ) {
        jQuery.fn[ name ] = function( type, data, fn ) {
            var handler;

            // Handle object literals
            if ( typeof type === "object" ) {
                for ( var key in type ) {
                    this[ name ](key, data, type[key], fn);
                }
                return this;
            }

            if ( arguments.length === 2 || data === false ) {
                fn = data;
                data = undefined;
            }

            if ( name === "one" ) {
                handler = function( event ) {
                    jQuery( this ).unbind( event, handler );
                    return fn.apply( this, arguments );
                };
                handler.guid = fn.guid || jQuery.guid++;
            } else {
                handler = fn;
            }

            if ( type === "unload" && name !== "one" ) {
                this.one( type, data, fn );

            } else {
                for ( var i = 0, l = this.length; i < l; i++ ) {
                    jQuery.event.add( this[i], type, handler, data );
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function( type, fn ) {
            // Handle object literals
            if ( typeof type === "object" && !type.preventDefault ) {
                for ( var key in type ) {
                    this.unbind(key, type[key]);
                }

            } else {
                for ( var i = 0, l = this.length; i < l; i++ ) {
                    jQuery.event.remove( this[i], type, fn );
                }
            }

            return this;
        },

        delegate: function( selector, types, data, fn ) {
            return this.live( types, data, fn, selector );
        },

        undelegate: function( selector, types, fn ) {
            if ( arguments.length === 0 ) {
                return this.unbind( "live" );

            } else {
                return this.die( types, null, fn, selector );
            }
        },

        trigger: function( type, data ) {
            return this.each(function() {
                jQuery.event.trigger( type, data, this );
            });
        },

        triggerHandler: function( type, data ) {
            if ( this[0] ) {
                return jQuery.event.trigger( type, data, this[0], true );
            }
        },

        toggle: function( fn ) {
            // Save reference to arguments for access in closure
            var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function( event ) {
                    // Figure out which function to execute
                    var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
                    jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

                    // Make sure that clicks stop
                    event.preventDefault();

                    // and execute the function
                    return args[ lastToggle ].apply( this, arguments ) || false;
                };

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while ( i < args.length ) {
                args[ i++ ].guid = guid;
            }

            return this.click( toggler );
        },

        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function( i, name ) {
        jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
            var type, i = 0, match, namespaces, preType,
                selector = origSelector || this.selector,
                context = origSelector ? this : jQuery( this.context );

            if ( typeof types === "object" && !types.preventDefault ) {
                for ( var key in types ) {
                    context[ name ]( key, data, types[key], selector );
                }

                return this;
            }

            if ( name === "die" && !types &&
                        origSelector && origSelector.charAt(0) === "." ) {

                context.unbind( origSelector );

                return this;
            }

            if ( data === false || jQuery.isFunction( data ) ) {
                fn = data || returnFalse;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ( (type = types[ i++ ]) != null ) {
                match = rnamespaces.exec( type );
                namespaces = "";

                if ( match )  {
                    namespaces = match[0];
                    type = type.replace( rnamespaces, "" );
                }

                if ( type === "hover" ) {
                    types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
                    continue;
                }

                preType = type;

                if ( liveMap[ type ] ) {
                    types.push( liveMap[ type ] + namespaces );
                    type = type + namespaces;

                } else {
                    type = (liveMap[ type ] || type) + namespaces;
                }

                if ( name === "live" ) {
                    // bind live handler
                    for ( var j = 0, l = context.length; j < l; j++ ) {
                        jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
                            { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
                    }

                } else {
                    // unbind live handler
                    context.unbind( "live." + liveConvert( type, selector ), fn );
                }
            }

            return this;
        };
    });

    function liveHandler( event ) {
        var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
            elems = [],
            selectors = [],
            events = jQuery._data( this, "events" );

        // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
        if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
            return;
        }

        if ( event.namespace ) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for ( j = 0; j < live.length; j++ ) {
            handleObj = live[j];

            if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
                selectors.push( handleObj.selector );

            } else {
                live.splice( j--, 1 );
            }
        }

        match = jQuery( event.target ).closest( selectors, event.currentTarget );

        for ( i = 0, l = match.length; i < l; i++ ) {
            close = match[i];

            for ( j = 0; j < live.length; j++ ) {
                handleObj = live[j];

                if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
                        event.type = handleObj.preType;
                        related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];

                        // Make sure not to accidentally match a child element with the same selector
                        if ( related && jQuery.contains( elem, related ) ) {
                            related = elem;
                        }
                    }

                    if ( !related || related !== elem ) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for ( i = 0, l = elems.length; i < l; i++ ) {
            match = elems[i];

            if ( maxLevel && match.level > maxLevel ) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply( match.elem, arguments );

            if ( ret === false || event.isPropagationStopped() ) {
                maxLevel = match.level;

                if ( ret === false ) {
                    stop = false;
                }
                if ( event.isImmediatePropagationStopped() ) {
                    break;
                }
            }
        }

        return stop;
    }

    function liveConvert( type, selector ) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
    }

    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error").split(" "), function( i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            if ( fn == null ) {
                fn = data;
                data = null;
            }

            return arguments.length > 0 ?
                this.bind( name, data, fn ) :
                this.trigger( name );
        };

        if ( jQuery.attrFn ) {
            jQuery.attrFn[ name ] = true;
        }
    });



    /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function(){

    var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
        done = 0,
        toString = Object.prototype.toString,
        hasDuplicate = false,
        baseHasDuplicate = true,
        rBackslash = /\\/g,
        rNonWord = /\W/;

    // Here we check if the JavaScript engine is using some sort of
    // optimization where it does not always call our comparision
    // function. If that is the case, discard the hasDuplicate value.
    //   Thus far that includes Google Chrome.
    [0, 0].sort(function() {
        baseHasDuplicate = false;
        return 0;
    });

    var Sizzle = function( selector, context, results, seed ) {
        results = results || [];
        context = context || document;

        var origContext = context;

        if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
            return [];
        }

        if ( !selector || typeof selector !== "string" ) {
            return results;
        }

        var m, set, checkSet, extra, ret, cur, pop, i,
            prune = true,
            contextXML = Sizzle.isXML( context ),
            parts = [],
            soFar = selector;

        // Reset the position of the chunker regexp (start from head)
        do {
            chunker.exec( "" );
            m = chunker.exec( soFar );

            if ( m ) {
                soFar = m[3];

                parts.push( m[1] );

                if ( m[2] ) {
                    extra = m[3];
                    break;
                }
            }
        } while ( m );

        if ( parts.length > 1 && origPOS.exec( selector ) ) {

            if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
                set = posProcess( parts[0] + parts[1], context );

            } else {
                set = Expr.relative[ parts[0] ] ?
                    [ context ] :
                    Sizzle( parts.shift(), context );

                while ( parts.length ) {
                    selector = parts.shift();

                    if ( Expr.relative[ selector ] ) {
                        selector += parts.shift();
                    }

                    set = posProcess( selector, set );
                }
            }

        } else {
            // Take a shortcut and set the context if the root selector is an ID
            // (but not if it'll be faster if the inner selector is an ID)
            if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                    Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

                ret = Sizzle.find( parts.shift(), context, contextXML );
                context = ret.expr ?
                    Sizzle.filter( ret.expr, ret.set )[0] :
                    ret.set[0];
            }

            if ( context ) {
                ret = seed ?
                    { expr: parts.pop(), set: makeArray(seed) } :
                    Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

                set = ret.expr ?
                    Sizzle.filter( ret.expr, ret.set ) :
                    ret.set;

                if ( parts.length > 0 ) {
                    checkSet = makeArray( set );

                } else {
                    prune = false;
                }

                while ( parts.length ) {
                    cur = parts.pop();
                    pop = cur;

                    if ( !Expr.relative[ cur ] ) {
                        cur = "";
                    } else {
                        pop = parts.pop();
                    }

                    if ( pop == null ) {
                        pop = context;
                    }

                    Expr.relative[ cur ]( checkSet, pop, contextXML );
                }

            } else {
                checkSet = parts = [];
            }
        }

        if ( !checkSet ) {
            checkSet = set;
        }

        if ( !checkSet ) {
            Sizzle.error( cur || selector );
        }

        if ( toString.call(checkSet) === "[object Array]" ) {
            if ( !prune ) {
                results.push.apply( results, checkSet );

            } else if ( context && context.nodeType === 1 ) {
                for ( i = 0; checkSet[i] != null; i++ ) {
                    if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
                        results.push( set[i] );
                    }
                }

            } else {
                for ( i = 0; checkSet[i] != null; i++ ) {
                    if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
                        results.push( set[i] );
                    }
                }
            }

        } else {
            makeArray( checkSet, results );
        }

        if ( extra ) {
            Sizzle( extra, origContext, results, seed );
            Sizzle.uniqueSort( results );
        }

        return results;
    };

    Sizzle.uniqueSort = function( results ) {
        if ( sortOrder ) {
            hasDuplicate = baseHasDuplicate;
            results.sort( sortOrder );

            if ( hasDuplicate ) {
                for ( var i = 1; i < results.length; i++ ) {
                    if ( results[i] === results[ i - 1 ] ) {
                        results.splice( i--, 1 );
                    }
                }
            }
        }

        return results;
    };

    Sizzle.matches = function( expr, set ) {
        return Sizzle( expr, null, null, set );
    };

    Sizzle.matchesSelector = function( node, expr ) {
        return Sizzle( expr, null, null, [node] ).length > 0;
    };

    Sizzle.find = function( expr, context, isXML ) {
        var set;

        if ( !expr ) {
            return [];
        }

        for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
            var match,
                type = Expr.order[i];

            if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
                var left = match[1];
                match.splice( 1, 1 );

                if ( left.substr( left.length - 1 ) !== "\\" ) {
                    match[1] = (match[1] || "").replace( rBackslash, "" );
                    set = Expr.find[ type ]( match, context, isXML );

                    if ( set != null ) {
                        expr = expr.replace( Expr.match[ type ], "" );
                        break;
                    }
                }
            }
        }

        if ( !set ) {
            set = typeof context.getElementsByTagName !== "undefined" ?
                context.getElementsByTagName( "*" ) :
                [];
        }

        return { set: set, expr: expr };
    };

    Sizzle.filter = function( expr, set, inplace, not ) {
        var match, anyFound,
            old = expr,
            result = [],
            curLoop = set,
            isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

        while ( expr && set.length ) {
            for ( var type in Expr.filter ) {
                if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
                    var found, item,
                        filter = Expr.filter[ type ],
                        left = match[1];

                    anyFound = false;

                    match.splice(1,1);

                    if ( left.substr( left.length - 1 ) === "\\" ) {
                        continue;
                    }

                    if ( curLoop === result ) {
                        result = [];
                    }

                    if ( Expr.preFilter[ type ] ) {
                        match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

                        if ( !match ) {
                            anyFound = found = true;

                        } else if ( match === true ) {
                            continue;
                        }
                    }

                    if ( match ) {
                        for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
                            if ( item ) {
                                found = filter( item, match, i, curLoop );
                                var pass = not ^ !!found;

                                if ( inplace && found != null ) {
                                    if ( pass ) {
                                        anyFound = true;

                                    } else {
                                        curLoop[i] = false;
                                    }

                                } else if ( pass ) {
                                    result.push( item );
                                    anyFound = true;
                                }
                            }
                        }
                    }

                    if ( found !== undefined ) {
                        if ( !inplace ) {
                            curLoop = result;
                        }

                        expr = expr.replace( Expr.match[ type ], "" );

                        if ( !anyFound ) {
                            return [];
                        }

                        break;
                    }
                }
            }

            // Improper expression
            if ( expr === old ) {
                if ( anyFound == null ) {
                    Sizzle.error( expr );

                } else {
                    break;
                }
            }

            old = expr;
        }

        return curLoop;
    };

    Sizzle.error = function( msg ) {
        throw "Syntax error, unrecognized expression: " + msg;
    };

    var Expr = Sizzle.selectors = {
        order: [ "ID", "NAME", "TAG" ],

        match: {
            ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
            CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
            NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
            ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
            TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
            CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
            POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
            PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
        },

        leftMatch: {},

        attrMap: {
            "class": "className",
            "for": "htmlFor"
        },

        attrHandle: {
            href: function( elem ) {
                return elem.getAttribute( "href" );
            },
            type: function( elem ) {
                return elem.getAttribute( "type" );
            }
        },

        relative: {
            "+": function(checkSet, part){
                var isPartStr = typeof part === "string",
                    isTag = isPartStr && !rNonWord.test( part ),
                    isPartStrNotTag = isPartStr && !isTag;

                if ( isTag ) {
                    part = part.toLowerCase();
                }

                for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
                    if ( (elem = checkSet[i]) ) {
                        while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

                        checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                            elem || false :
                            elem === part;
                    }
                }

                if ( isPartStrNotTag ) {
                    Sizzle.filter( part, checkSet, true );
                }
            },

            ">": function( checkSet, part ) {
                var elem,
                    isPartStr = typeof part === "string",
                    i = 0,
                    l = checkSet.length;

                if ( isPartStr && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();

                    for ( ; i < l; i++ ) {
                        elem = checkSet[i];

                        if ( elem ) {
                            var parent = elem.parentNode;
                            checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                        }
                    }

                } else {
                    for ( ; i < l; i++ ) {
                        elem = checkSet[i];

                        if ( elem ) {
                            checkSet[i] = isPartStr ?
                                elem.parentNode :
                                elem.parentNode === part;
                        }
                    }

                    if ( isPartStr ) {
                        Sizzle.filter( part, checkSet, true );
                    }
                }
            },

            "": function(checkSet, part, isXML){
                var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;

                if ( typeof part === "string" && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                }

                checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
            },

            "~": function( checkSet, part, isXML ) {
                var nodeCheck,
                    doneName = done++,
                    checkFn = dirCheck;

                if ( typeof part === "string" && !rNonWord.test( part ) ) {
                    part = part.toLowerCase();
                    nodeCheck = part;
                    checkFn = dirNodeCheck;
                }

                checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
            }
        },

        find: {
            ID: function( match, context, isXML ) {
                if ( typeof context.getElementById !== "undefined" && !isXML ) {
                    var m = context.getElementById(match[1]);
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    return m && m.parentNode ? [m] : [];
                }
            },

            NAME: function( match, context ) {
                if ( typeof context.getElementsByName !== "undefined" ) {
                    var ret = [],
                        results = context.getElementsByName( match[1] );

                    for ( var i = 0, l = results.length; i < l; i++ ) {
                        if ( results[i].getAttribute("name") === match[1] ) {
                            ret.push( results[i] );
                        }
                    }

                    return ret.length === 0 ? null : ret;
                }
            },

            TAG: function( match, context ) {
                if ( typeof context.getElementsByTagName !== "undefined" ) {
                    return context.getElementsByTagName( match[1] );
                }
            }
        },
        preFilter: {
            CLASS: function( match, curLoop, inplace, result, not, isXML ) {
                match = " " + match[1].replace( rBackslash, "" ) + " ";

                if ( isXML ) {
                    return match;
                }

                for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
                    if ( elem ) {
                        if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
                            if ( !inplace ) {
                                result.push( elem );
                            }

                        } else if ( inplace ) {
                            curLoop[i] = false;
                        }
                    }
                }

                return false;
            },

            ID: function( match ) {
                return match[1].replace( rBackslash, "" );
            },

            TAG: function( match, curLoop ) {
                return match[1].replace( rBackslash, "" ).toLowerCase();
            },

            CHILD: function( match ) {
                if ( match[1] === "nth" ) {
                    if ( !match[2] ) {
                        Sizzle.error( match[0] );
                    }

                    match[2] = match[2].replace(/^\+|\s*/g, '');

                    // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                    var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
                        match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                        !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

                    // calculate the numbers (first)n+(last) including if they are negative
                    match[2] = (test[1] + (test[2] || 1)) - 0;
                    match[3] = test[3] - 0;
                }
                else if ( match[2] ) {
                    Sizzle.error( match[0] );
                }

                // TODO: Move to normal caching system
                match[0] = done++;

                return match;
            },

            ATTR: function( match, curLoop, inplace, result, not, isXML ) {
                var name = match[1] = match[1].replace( rBackslash, "" );

                if ( !isXML && Expr.attrMap[name] ) {
                    match[1] = Expr.attrMap[name];
                }

                // Handle if an un-quoted value was used
                match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

                if ( match[2] === "~=" ) {
                    match[4] = " " + match[4] + " ";
                }

                return match;
            },

            PSEUDO: function( match, curLoop, inplace, result, not ) {
                if ( match[1] === "not" ) {
                    // If we're dealing with a complex expression, or a simple one
                    if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
                        match[3] = Sizzle(match[3], null, null, curLoop);

                    } else {
                        var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                        if ( !inplace ) {
                            result.push.apply( result, ret );
                        }

                        return false;
                    }

                } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
                    return true;
                }

                return match;
            },

            POS: function( match ) {
                match.unshift( true );

                return match;
            }
        },

        filters: {
            enabled: function( elem ) {
                return elem.disabled === false && elem.type !== "hidden";
            },

            disabled: function( elem ) {
                return elem.disabled === true;
            },

            checked: function( elem ) {
                return elem.checked === true;
            },

            selected: function( elem ) {
                // Accessing this property makes selected-by-default
                // options in Safari work properly
                if ( elem.parentNode ) {
                    elem.parentNode.selectedIndex;
                }

                return elem.selected === true;
            },

            parent: function( elem ) {
                return !!elem.firstChild;
            },

            empty: function( elem ) {
                return !elem.firstChild;
            },

            has: function( elem, i, match ) {
                return !!Sizzle( match[3], elem ).length;
            },

            header: function( elem ) {
                return (/h\d/i).test( elem.nodeName );
            },

            text: function( elem ) {
                var attr = elem.getAttribute( "type" ), type = elem.type;
                // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                // use getAttribute instead to test this case
                return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
            },

            radio: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
            },

            checkbox: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
            },

            file: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
            },

            password: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
            },

            submit: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && "submit" === elem.type;
            },

            image: function( elem ) {
                return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
            },

            reset: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && "reset" === elem.type;
            },

            button: function( elem ) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && "button" === elem.type || name === "button";
            },

            input: function( elem ) {
                return (/input|select|textarea|button/i).test( elem.nodeName );
            },

            focus: function( elem ) {
                return elem === elem.ownerDocument.activeElement;
            }
        },
        setFilters: {
            first: function( elem, i ) {
                return i === 0;
            },

            last: function( elem, i, match, array ) {
                return i === array.length - 1;
            },

            even: function( elem, i ) {
                return i % 2 === 0;
            },

            odd: function( elem, i ) {
                return i % 2 === 1;
            },

            lt: function( elem, i, match ) {
                return i < match[3] - 0;
            },

            gt: function( elem, i, match ) {
                return i > match[3] - 0;
            },

            nth: function( elem, i, match ) {
                return match[3] - 0 === i;
            },

            eq: function( elem, i, match ) {
                return match[3] - 0 === i;
            }
        },
        filter: {
            PSEUDO: function( elem, match, i, array ) {
                var name = match[1],
                    filter = Expr.filters[ name ];

                if ( filter ) {
                    return filter( elem, i, match, array );

                } else if ( name === "contains" ) {
                    return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

                } else if ( name === "not" ) {
                    var not = match[3];

                    for ( var j = 0, l = not.length; j < l; j++ ) {
                        if ( not[j] === elem ) {
                            return false;
                        }
                    }

                    return true;

                } else {
                    Sizzle.error( name );
                }
            },

            CHILD: function( elem, match ) {
                var type = match[1],
                    node = elem;

                switch ( type ) {
                    case "only":
                    case "first":
                        while ( (node = node.previousSibling) )  {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }

                        if ( type === "first" ) {
                            return true;
                        }

                        node = elem;
                        /* falls through */
                    case "last":
                        while ( (node = node.nextSibling) )  {
                            if ( node.nodeType === 1 ) {
                                return false;
                            }
                        }

                        return true;

                    case "nth":
                        var first = match[2],
                            last = match[3];

                        if ( first === 1 && last === 0 ) {
                            return true;
                        }

                        var doneName = match[0],
                            parent = elem.parentNode;

                        if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
                            var count = 0;

                            for ( node = parent.firstChild; node; node = node.nextSibling ) {
                                if ( node.nodeType === 1 ) {
                                    node.nodeIndex = ++count;
                                }
                            }

                            parent.sizcache = doneName;
                        }

                        var diff = elem.nodeIndex - last;

                        if ( first === 0 ) {
                            return diff === 0;

                        } else {
                            return ( diff % first === 0 && diff / first >= 0 );
                        }
                }
            },

            ID: function( elem, match ) {
                return elem.nodeType === 1 && elem.getAttribute("id") === match;
            },

            TAG: function( elem, match ) {
                return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
            },

            CLASS: function( elem, match ) {
                return (" " + (elem.className || elem.getAttribute("class")) + " ")
                    .indexOf( match ) > -1;
            },

            ATTR: function( elem, match ) {
                var name = match[1],
                    result = Expr.attrHandle[ name ] ?
                        Expr.attrHandle[ name ]( elem ) :
                        elem[ name ] != null ?
                            elem[ name ] :
                            elem.getAttribute( name ),
                    value = result + "",
                    type = match[2],
                    check = match[4];

                return result == null ?
                    type === "!=" :
                    type === "=" ?
                    value === check :
                    type === "*=" ?
                    value.indexOf(check) >= 0 :
                    type === "~=" ?
                    (" " + value + " ").indexOf(check) >= 0 :
                    !check ?
                    value && result !== false :
                    type === "!=" ?
                    value !== check :
                    type === "^=" ?
                    value.indexOf(check) === 0 :
                    type === "$=" ?
                    value.substr(value.length - check.length) === check :
                    type === "|=" ?
                    value === check || value.substr(0, check.length + 1) === check + "-" :
                    false;
            },

            POS: function( elem, match, i, array ) {
                var name = match[2],
                    filter = Expr.setFilters[ name ];

                if ( filter ) {
                    return filter( elem, i, match, array );
                }
            }
        }
    };

    var origPOS = Expr.match.POS,
        fescape = function(all, num){
            return "\\" + (num - 0 + 1);
        };

    for ( var type in Expr.match ) {
        Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
        Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
    }

    var makeArray = function( array, results ) {
        array = Array.prototype.slice.call( array, 0 );

        if ( results ) {
            results.push.apply( results, array );
            return results;
        }

        return array;
    };

    // Perform a simple check to determine if the browser is capable of
    // converting a NodeList to an array using builtin methods.
    // Also verifies that the returned array holds DOM nodes
    // (which is not the case in the Blackberry browser)
    try {
        Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

    // Provide a fallback method if it does not work
    } catch( e ) {
        makeArray = function( array, results ) {
            var i = 0,
                ret = results || [];

            if ( toString.call(array) === "[object Array]" ) {
                Array.prototype.push.apply( ret, array );

            } else {
                if ( typeof array.length === "number" ) {
                    for ( var l = array.length; i < l; i++ ) {
                        ret.push( array[i] );
                    }

                } else {
                    for ( ; array[i]; i++ ) {
                        ret.push( array[i] );
                    }
                }
            }

            return ret;
        };
    }

    var sortOrder, siblingCheck;

    if ( document.documentElement.compareDocumentPosition ) {
        sortOrder = function( a, b ) {
            if ( a === b ) {
                hasDuplicate = true;
                return 0;
            }

            if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
                return a.compareDocumentPosition ? -1 : 1;
            }

            return a.compareDocumentPosition(b) & 4 ? -1 : 1;
        };

    } else {
        sortOrder = function( a, b ) {
            // The nodes are identical, we can exit early
            if ( a === b ) {
                hasDuplicate = true;
                return 0;

            // Fallback to using sourceIndex (in IE) if it's available on both nodes
            } else if ( a.sourceIndex && b.sourceIndex ) {
                return a.sourceIndex - b.sourceIndex;
            }

            var al, bl,
                ap = [],
                bp = [],
                aup = a.parentNode,
                bup = b.parentNode,
                cur = aup;

            // If the nodes are siblings (or identical) we can do a quick check
            if ( aup === bup ) {
                return siblingCheck( a, b );

            // If no parents were found then the nodes are disconnected
            } else if ( !aup ) {
                return -1;

            } else if ( !bup ) {
                return 1;
            }

            // Otherwise they're somewhere else in the tree so we need
            // to build up a full list of the parentNodes for comparison
            while ( cur ) {
                ap.unshift( cur );
                cur = cur.parentNode;
            }

            cur = bup;

            while ( cur ) {
                bp.unshift( cur );
                cur = cur.parentNode;
            }

            al = ap.length;
            bl = bp.length;

            // Start walking down the tree looking for a discrepancy
            for ( var i = 0; i < al && i < bl; i++ ) {
                if ( ap[i] !== bp[i] ) {
                    return siblingCheck( ap[i], bp[i] );
                }
            }

            // We ended someplace up the tree so do a sibling check
            return i === al ?
                siblingCheck( a, bp[i], -1 ) :
                siblingCheck( ap[i], b, 1 );
        };

        siblingCheck = function( a, b, ret ) {
            if ( a === b ) {
                return ret;
            }

            var cur = a.nextSibling;

            while ( cur ) {
                if ( cur === b ) {
                    return -1;
                }

                cur = cur.nextSibling;
            }

            return 1;
        };
    }

    // Utility function for retreiving the text value of an array of DOM nodes
    Sizzle.getText = function( elems ) {
        var ret = "", elem;

        for ( var i = 0; elems[i]; i++ ) {
            elem = elems[i];

            // Get the text from text nodes and CDATA nodes
            if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
                ret += elem.nodeValue;

            // Traverse everything else, except comment nodes
            } else if ( elem.nodeType !== 8 ) {
                ret += Sizzle.getText( elem.childNodes );
            }
        }

        return ret;
    };

    // Check to see if the browser returns elements by name when
    // querying by getElementById (and provide a workaround)
    (function(){
        // We're going to inject a fake input element with a specified name
        var form = document.createElement("div"),
            id = "script" + (new Date()).getTime(),
            root = document.documentElement;

        form.innerHTML = "<a name='" + id + "'/>";

        // Inject it into the root element, check its status, and remove it quickly
        root.insertBefore( form, root.firstChild );

        // The workaround has to do additional checks after a getElementById
        // Which slows things down for other browsers (hence the branching)
        if ( document.getElementById( id ) ) {
            Expr.find.ID = function( match, context, isXML ) {
                if ( typeof context.getElementById !== "undefined" && !isXML ) {
                    var m = context.getElementById(match[1]);

                    return m ?
                        m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
                            [m] :
                            undefined :
                        [];
                }
            };

            Expr.filter.ID = function( elem, match ) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                return elem.nodeType === 1 && node && node.nodeValue === match;
            };
        }

        root.removeChild( form );

        // release memory in IE
        root = form = null;
    })();

    (function(){
        // Check to see if the browser returns only elements
        // when doing getElementsByTagName("*")

        // Create a fake element
        var div = document.createElement("div");
        div.appendChild( document.createComment("") );

        // Make sure no comments are found
        if ( div.getElementsByTagName("*").length > 0 ) {
            Expr.find.TAG = function( match, context ) {
                var results = context.getElementsByTagName( match[1] );

                // Filter out possible comments
                if ( match[1] === "*" ) {
                    var tmp = [];

                    for ( var i = 0; results[i]; i++ ) {
                        if ( results[i].nodeType === 1 ) {
                            tmp.push( results[i] );
                        }
                    }

                    results = tmp;
                }

                return results;
            };
        }

        // Check to see if an attribute returns normalized href attributes
        div.innerHTML = "<a href='#'></a>";

        if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#" ) {

            Expr.attrHandle.href = function( elem ) {
                return elem.getAttribute( "href", 2 );
            };
        }

        // release memory in IE
        div = null;
    })();

    if ( document.querySelectorAll ) {
        (function(){
            var oldSizzle = Sizzle,
                div = document.createElement("div"),
                id = "__sizzle__";

            div.innerHTML = "<p class='TEST'></p>";

            // Safari can't handle uppercase or unicode characters when
            // in quirks mode.
            if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
                return;
            }

            Sizzle = function( query, context, extra, seed ) {
                context = context || document;

                // Only use querySelectorAll on non-XML documents
                // (ID selectors don't work in non-HTML documents)
                if ( !seed && !Sizzle.isXML(context) ) {
                    // See if we find a selector to speed up
                    var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

                    if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
                        // Speed-up: Sizzle("TAG")
                        if ( match[1] ) {
                            return makeArray( context.getElementsByTagName( query ), extra );

                        // Speed-up: Sizzle(".CLASS")
                        } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
                            return makeArray( context.getElementsByClassName( match[2] ), extra );
                        }
                    }

                    if ( context.nodeType === 9 ) {
                        // Speed-up: Sizzle("body")
                        // The body element only exists once, optimize finding it
                        if ( query === "body" && context.body ) {
                            return makeArray( [ context.body ], extra );

                        // Speed-up: Sizzle("#ID")
                        } else if ( match && match[3] ) {
                            var elem = context.getElementById( match[3] );

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if ( elem && elem.parentNode ) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if ( elem.id === match[3] ) {
                                    return makeArray( [ elem ], extra );
                                }

                            } else {
                                return makeArray( [], extra );
                            }
                        }

                        try {
                            return makeArray( context.querySelectorAll(query), extra );
                        } catch(qsaError) {}

                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                        var oldContext = context,
                            old = context.getAttribute( "id" ),
                            nid = old || id,
                            hasParent = context.parentNode,
                            relativeHierarchySelector = /^\s*[+~]/.test( query );

                        if ( !old ) {
                            context.setAttribute( "id", nid );
                        } else {
                            nid = nid.replace( /'/g, "\\$&" );
                        }
                        if ( relativeHierarchySelector && hasParent ) {
                            context = context.parentNode;
                        }

                        try {
                            if ( !relativeHierarchySelector || hasParent ) {
                                return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
                            }

                        } catch(pseudoError) {
                        } finally {
                            if ( !old ) {
                                oldContext.removeAttribute( "id" );
                            }
                        }
                    }
                }

                return oldSizzle(query, context, extra, seed);
            };

            for ( var prop in oldSizzle ) {
                Sizzle[ prop ] = oldSizzle[ prop ];
            }

            // release memory in IE
            div = null;
        })();
    }

    (function(){
        var html = document.documentElement,
            matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

        if ( matches ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9 fails this)
            var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
                pseudoWorks = false;

            try {
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call( document.documentElement, "[test!='']:sizzle" );

            } catch( pseudoError ) {
                pseudoWorks = true;
            }

            Sizzle.matchesSelector = function( node, expr ) {
                // Make sure that attribute selectors are quoted
                expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                if ( !Sizzle.isXML( node ) ) {
                    try {
                        if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
                            var ret = matches.call( node, expr );

                            // IE 9's matchesSelector returns false on disconnected nodes
                            if ( ret || !disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9, so check for that
                                    node.document && node.document.nodeType !== 11 ) {
                                return ret;
                            }
                        }
                    } catch(e) {}
                }

                return Sizzle(expr, null, null, [node]).length > 0;
            };
        }
    })();

    (function(){
        var div = document.createElement("div");

        div.innerHTML = "<div class='test e'></div><div class='test'></div>";

        // Opera can't find a second classname (in 9.6)
        // Also, make sure that getElementsByClassName actually exists
        if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
            return;
        }

        // Safari caches class attributes, doesn't catch changes (in 3.2)
        div.lastChild.className = "e";

        if ( div.getElementsByClassName("e").length === 1 ) {
            return;
        }

        Expr.order.splice(1, 0, "CLASS");
        Expr.find.CLASS = function( match, context, isXML ) {
            if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
                return context.getElementsByClassName(match[1]);
            }
        };

        // release memory in IE
        div = null;
    })();

    function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
        for ( var i = 0, l = checkSet.length; i < l; i++ ) {
            var elem = checkSet[i];

            if ( elem ) {
                var match = false;

                elem = elem[dir];

                while ( elem ) {
                    if ( elem.sizcache === doneName ) {
                        match = checkSet[elem.sizset];
                        break;
                    }

                    if ( elem.nodeType === 1 && !isXML ){
                        elem.sizcache = doneName;
                        elem.sizset = i;
                    }

                    if ( elem.nodeName.toLowerCase() === cur ) {
                        match = elem;
                        break;
                    }

                    elem = elem[dir];
                }

                checkSet[i] = match;
            }
        }
    }

    function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
        for ( var i = 0, l = checkSet.length; i < l; i++ ) {
            var elem = checkSet[i];

            if ( elem ) {
                var match = false;

                elem = elem[dir];

                while ( elem ) {
                    if ( elem.sizcache === doneName ) {
                        match = checkSet[elem.sizset];
                        break;
                    }

                    if ( elem.nodeType === 1 ) {
                        if ( !isXML ) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if ( typeof cur !== "string" ) {
                            if ( elem === cur ) {
                                match = true;
                                break;
                            }

                        } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
                            match = elem;
                            break;
                        }
                    }

                    elem = elem[dir];
                }

                checkSet[i] = match;
            }
        }
    }

    if ( document.documentElement.contains ) {
        Sizzle.contains = function( a, b ) {
            return a !== b && (a.contains ? a.contains(b) : true);
        };

    } else if ( document.documentElement.compareDocumentPosition ) {
        Sizzle.contains = function( a, b ) {
            return !!(a.compareDocumentPosition(b) & 16);
        };

    } else {
        Sizzle.contains = function() {
            return false;
        };
    }

    Sizzle.isXML = function( elem ) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

        return documentElement ? documentElement.nodeName !== "HTML" : false;
    };

    var posProcess = function( selector, context ) {
        var match,
            tmpSet = [],
            later = "",
            root = context.nodeType ? [context] : context;

        // Position selectors must be done after the filter
        // And so must :not(positional) so we move all PSEUDOs to the end
        while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
            later += match[0];
            selector = selector.replace( Expr.match.PSEUDO, "" );
        }

        selector = Expr.relative[selector] ? selector + "*" : selector;

        for ( var i = 0, l = root.length; i < l; i++ ) {
            Sizzle( selector, root[i], tmpSet );
        }

        return Sizzle.filter( later, tmpSet );
    };

    // EXPOSE
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.filters;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.POS,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        find: function( selector ) {
            var self = this,
                i, l;

            if ( typeof selector !== "string" ) {
                return jQuery( selector ).filter(function() {
                    for ( i = 0, l = self.length; i < l; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                });
            }

            var ret = this.pushStack( "", "find", selector ),
                length, n, r;

            for ( i = 0, l = this.length; i < l; i++ ) {
                length = ret.length;
                jQuery.find( selector, this[i], ret );

                if ( i > 0 ) {
                    // Make sure that the results are unique
                    for ( n = length; n < ret.length; n++ ) {
                        for ( r = 0; r < length; r++ ) {
                            if ( ret[r] === ret[n] ) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function( target ) {
            var targets = jQuery( target );
            return this.filter(function() {
                for ( var i = 0, l = targets.length; i < l; i++ ) {
                    if ( jQuery.contains( this, targets[i] ) ) {
                        return true;
                    }
                }
            });
        },

        not: function( selector ) {
            return this.pushStack( winnow(this, selector, false), "not", selector);
        },

        filter: function( selector ) {
            return this.pushStack( winnow(this, selector, true), "filter", selector );
        },

        is: function( selector ) {
            return !!selector && ( typeof selector === "string" ?
                jQuery.filter( selector, this ).length > 0 :
                this.filter( selector ).length > 0 );
        },

        closest: function( selectors, context ) {
            var ret = [], i, l, cur = this[0];

            // Array
            if ( jQuery.isArray( selectors ) ) {
                var match, selector,
                    matches = {},
                    level = 1;

                if ( cur && selectors.length ) {
                    for ( i = 0, l = selectors.length; i < l; i++ ) {
                        selector = selectors[i];

                        if ( !matches[ selector ] ) {
                            matches[ selector ] = POS.test( selector ) ?
                                jQuery( selector, context || this.context ) :
                                selector;
                        }
                    }

                    while ( cur && cur.ownerDocument && cur !== context ) {
                        for ( selector in matches ) {
                            match = matches[ selector ];

                            if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( match ) ) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            // String
            var pos = POS.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;

            for ( i = 0, l = this.length; i < l; i++ ) {
                cur = this[i];

                while ( cur ) {
                    if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
                        ret.push( cur );
                        break;

                    } else {
                        cur = cur.parentNode;
                        if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

            return this.pushStack( ret, "closest", selectors );
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
            }

            // index in selector
            if ( typeof elem === "string" ) {
                return jQuery.inArray( this[0], jQuery( elem ) );
            }

            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this );
        },

        add: function( selector, context ) {
            var set = typeof selector === "string" ?
                    jQuery( selector, context ) :
                    jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
                all = jQuery.merge( this.get(), set );

            return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
                all :
                jQuery.unique( all ) );
        },

        andSelf: function() {
            return this.add( this.prevObject );
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected( node ) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return jQuery.dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return jQuery.nth( elem, 2, "nextSibling" );
        },
        prev: function( elem ) {
            return jQuery.nth( elem, 2, "previousSibling" );
        },
        nextAll: function( elem ) {
            return jQuery.dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return jQuery.dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return jQuery.sibling( elem.parentNode.firstChild, elem );
        },
        children: function( elem ) {
            return jQuery.sibling( elem.firstChild );
        },
        contents: function( elem ) {
            return jQuery.nodeName( elem, "iframe" ) ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray( elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var ret = jQuery.map( this, fn, until ),
                // The variable 'args' was introduced in
                // https://github.com/jquery/jquery/commit/52a0238
                // to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
                // http://code.google.com/p/v8/issues/detail?id=1050
                args = slice.call(arguments);

            if ( !runtil.test( name ) ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                ret = jQuery.filter( selector, ret );
            }

            ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

            if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }

            return this.pushStack( ret, name, args.join(",") );
        };
    });

    jQuery.extend({
        filter: function( expr, elems, not ) {
            if ( not ) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
                jQuery.find.matches(expr, elems);
        },

        dir: function( elem, dir, until ) {
            var matched = [],
                cur = elem[ dir ];

            while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                if ( cur.nodeType === 1 ) {
                    matched.push( cur );
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function( cur, result, dir, elem ) {
            result = result || 1;
            var num = 0;

            for ( ; cur; cur = cur[dir] ) {
                if ( cur.nodeType === 1 && ++num === result ) {
                    break;
                }
            }

            return cur;
        },

        sibling: function( n, elem ) {
            var r = [];

            for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 && n !== elem ) {
                    r.push( n );
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, keep ) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep(elements, function( elem, i ) {
                var retVal = !!qualifier.call( elem, i, elem );
                return retVal === keep;
            });

        } else if ( qualifier.nodeType ) {
            return jQuery.grep(elements, function( elem, i ) {
                return (elem === qualifier) === keep;
            });

        } else if ( typeof qualifier === "string" ) {
            var filtered = jQuery.grep(elements, function( elem ) {
                return elem.nodeType === 1;
            });

            if ( isSimple.test( qualifier ) ) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter( qualifier, filtered );
            }
        }

        return jQuery.grep(elements, function( elem, i ) {
            return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnocache = /<(?:script|object|embed|option|style)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
        wrapMap = {
            option: [ 1, "<select multiple='multiple'>", "</select>" ],
            legend: [ 1, "<fieldset>", "</fieldset>" ],
            thead: [ 1, "<table>", "</table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
            area: [ 1, "<map>", "</map>" ],
            _default: [ 0, "", "" ]
        };

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if ( !jQuery.support.htmlSerialize ) {
        wrapMap._default = [ 1, "div<div>", "</div>" ];
    }

    jQuery.fn.extend({
        text: function( text ) {
            if ( jQuery.isFunction(text) ) {
                return this.each(function(i) {
                    var self = jQuery( this );

                    self.text( text.call(this, i, self.text()) );
                });
            }

            if ( typeof text !== "object" && text !== undefined ) {
                return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
            }

            return jQuery.text( this );
        },

        wrapAll: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapAll( html.call(this, i) );
                });
            }

            if ( this[0] ) {
                // The elements to wrap the target around
                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                if ( this[0].parentNode ) {
                    wrap.insertBefore( this[0] );
                }

                wrap.map(function() {
                    var elem = this;

                    while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapInner( html.call(this, i) );
                });
            }

            return this.each(function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            });
        },

        wrap: function( html ) {
            return this.each(function() {
                jQuery( this ).wrapAll( html );
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            }).end();
        },

        append: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.appendChild( elem );
                }
            });
        },

        prepend: function() {
            return this.domManip(arguments, true, function( elem ) {
                if ( this.nodeType === 1 ) {
                    this.insertBefore( elem, this.firstChild );
                }
            });
        },

        before: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this );
                });
            } else if ( arguments.length ) {
                var set = jQuery(arguments[0]);
                set.push.apply( set, this.toArray() );
                return this.pushStack( set, "before", arguments );
            }
        },

        after: function() {
            if ( this[0] && this[0].parentNode ) {
                return this.domManip(arguments, false, function( elem ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                });
            } else if ( arguments.length ) {
                var set = this.pushStack( this, "after", arguments );
                set.push.apply( set, jQuery(arguments[0]).toArray() );
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function( selector, keepData ) {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
                    if ( !keepData && elem.nodeType === 1 ) {
                        jQuery.cleanData( elem.getElementsByTagName("*") );
                        jQuery.cleanData( [ elem ] );
                    }

                    if ( elem.parentNode ) {
                        elem.parentNode.removeChild( elem );
                    }
                }
            }

            return this;
        },

        empty: function() {
            for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                // Remove element nodes and prevent memory leaks
                if ( elem.nodeType === 1 ) {
                    jQuery.cleanData( elem.getElementsByTagName("*") );
                }

                // Remove any remaining nodes
                while ( elem.firstChild ) {
                    elem.removeChild( elem.firstChild );
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map( function () {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            });
        },

        html: function( value ) {
            if ( value === undefined ) {
                return this[0] && this[0].nodeType === 1 ?
                    this[0].innerHTML.replace(rinlinejQuery, "") :
                    null;

            // See if we can take a shortcut and just use innerHTML
            } else if ( typeof value === "string" && !rnocache.test( value ) &&
                (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
                !wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for ( var i = 0, l = this.length; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        if ( this[i].nodeType === 1 ) {
                            jQuery.cleanData( this[i].getElementsByTagName("*") );
                            this[i].innerHTML = value;
                        }
                    }

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {
                    this.empty().append( value );
                }

            } else if ( jQuery.isFunction( value ) ) {
                this.each(function(i){
                    var self = jQuery( this );

                    self.html( value.call(this, i, self.html()) );
                });

            } else {
                this.empty().append( value );
            }

            return this;
        },

        replaceWith: function( value ) {
            if ( this[0] && this[0].parentNode ) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if ( jQuery.isFunction( value ) ) {
                    return this.each(function(i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith( value.call( this, i, old ) );
                    });
                }

                if ( typeof value !== "string" ) {
                    value = jQuery( value ).detach();
                }

                return this.each(function() {
                    var next = this.nextSibling,
                        parent = this.parentNode;

                    jQuery( this ).remove();

                    if ( next ) {
                        jQuery(next).before( value );
                    } else {
                        jQuery(parent).append( value );
                    }
                });
            } else {
                return this.length ?
                    this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
                    this;
            }
        },

        detach: function( selector ) {
            return this.remove( selector, true );
        },

        domManip: function( args, table, callback ) {
            var results, first, fragment, parent,
                value = args[0],
                scripts = [];

            // We can't cloneNode fragments that contain checked, in WebKit
            if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
                return this.each(function() {
                    jQuery(this).domManip( args, table, callback, true );
                });
            }

            if ( jQuery.isFunction(value) ) {
                return this.each(function(i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip( args, table, callback );
                });
            }

            if ( this[0] ) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment( args, this, scripts );
                }

                fragment = results.fragment;

                if ( fragment.childNodes.length === 1 ) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if ( first ) {
                    table = table && jQuery.nodeName( first, "tr" );

                    for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
                        callback.call(
                            table ?
                                root(this[i], first) :
                                this[i],
                            // Make sure that we do not leak memory by inadvertently discarding
                            // the original fragment (which might have attached data) instead of
                            // using it; in addition, use the original fragment object for the last
                            // item instead of first because it can end up being emptied incorrectly
                            // in certain situations (Bug #8070).
                            // Fragments from the fragment cache must always be cloned and never used
                            // in place.
                            results.cacheable || (l > 1 && i < lastIndex) ?
                                jQuery.clone( fragment, true, true ) :
                                fragment
                        );
                    }
                }

                if ( scripts.length ) {
                    jQuery.each( scripts, evalScript );
                }
            }

            return this;
        }
    });

    function root( elem, cur ) {
        return jQuery.nodeName(elem, "table") ?
            (elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
            elem;
    }

    function cloneCopyEvent( src, dest ) {

        if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
            return;
        }

        var internalKey = jQuery.expando,
            oldData = jQuery.data( src ),
            curData = jQuery.data( dest, oldData );

        // Switch to use the internal data object, if it exists, for the next
        // stage of data copying
        if ( (oldData = oldData[ internalKey ]) ) {
            var events = oldData.events;
                    curData = curData[ internalKey ] = jQuery.extend({}, oldData);

            if ( events ) {
                delete curData.handle;
                curData.events = {};

                for ( var type in events ) {
                    for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
                        jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
                    }
                }
            }
        }
    }

    function cloneFixAttributes( src, dest ) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if ( dest.nodeType !== 1 ) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if ( dest.clearAttributes ) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if ( dest.mergeAttributes ) {
            dest.mergeAttributes( src );
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 fail to clone children inside object elements that use
        // the proprietary classid attribute value (rather than the type
        // attribute) to identify the type of content to display
        if ( nodeName === "object" ) {
            dest.outerHTML = src.outerHTML;

        } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            if ( src.checked ) {
                dest.defaultChecked = dest.checked = src.checked;
            }

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if ( dest.value !== src.value ) {
                dest.value = src.value;
            }

        // IE6-8 fails to return the selected option to the default selected
        // state when cloning options
        } else if ( nodeName === "option" ) {
            dest.selected = src.defaultSelected;

        // IE6-8 fails to set the defaultValue to the correct value when
        // cloning other types of input fields
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute( jQuery.expando );
    }

    jQuery.buildFragment = function( args, nodes, scripts ) {
        var fragment, cacheable, cacheresults, doc;

      // nodes may contain either an explicit document object,
      // a jQuery collection or context object.
      // If nodes[0] contains a valid object to assign to doc
      if ( nodes && nodes[0] ) {
        doc = nodes[0].ownerDocument || nodes[0];
      }

      // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if ( !doc.createDocumentFragment ) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
            args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

            cacheable = true;

            cacheresults = jQuery.fragments[ args[0] ];
            if ( cacheresults && cacheresults !== 1 ) {
                fragment = cacheresults;
            }
        }

        if ( !fragment ) {
            fragment = doc.createDocumentFragment();
            jQuery.clean( args, doc, fragment, scripts );
        }

        if ( cacheable ) {
            jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var ret = [],
                insert = jQuery( selector ),
                parent = this.length === 1 && this[0].parentNode;

            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
                insert[ original ]( this[0] );
                return this;

            } else {
                for ( var i = 0, l = insert.length; i < l; i++ ) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery( insert[i] )[ original ]( elems );
                    ret = ret.concat( elems );
                }

                return this.pushStack( ret, name, insert.selector );
            }
        };
    });

    function getAll( elem ) {
        if ( "getElementsByTagName" in elem ) {
            return elem.getElementsByTagName( "*" );

        } else if ( "querySelectorAll" in elem ) {
            return elem.querySelectorAll( "*" );

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked( elem ) {
        if ( elem.type === "checkbox" || elem.type === "radio" ) {
            elem.defaultChecked = elem.checked;
        }
    }
    // Finds all inputs and passes them to fixDefaultChecked
    function findInputs( elem ) {
        if ( jQuery.nodeName( elem, "input" ) ) {
            fixDefaultChecked( elem );
        } else if ( "getElementsByTagName" in elem ) {
            jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
        }
    }

    jQuery.extend({
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var clone = elem.cloneNode(true),
                    srcElements,
                    destElements,
                    i;

            if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                    (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes( elem, clone );

                // Using Sizzle here is crazy slow, so we use getElementsByTagName
                // instead
                srcElements = getAll( elem );
                destElements = getAll( clone );

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for ( i = 0; srcElements[i]; ++i ) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if ( destElements[i] ) {
                        cloneFixAttributes( srcElements[i], destElements[i] );
                    }
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                cloneCopyEvent( elem, clone );

                if ( deepDataAndEvents ) {
                    srcElements = getAll( elem );
                    destElements = getAll( clone );

                    for ( i = 0; srcElements[i]; ++i ) {
                        cloneCopyEvent( srcElements[i], destElements[i] );
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function( elems, context, fragment, scripts ) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if ( typeof context.createElement === "undefined" ) {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [], j;

            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( typeof elem === "number" ) {
                    elem += "";
                }

                if ( !elem ) {
                    continue;
                }

                // Convert html string into DOM nodes
                if ( typeof elem === "string" ) {
                    if ( !rhtml.test( elem ) ) {
                        elem = context.createTextNode( elem );
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
                            wrap = wrapMap[ tag ] || wrapMap._default,
                            depth = wrap[0],
                            div = context.createElement("div");

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while ( depth-- ) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if ( !jQuery.support.tbody ) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
                                tbody = tag === "table" && !hasBody ?
                                    div.firstChild && div.firstChild.childNodes :

                                    // String was a bare <thead> or <tfoot>
                                    wrap[1] === "<table>" && !hasBody ?
                                        div.childNodes :
                                        [];

                            for ( j = tbody.length - 1; j >= 0 ; --j ) {
                                if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                                    tbody[ j ].parentNode.removeChild( tbody[ j ] );
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                            div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if ( !jQuery.support.appendChecked ) {
                    if ( elem[0] && typeof (len = elem.length) === "number" ) {
                        for ( j = 0; j < len; j++ ) {
                            findInputs( elem[j] );
                        }
                    } else {
                        findInputs( elem );
                    }
                }

                if ( elem.nodeType ) {
                    ret.push( elem );
                } else {
                    ret = jQuery.merge( ret, elem );
                }
            }

            if ( fragment ) {
                checkScriptType = function( elem ) {
                    return !elem.type || rscriptType.test( elem.type );
                };
                for ( i = 0; ret[i]; i++ ) {
                    if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
                        scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

                    } else {
                        if ( ret[i].nodeType === 1 ) {
                            var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

                            ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
                        }
                        fragment.appendChild( ret[i] );
                    }
                }
            }

            return ret;
        },

        cleanData: function( elems ) {
            var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

            for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
                    continue;
                }

                id = elem[ jQuery.expando ];

                if ( id ) {
                    data = cache[ id ] && cache[ id ][ internalKey ];

                    if ( data && data.events ) {
                        for ( var type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if ( data.handle ) {
                            data.handle.elem = null;
                        }
                    }

                    if ( deleteExpando ) {
                        delete elem[ jQuery.expando ];

                    } else if ( elem.removeAttribute ) {
                        elem.removeAttribute( jQuery.expando );
                    }

                    delete cache[ id ];
                }
            }
        }
    });

    function evalScript( i, elem ) {
        if ( elem.src ) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
        }

        if ( elem.parentNode ) {
            elem.parentNode.removeChild( elem );
        }
    }




    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        // fixed for IE9, see #8346
        rupper = /([A-Z]|^ms)/g,
        rnumpx = /^-?\d+(?:px)?$/i,
        rnum = /^-?\d/,
        rrelNum = /^([\-+])=([\-+.\de]+)/,

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssWidth = [ "Left", "Right" ],
        cssHeight = [ "Top", "Bottom" ],
        curCSS,

        getComputedStyle,
        currentStyle;

    jQuery.fn.css = function( name, value ) {
        // Setting 'undefined' is a no-op
        if ( arguments.length === 2 && value === undefined ) {
            return this;
        }

        return jQuery.access( this, name, value, true, function( elem, name, value ) {
            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity", "opacity" );
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, origName = jQuery.camelCase( name ),
                style = elem.style, hooks = jQuery.cssHooks[ origName ];

            name = jQuery.cssProps[ origName ] || origName;

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                    value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if ( value == null || type === "number" && isNaN( value ) ) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[ name ] = value;
                    } catch(e) {}
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra ) {
            var ret, hooks;

            // Make sure that we're working with the right name
            name = jQuery.camelCase( name );
            hooks = jQuery.cssHooks[ name ];
            name = jQuery.cssProps[ name ] || name;

            // cssFloat needs a special treatment
            if ( name === "cssFloat" ) {
                name = "float";
            }

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
                return ret;

            // Otherwise, if a way to get the computed value exists, use that
            } else if ( curCSS ) {
                return curCSS( elem, name );
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function( elem, options, callback ) {
            var old = {};

            // Remember the old values, and insert the new ones
            for ( var name in options ) {
                old[ name ] = elem.style[ name ];
                elem.style[ name ] = options[ name ];
            }

            callback.call( elem );

            // Revert the old values
            for ( name in options ) {
                elem.style[ name ] = old[ name ];
            }
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                var val;

                if ( computed ) {
                    if ( elem.offsetWidth !== 0 ) {
                        return getWH( elem, name, extra );
                    } else {
                        jQuery.swap( elem, cssShow, function() {
                            val = getWH( elem, name, extra );
                        });
                    }

                    return val;
                }
            },

            set: function( elem, value ) {
                if ( rnumpx.test( value ) ) {
                    // ignore negative width and height values #1599
                    value = parseFloat( value );

                    if ( value >= 0 ) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if ( !jQuery.support.opacity ) {
        jQuery.cssHooks.opacity = {
            get: function( elem, computed ) {
                // IE uses filters for opacity
                return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                    ( parseFloat( RegExp.$1 ) / 100 ) + "" :
                    computed ? "1" : "";
            },

            set: function( elem, value ) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNaN( value ) ? "" : "alpha(opacity=" + value * 100 + ")",
                    filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute( "filter" );

                    // if there there is no filter style applied in a css rule, we are done
                    if ( currentStyle && !currentStyle.filter ) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test( filter ) ?
                    filter.replace( ralpha, opacity ) :
                    filter + " " + opacity;
            }
        };
    }

    jQuery(function() {
        // This hook cannot be added until DOM ready because the support test
        // for it is not run until after DOM ready
        if ( !jQuery.support.reliableMarginRight ) {
            jQuery.cssHooks.marginRight = {
                get: function( elem, computed ) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    var ret;
                    jQuery.swap( elem, { "display": "inline-block" }, function() {
                        if ( computed ) {
                            ret = curCSS( elem, "margin-right", "marginRight" );
                        } else {
                            ret = elem.style.marginRight;
                        }
                    });
                    return ret;
                }
            };
        }
    });

    if ( document.defaultView && document.defaultView.getComputedStyle ) {
        getComputedStyle = function( elem, name ) {
            var ret, defaultView, computedStyle;

            name = name.replace( rupper, "-$1" ).toLowerCase();

            if ( !(defaultView = elem.ownerDocument.defaultView) ) {
                return undefined;
            }

            if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
                ret = computedStyle.getPropertyValue( name );
                if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                    ret = jQuery.style( elem, name );
                }
            }

            return ret;
        };
    }

    if ( document.documentElement.currentStyle ) {
        currentStyle = function( elem, name ) {
            var left,
                ret = elem.currentStyle && elem.currentStyle[ name ],
                rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
                style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
                // Remember the original values
                left = style.left;

                // Put in the new values to get a computed value out
                if ( rsLeft ) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if ( rsLeft ) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH( elem, name, extra ) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            which = name === "width" ? cssWidth : cssHeight;

        if ( val > 0 ) {
            if ( extra !== "border" ) {
                jQuery.each( which, function() {
                    if ( !extra ) {
                        val -= parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
                    }
                    if ( extra === "margin" ) {
                        val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
                    } else {
                        val -= parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
                    }
                });
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, name );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;

        // Add padding, border, margin
        if ( extra ) {
            jQuery.each( which, function() {
                val += parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;
                if ( extra !== "padding" ) {
                    val += parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) || 0;
                }
                if ( extra === "margin" ) {
                    val += parseFloat( jQuery.css( elem, extra + this ) ) || 0;
                }
            });
        }

        return val + "px";
    }

    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.hidden = function( elem ) {
            var width = elem.offsetWidth,
                height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
        };

        jQuery.expr.filters.visible = function( elem ) {
            return !jQuery.expr.filters.hidden( elem );
        };
    }




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rspacesAjax = /\s+/,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Document location
        ajaxLocation,

        // Document location segments
        ajaxLocParts,

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = ["*/"] + ["*"];

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch( e ) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            if ( jQuery.isFunction( func ) ) {
                var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
                    i = 0,
                    length = dataTypes.length,
                    dataType,
                    list,
                    placeBefore;

                // For each dataType in the dataTypeExpression
                for(; i < length; i++ ) {
                    dataType = dataTypes[ i ];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test( dataType );
                    if ( placeBefore ) {
                        dataType = dataType.substr( 1 ) || "*";
                    }
                    list = structure[ dataType ] = structure[ dataType ] || [];
                    // then we add to the structure accordingly
                    list[ placeBefore ? "unshift" : "push" ]( func );
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
            dataType /* internal */, inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[ 0 ];
        inspected = inspected || {};

        inspected[ dataType ] = true;

        var list = structure[ dataType ],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = ( structure === prefilters ),
            selection;

        for(; i < length && ( executeOnly || !selection ); i++ ) {
            selection = list[ i ]( options, originalOptions, jqXHR );
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if ( typeof selection === "string" ) {
                if ( !executeOnly || inspected[ selection ] ) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift( selection );
                    selection = inspectPrefiltersOrTransports(
                            structure, options, originalOptions, jqXHR, selection, inspected );
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
            selection = inspectPrefiltersOrTransports(
                    structure, options, originalOptions, jqXHR, "*", inspected );
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }
    }

    jQuery.fn.extend({
        load: function( url, params, callback ) {
            if ( typeof url !== "string" && _load ) {
                return _load.apply( this, arguments );

            // Don't do a request if no elements are being requested
            } else if ( !this.length ) {
                return this;
            }

            var off = url.indexOf( " " );
            if ( off >= 0 ) {
                var selector = url.slice( off, url.length );
                url = url.slice( 0, off );
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if ( params ) {
                // If it's a function
                if ( jQuery.isFunction( params ) ) {
                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                // Otherwise, build a param string
                } else if ( typeof params === "object" ) {
                    params = jQuery.param( params, jQuery.ajaxSettings.traditional );
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                // Complete callback (responseText is used internally)
                complete: function( jqXHR, status, responseText ) {
                    // Store the response as specified by the jqXHR object
                    responseText = jqXHR.responseText;
                    // If successful, inject the HTML into all the matched elements
                    if ( jqXHR.isResolved() ) {
                        // #4825: Get the actual response in case
                        // a dataFilter is present in ajaxSettings
                        jqXHR.done(function( r ) {
                            responseText = r;
                        });
                        // See if a selector was specified
                        self.html( selector ?
                            // Create a dummy div to hold the results
                            jQuery("<div>")
                                // inject the contents of the document in, removing the scripts
                                // to avoid any 'Permission Denied' errors in IE
                                .append(responseText.replace(rscript, ""))

                                // Locate the specified elements
                                .find(selector) :

                            // If not, just inject the full result
                            responseText );
                    }

                    if ( callback ) {
                        self.each( callback, [ responseText, status, jqXHR ] );
                    }
                }
            });

            return this;
        },

        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },

        serializeArray: function() {
            return this.map(function(){
                return this.elements ? jQuery.makeArray( this.elements ) : this;
            })
            .filter(function(){
                return this.name && !this.disabled &&
                    ( this.checked || rselectTextarea.test( this.nodeName ) ||
                        rinput.test( this.type ) );
            })
            .map(function( i, elem ){
                var val = jQuery( this ).val();

                return val == null ?
                    null :
                    jQuery.isArray( val ) ?
                        jQuery.map( val, function( val, i ){
                            return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                        }) :
                        { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
            }).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
        jQuery.fn[ o ] = function( f ){
            return this.bind( o, f );
        };
    });

    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
            // shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            if ( settings ) {
                // Building a settings object
                ajaxExtend( target, jQuery.ajaxSettings );
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend( target, settings );
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s &&
                    ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
                            jQuery( callbackContext ) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery._Deferred(),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // ifModified key
                ifModifiedKey,
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // The jqXHR state
                state = 0,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Fake xhr
                jqXHR = {

                    readyState: 0,

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        if ( !state ) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match === undefined ? null : match;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        statusText = statusText || "abort";
                        if ( transport ) {
                            transport.abort( statusText );
                        }
                        done( 0, statusText );
                        return this;
                    }
                };

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done( status, nativeStatusText, responses, headers ) {

                // Called once
                if ( state === 2 ) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                var isSuccess,
                    success,
                    error,
                    statusText = nativeStatusText,
                    response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
                    lastModified,
                    etag;

                // If successful, handle type chaining
                if ( status >= 200 && status < 300 || status === 304 ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {

                        if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
                            jQuery.lastModified[ ifModifiedKey ] = lastModified;
                        }
                        if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
                            jQuery.etag[ ifModifiedKey ] = etag;
                        }
                    }

                    // If not modified
                    if ( status === 304 ) {

                        statusText = "notmodified";
                        isSuccess = true;

                    // If we have data
                    } else {

                        try {
                            success = ajaxConvert( s, response );
                            statusText = "success";
                            isSuccess = true;
                        } catch(e) {
                            // We have a parsererror
                            statusText = "parsererror";
                            error = e;
                        }
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if( !statusText || status ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = "" + ( nativeStatusText || statusText );

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                            [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger( "ajaxStop" );
                    }
                }
            }

            // Attach deferreds
            deferred.promise( jqXHR );
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.done;

            // Status-dependent callbacks
            jqXHR.statusCode = function( map ) {
                if ( map ) {
                    var tmp;
                    if ( state < 2 ) {
                        for( tmp in map ) {
                            statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                        }
                    } else {
                        tmp = map[ jqXHR.status ];
                        jqXHR.then( tmp, tmp );
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

            // Determine if a cross-domain request is in order
            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                            ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                );
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefiler, stop there
            if ( state === 2 ) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger( "ajaxStart" );
            }

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // If data is available, append data to url
                if ( s.data ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if ( s.cache === false ) {

                    var ts = jQuery.now(),
                        // try replacing _= if it is there
                        ret = s.url.replace( rts, "$1_=" + ts );

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                ifModifiedKey = ifModifiedKey || s.url;
                if ( jQuery.lastModified[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
                }
                if ( jQuery.etag[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                    // Abort if not done already
                    jqXHR.abort();
                    return false;

            }

            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout( function(){
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch (e) {
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
                    // Simply rethrow otherwise
                    } else {
                        jQuery.error( e );
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function( a, traditional ) {
            var s = [],
                add = function( key, value ) {
                    // If value is a function, invoke it and return its value
                    value = jQuery.isFunction( value ) ? value() : value;
                    s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                };

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if ( traditional === undefined ) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                // Serialize the form elements
                jQuery.each( a, function() {
                    add( this.name, this.value );
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for ( var prefix in a ) {
                    buildParams( prefix, a[ prefix ], traditional, add );
                }
            }

            // Return the resulting serialization
            return s.join( "&" ).replace( r20, "+" );
        }
    });

    function buildParams( prefix, obj, traditional, add ) {
        if ( jQuery.isArray( obj ) ) {
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
                }
            });

        } else if ( !traditional && obj != null && typeof obj === "object" ) {
            // Serialize object item.
            for ( var name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {
            // Serialize scalar item.
            add( prefix, obj );
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {

        var contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields,
            ct,
            type,
            finalDataType,
            firstDataType;

        // Fill responseXXX fields
        for( type in responseFields ) {
            if ( type in responses ) {
                jqXHR[ responseFields[type] ] = responses[ type ];
            }
        }

        // Remove auto dataType and get content-type in the process
        while( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert( s, response ) {

        // Apply the dataFilter if provided
        if ( s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        var dataTypes = s.dataTypes,
            converters = {},
            i,
            key,
            length = dataTypes.length,
            tmp,
            // Current and previous dataTypes
            current = dataTypes[ 0 ],
            prev,
            // Conversion expression
            conversion,
            // Conversion function
            conv,
            // Conversion functions (transitive conversion)
            conv1,
            conv2;

        // For each dataType in the chain
        for( i = 1; i < length; i++ ) {

            // Create converters map
            // with lowercased keys
            if ( i === 1 ) {
                for( key in s.converters ) {
                    if( typeof key === "string" ) {
                        converters[ key.toLowerCase() ] = s.converters[ key ];
                    }
                }
            }

            // Get the dataTypes
            prev = current;
            current = dataTypes[ i ];

            // If current is auto dataType, update it to prev
            if( current === "*" ) {
                current = prev;
            // If no auto and dataTypes are actually different
            } else if ( prev !== "*" && prev !== current ) {

                // Get the converter
                conversion = prev + " " + current;
                conv = converters[ conversion ] || converters[ "* " + current ];

                // If there is no direct converter, search transitively
                if ( !conv ) {
                    conv2 = undefined;
                    for( conv1 in converters ) {
                        tmp = conv1.split( " " );
                        if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
                            conv2 = converters[ tmp[1] + " " + current ];
                            if ( conv2 ) {
                                conv1 = converters[ conv1 ];
                                if ( conv1 === true ) {
                                    conv = conv2;
                                } else if ( conv2 === true ) {
                                    conv = conv1;
                                }
                                break;
                            }
                        }
                    }
                }
                // If we found no converter, dispatch an error
                if ( !( conv || conv2 ) ) {
                    jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
                }
                // If found converter is not an equivalence
                if ( conv !== true ) {
                    // Convert with 1 or 2 converters accordingly
                    response = conv ? conv( response ) : conv2( conv1(response) );
                }
            }
        }
        return response;
    }




    var jsc = jQuery.now(),
        jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            return jQuery.expando + "_" + ( jsc++ );
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
            ( typeof s.data === "string" );

        if ( s.dataTypes[ 0 ] === "jsonp" ||
            s.jsonp !== false && ( jsre.test( s.url ) ||
                    inspectData && jsre.test( s.data ) ) ) {

            var responseContainer,
                jsonpCallback = s.jsonpCallback =
                    jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
                previous = window[ jsonpCallback ],
                url = s.url,
                data = s.data,
                replace = "$1" + jsonpCallback + "$2";

            if ( s.jsonp !== false ) {
                url = url.replace( jsre, replace );
                if ( s.url === url ) {
                    if ( inspectData ) {
                        data = data.replace( jsre, replace );
                    }
                    if ( s.data === data ) {
                        // Add callback manually
                        url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                    }
                }
            }

            s.url = url;
            s.data = data;

            // Install callback
            window[ jsonpCallback ] = function( response ) {
                responseContainer = [ response ];
            };

            // Clean-up function
            jqXHR.always(function() {
                // Set callback back to previous value
                window[ jsonpCallback ] = previous;
                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( previous ) ) {
                    window[ jsonpCallback ]( responseContainer[ 0 ] );
                }
            });

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if ( !responseContainer ) {
                    jQuery.error( jsonpCallback + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // force json dataType
            s.dataTypes[ 0 ] = "json";

            // Delegate to script
            return "script";
        }
    });




    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function(s) {

        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {

            var script,
                head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

            return {

                send: function( _, callback ) {

                    script = document.createElement( "script" );

                    script.async = "async";

                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function( _, isAbort ) {

                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if ( head && script.parentNode ) {
                                head.removeChild( script );
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore( script, head.firstChild );
                },

                abort: function() {
                    if ( script ) {
                        script.onload( 0, 1 );
                    }
                }
            };
        }
    });




    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
        xhrOnUnloadAbort = window.ActiveXObject ? function() {
            // Abort all pending requests
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( 0, 1 );
            }
        } : false,
        xhrId = 0,
        xhrCallbacks;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch( e ) {}
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch( e ) {}
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
        /* Microsoft failed to properly
         * implement the XMLHttpRequest in IE7 (can't request local files),
         * so we use the ActiveXObject when it is available
         * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
         * we need a fallback.
         */
        function() {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;

    // Determine support properties
    (function( xhr ) {
        jQuery.extend( jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ( "withCredentials" in xhr )
        });
    })( jQuery.ajaxSettings.xhr() );

    // Create transport if the browser can provide an xhr
    if ( jQuery.support.ajax ) {

        jQuery.ajaxTransport(function( s ) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if ( !s.crossDomain || jQuery.support.cors ) {

                var callback;

                return {
                    send: function( headers, complete ) {

                        // Get a new xhr
                        var xhr = s.xhr(),
                            handle,
                            i;

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if ( s.username ) {
                            xhr.open( s.type, s.url, s.async, s.username, s.password );
                        } else {
                            xhr.open( s.type, s.url, s.async );
                        }

                        // Apply custom fields if provided
                        if ( s.xhrFields ) {
                            for ( i in s.xhrFields ) {
                                xhr[ i ] = s.xhrFields[ i ];
                            }
                        }

                        // Override mime type if needed
                        if ( s.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( s.mimeType );
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if ( !s.crossDomain && !headers["X-Requested-With"] ) {
                            headers[ "X-Requested-With" ] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }
                        } catch( _ ) {}

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send( ( s.hasContent && s.data ) || null );

                        // Listener
                        callback = function( _, isAbort ) {

                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occured
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if ( handle ) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if ( xhrOnUnloadAbort ) {
                                            delete xhrCallbacks[ handle ];
                                        }
                                    }

                                    // If it's an abort
                                    if ( isAbort ) {
                                        // Abort it manually if needed
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if ( xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }
                                        responses.text = xhr.responseText;

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch( e ) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if ( !status && s.isLocal && !s.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                        // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch( firefoxAccessException ) {
                                if ( !isAbort ) {
                                    complete( -1, firefoxAccessException );
                                }
                            }

                            // Call complete if needed
                            if ( responses ) {
                                complete( status, statusText, responses, responseHeaders );
                            }
                        };

                        // if we're in sync mode or it's in cache
                        // and has been retrieved directly (IE6 & IE7)
                        // we need to manually fire the callback
                        if ( !s.async || xhr.readyState === 4 ) {
                            callback();
                        } else {
                            handle = ++xhrId;
                            if ( xhrOnUnloadAbort ) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if ( !xhrCallbacks ) {
                                    xhrCallbacks = {};
                                    jQuery( window ).unload( xhrOnUnloadAbort );
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[ handle ] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function() {
                        if ( callback ) {
                            callback(0,1);
                        }
                    }
                };
            }
        });
    }




    var elemdisplay = {},
        iframe, iframeDoc,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
        timerId,
        fxAttrs = [
            // height animations
            [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
            // width animations
            [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
            // opacity animations
            [ "opacity" ]
        ],
        fxNow;

    jQuery.fn.extend({
        show: function( speed, easing, callback ) {
            var elem, display;

            if ( speed || speed === 0 ) {
                return this.animate( genFx("show", 3), speed, easing, callback);

            } else {
                for ( var i = 0, j = this.length; i < j; i++ ) {
                    elem = this[i];

                    if ( elem.style ) {
                        display = elem.style.display;

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
                            display = elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
                            jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    elem = this[i];

                    if ( elem.style ) {
                        display = elem.style.display;

                        if ( display === "" || display === "none" ) {
                            elem.style.display = jQuery._data(elem, "olddisplay") || "";
                        }
                    }
                }

                return this;
            }
        },

        hide: function( speed, easing, callback ) {
            if ( speed || speed === 0 ) {
                return this.animate( genFx("hide", 3), speed, easing, callback);

            } else {
                for ( var i = 0, j = this.length; i < j; i++ ) {
                    if ( this[i].style ) {
                        var display = jQuery.css( this[i], "display" );

                        if ( display !== "none" && !jQuery._data( this[i], "olddisplay" ) ) {
                            jQuery._data( this[i], "olddisplay", display );
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for ( i = 0; i < j; i++ ) {
                    if ( this[i].style ) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function( fn, fn2, callback ) {
            var bool = typeof fn === "boolean";

            if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
                this._toggle.apply( this, arguments );

            } else if ( fn == null || bool ) {
                this.each(function() {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[ state ? "show" : "hide" ]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function( speed, to, easing, callback ) {
            return this.filter(":hidden").css("opacity", 0).show().end()
                        .animate({opacity: to}, speed, easing, callback);
        },

        animate: function( prop, speed, easing, callback ) {
            var optall = jQuery.speed(speed, easing, callback);

            if ( jQuery.isEmptyObject( prop ) ) {
                return this.each( optall.complete, [ false ] );
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend( {}, prop );

            return this[ optall.queue === false ? "each" : "queue" ](function() {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if ( optall.queue === false ) {
                    jQuery._mark( this );
                }

                var opt = jQuery.extend( {}, optall ),
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    name, val, p,
                    display, e,
                    parts, start, end, unit;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for ( p in prop ) {

                    // property name normalization
                    name = jQuery.camelCase( p );
                    if ( p !== name ) {
                        prop[ name ] = prop[ p ];
                        delete prop[ p ];
                    }

                    val = prop[ name ];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if ( jQuery.isArray( val ) ) {
                        opt.animatedProperties[ name ] = val[ 1 ];
                        val = prop[ name ] = val[ 0 ];
                    } else {
                        opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
                    }

                    if ( val === "hide" && hidden || val === "show" && !hidden ) {
                        return opt.complete.call( this );
                    }

                    if ( isElement && ( name === "height" || name === "width" ) ) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if ( jQuery.css( this, "display" ) === "inline" &&
                                jQuery.css( this, "float" ) === "none" ) {
                            if ( !jQuery.support.inlineBlockNeedsLayout ) {
                                this.style.display = "inline-block";

                            } else {
                                display = defaultDisplay( this.nodeName );

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if ( display === "inline" ) {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }
                }

                if ( opt.overflow != null ) {
                    this.style.overflow = "hidden";
                }

                for ( p in prop ) {
                    e = new jQuery.fx( this, opt, p );
                    val = prop[ p ];

                    if ( rfxtypes.test(val) ) {
                        e[ val === "toggle" ? hidden ? "show" : "hide" : val ]();

                    } else {
                        parts = rfxnum.exec( val );
                        start = e.cur();

                        if ( parts ) {
                            end = parseFloat( parts[2] );
                            unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

                            // We need to compute starting value
                            if ( unit !== "px" ) {
                                jQuery.style( this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style( this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if ( parts[1] ) {
                                end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
                            }

                            e.custom( start, end, unit );

                        } else {
                            e.custom( start, val, "" );
                        }
                    }
                }

                // For JS strict compliance
                return true;
            });
        },

        stop: function( clearQueue, gotoEnd ) {
            if ( clearQueue ) {
                this.queue([]);
            }

            this.each(function() {
                var timers = jQuery.timers,
                    i = timers.length;
                // clear marker counters if we know they won't be
                if ( !gotoEnd ) {
                    jQuery._unmark( true, this );
                }
                while ( i-- ) {
                    if ( timers[i].elem === this ) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if ( !gotoEnd ) {
                this.dequeue();
            }

            return this;
        }

    });

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout( clearFxNow, 0 );
        return ( fxNow = jQuery.now() );
    }

    function clearFxNow() {
        fxNow = undefined;
    }

    // Generate parameters to create a standard animation
    function genFx( type, num ) {
        var obj = {};

        jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
            obj[ this ] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    });

    jQuery.extend({
        speed: function( speed, easing, fn ) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
                    jQuery.isFunction( speed ) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function( noUnmark ) {
                if ( jQuery.isFunction( opt.old ) ) {
                    opt.old.call( this );
                }

                if ( opt.queue !== false ) {
                    jQuery.dequeue( this );
                } else if ( noUnmark !== false ) {
                    jQuery._unmark( this );
                }
            };

            return opt;
        },

        easing: {
            linear: function( p, n, firstNum, diff ) {
                return firstNum + diff * p;
            },
            swing: function( p, n, firstNum, diff ) {
                return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function( elem, options, prop ) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            options.orig = options.orig || {};
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function() {
            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
        },

        // Get the current size
        cur: function() {
            if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
                return this.elem[ this.prop ];
            }

            var parsed,
                r = jQuery.css( this.elem, this.prop );
            // Empty strings, null, undefined and "auto" are converted to 0,
            // complex values such as "rotate(1rad)" are returned as is,
            // simple values such as "10px" are parsed to Float.
            return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
        },

        // Start an animation from one number to another
        custom: function( from, to, unit ) {
            var self = this,
                fx = jQuery.fx;

            this.startTime = fxNow || createFxNow();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
            this.now = this.start;
            this.pos = this.state = 0;

            function t( gotoEnd ) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if ( t() && jQuery.timers.push(t) && !timerId ) {
                timerId = setInterval( fx.tick, fx.interval );
            }
        },

        // Simple 'show' function
        show: function() {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery( this.elem ).show();
        },

        // Simple 'hide' function
        hide: function() {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function( gotoEnd ) {
            var t = fxNow || createFxNow(),
                done = true,
                elem = this.elem,
                options = this.options,
                i, n;

            if ( gotoEnd || t >= options.duration + this.startTime ) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[ this.prop ] = true;

                for ( i in options.animatedProperties ) {
                    if ( options.animatedProperties[i] !== true ) {
                        done = false;
                    }
                }

                if ( done ) {
                    // Reset the overflow
                    if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

                        jQuery.each( [ "", "X", "Y" ], function (index, value) {
                            elem.style[ "overflow" + value ] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if ( options.hide ) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if ( options.hide || options.show ) {
                        for ( var p in options.animatedProperties ) {
                            jQuery.style( elem, p, options.orig[p] );
                        }
                    }

                    // Execute the complete function
                    options.complete.call( elem );
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if ( options.duration == Infinity ) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[ options.animatedProperties[ this.prop ] ]( this.state, n, 0, 1, options.duration );
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend( jQuery.fx, {
        tick: function() {
            for ( var timers = jQuery.timers, i = 0 ; i < timers.length ; ++i ) {
                if ( !timers[i]() ) {
                    timers.splice(i--, 1);
                }
            }

            if ( !timers.length ) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function() {
            clearInterval( timerId );
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function( fx ) {
                jQuery.style( fx.elem, "opacity", fx.now );
            },

            _default: function( fx ) {
                if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
                    fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[ fx.prop ] = fx.now;
                }
            }
        }
    });

    if ( jQuery.expr && jQuery.expr.filters ) {
        jQuery.expr.filters.animated = function( elem ) {
            return jQuery.grep(jQuery.timers, function( fn ) {
                return elem === fn.elem;
            }).length;
        };
    }

    // Try to restore the default display value of an element
    function defaultDisplay( nodeName ) {

        if ( !elemdisplay[ nodeName ] ) {

            var body = document.body,
                elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
                display = elem.css( "display" );

            elem.remove();

            // If the simple way fails,
            // get element's real default display by attaching it to a temp iframe
            if ( display === "none" || display === "" ) {
                // No iframe to use yet, so create it
                if ( !iframe ) {
                    iframe = document.createElement( "iframe" );
                    iframe.frameBorder = iframe.width = iframe.height = 0;
                }

                body.appendChild( iframe );

                // Create a cacheable copy of the iframe document on first call.
                // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
                // document to it; WebKit & Firefox won't allow reusing the iframe document.
                if ( !iframeDoc || !iframe.createElement ) {
                    iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
                    iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
                    iframeDoc.close();
                }

                elem = iframeDoc.createElement( nodeName );

                iframeDoc.body.appendChild( elem );

                display = jQuery.css( elem, "display" );

                body.removeChild( iframe );
            }

            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }

        return elemdisplay[ nodeName ];
    }




    var rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;

    if ( "getBoundingClientRect" in document.documentElement ) {
        jQuery.fn.offset = function( options ) {
            var elem = this[0], box;

            if ( options ) {
                return this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
            }

            if ( !elem || !elem.ownerDocument ) {
                return null;
            }

            if ( elem === elem.ownerDocument.body ) {
                return jQuery.offset.bodyOffset( elem );
            }

            try {
                box = elem.getBoundingClientRect();
            } catch(e) {}

            var doc = elem.ownerDocument,
                docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if ( !box || !jQuery.contains( docElem, elem ) ) {
                return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
            }

            var body = doc.body,
                win = getWindow(doc),
                clientTop  = docElem.clientTop  || body.clientTop  || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
                scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
                top  = box.top  + scrollTop  - clientTop,
                left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function( options ) {
            var elem = this[0];

            if ( options ) {
                return this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
            }

            if ( !elem || !elem.ownerDocument ) {
                return null;
            }

            if ( elem === elem.ownerDocument.body ) {
                return jQuery.offset.bodyOffset( elem );
            }

            jQuery.offset.initialize();

            var computedStyle,
                offsetParent = elem.offsetParent,
                prevOffsetParent = elem,
                doc = elem.ownerDocument,
                docElem = doc.documentElement,
                body = doc.body,
                defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
                top = elem.offsetTop,
                left = elem.offsetLeft;

            while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
                if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top  -= elem.scrollTop;
                left -= elem.scrollLeft;

                if ( elem === offsetParent ) {
                    top  += elem.offsetTop;
                    left += elem.offsetLeft;

                    if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
                        top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                        left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
                    top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                    left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
                top  += body.offsetTop;
                left += body.offsetLeft;
            }

            if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
                top  += Math.max( docElem.scrollTop, body.scrollTop );
                left += Math.max( docElem.scrollLeft, body.scrollLeft );
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function() {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
                html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

            container.innerHTML = html;
            body.insertBefore( container, body.firstChild );
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild( container );
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function( body ) {
            var top = body.offsetTop,
                left = body.offsetLeft;

            jQuery.offset.initialize();

            if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
                top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
                left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function( elem, options, i ) {
            var position = jQuery.css( elem, "position" );

            // set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            var curElem = jQuery( elem ),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css( elem, "top" ),
                curCSSLeft = jQuery.css( elem, "left" ),
                calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );
            } else {
                curElem.css( props );
            }
        }
    };


    jQuery.fn.extend({
        position: function() {
            if ( !this[0] ) {
                return null;
            }

            var elem = this[0],

            // Get *real* offsetParent
            offsetParent = this.offsetParent(),

            // Get correct offsets
            offset       = this.offset(),
            parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
            offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

            // Add offsetParent borders
            parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
            parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

            // Subtract the two offsets
            return {
                top:  offset.top  - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each( ["Left", "Top"], function( i, name ) {
        var method = "scroll" + name;

        jQuery.fn[ method ] = function( val ) {
            var elem, win;

            if ( val === undefined ) {
                elem = this[ 0 ];

                if ( !elem ) {
                    return null;
                }

                win = getWindow( elem );

                // Return the scroll offset
                return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
                    jQuery.support.boxModel && win.document.documentElement[ method ] ||
                        win.document.body[ method ] :
                    elem[ method ];
            }

            // Set the scroll offset
            return this.each(function() {
                win = getWindow( this );

                if ( win ) {
                    win.scrollTo(
                        !i ? val : jQuery( win ).scrollLeft(),
                         i ? val : jQuery( win ).scrollTop()
                    );

                } else {
                    this[ method ] = val;
                }
            });
        };
    });

    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }




    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each([ "Height", "Width" ], function( i, name ) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn[ "inner" + name ] = function() {
            var elem = this[0];
            return elem && elem.style ?
                parseFloat( jQuery.css( elem, type, "padding" ) ) :
                null;
        };

        // outerHeight and outerWidth
        jQuery.fn[ "outer" + name ] = function( margin ) {
            var elem = this[0];
            return elem && elem.style ?
                parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
                null;
        };

        jQuery.fn[ type ] = function( size ) {
            // Get window width or height
            var elem = this[0];
            if ( !elem ) {
                return size == null ? null : this;
            }

            if ( jQuery.isFunction( size ) ) {
                return this.each(function( i ) {
                    var self = jQuery( this );
                    self[ type ]( size.call( this, i, self[ type ]() ) );
                });
            }

            if ( jQuery.isWindow( elem ) ) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement[ "client" + name ],
                    body = elem.document.body;
                return jQuery.support.boxModel && docElemProp ||
                    body && body[ "client" + name ] || docElemProp;

            // Get document width or height
            } else if ( elem.nodeType === 9 ) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
                    elem.documentElement["client" + name],
                    elem.body["scroll" + name], elem.documentElement["scroll" + name],
                    elem.body["offset" + name], elem.documentElement["offset" + name]
                );

            // Get or set width or height on the element
            } else if ( size === undefined ) {
                var orig = jQuery.css( elem, type ),
                    ret = parseFloat( orig );

                return jQuery.isNaN( ret ) ? orig : ret;

            // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css( type, typeof size === "string" ? size : size + "px" );
            }
        };

    });

    /* Importing _throw_error.js */
(function () {
    jQuery.find.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
    };

    jQuery.error = function (message) {
        throw typeof message === "object" ? message : new Error(message);
    };
})();
/* Done importing _throw_error.js */


    /* Importing _guard.js */
(function () {
    function lateGuard(toGuard) {
        if (typeof toGuard === 'function' && typeof P.guardCurrent === 'function') {
            return P.guardCurrent(toGuard);
        } else {
            return toGuard;
        }
    }

    var jQueryDeferred = jQuery._Deferred;
    jQuery._Deferred = function () {
        var _deferred = jQueryDeferred();
        var _done = _deferred.done;
        _deferred.done = function () {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
                args[i] = lateGuard(arguments[i]);
            }
            return _done.apply(this, args);
        };
        return _deferred;
    };
})();
/* Done importing _guard.js */


    /* Importing _onbeforeunload.js */
/**
 *  This event has been patched by jsanders on 13 June 2013.  The original jQuery 1.6.4 would overwrite
 *  any existing window.onbeforeunload hander with eventHandle.  This will allow both the setup and
 *  teardown methods to respect any existing onbeforeunload handler.
 *
 *  https://tt.amazon.com/0022275030
 */
(function () {
    var oldBeforeUnload;
    jQuery.event.special.beforeunload = {
        setup: function (data, namespaces, eventHandle) {
            oldBeforeUnload = this.onbeforeunload;
            // We only want to do this special case on windows
            if (jQuery.isWindow(this)) {
                this.onbeforeunload = function () {
                    var isOldEventAccessibleFunction = false;

                    // A function might not be accessible from where it is called, example cross origin iframe
                    // Sev 2 TT - https://tt.amazon.com/0409925346
                    try {
                        isOldEventAccessibleFunction = jQuery.isFunction(oldBeforeUnload);
                    }
                    catch(err) {
                        // skip if oldBeforeUnload is inaccessible from script source
                    }

                    if (isOldEventAccessibleFunction) {
                        oldBeforeUnload.apply(this, arguments);
                    }

                    eventHandle.apply(this, arguments);
                };
            }
        },

        teardown: function (namespaces, eventHandle) {
            this.onbeforeunload = oldBeforeUnload;
        }
    }
})();
/* Done importing _onbeforeunload.js */


    // Expose jQuery to the global object
    return jQuery;
}());

}
/////////////////////////
// END FILE jquery.js
/////////////////////////
/////////////////////////
// BEGIN FILE rtl-plugin.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// To guard from having jQuery.withoutRtl undefined on LTR locales

P.when('jQuery').execute('rtl-jquery-plugin', function(jQuery) {
    "use strict";

	jQuery.withoutRtl = function(func) {
		func.apply(this);
	};
});
/////////////////////////
// END FILE rtl-plugin.js
/////////////////////////

// END ASSET AmazonUIjQuery-3.0.332907.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPromise", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPromise-3.0.335545.0
/////////////////////////
// BEGIN FILE promise.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing _desktop.js */
/* Importing _promise_polyfill.js */
// AmazonUI Promise polyfill.
// GitHub: https://github.com/taylorhakes/promise-polyfill

/*
  Copyright (c) 2014 Taylor Hakes
  Copyright (c) 2014 Forbes Lindesay

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

P.register('3p-promise', function () {

    if(typeof window.Promise === 'function') {
      return window.Promise;
    }

    // Store setTimeout reference so promise-polyfill will be unaffected by
    // other code modifying setTimeout (like sinon.useFakeTimers())
    var setTimeoutFunc = setTimeout;

    function noop() {
    }

    // Use polyfill for setImmediate for performance gains
    var asap = (typeof setImmediate === 'function' && setImmediate) ||
      function (fn) {
        setTimeoutFunc(fn, 0);
      };

    var onUnhandledRejection = function onUnhandledRejection(err) {
      if (typeof console !== 'undefined' && console) {
        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
      }
    };

    // Polyfill for Function.prototype.bind
    function bind(fn, thisArg) {
      return function () {
        fn.apply(thisArg, arguments);
      };
    }

    function Promise(fn) {
      if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
      if (typeof fn !== 'function') throw new TypeError('not a function');
      this._state = 0;
      this._handled = false;
      this._value = undefined;
      this._deferreds = [];

      doResolve(fn, this);
    }

    function handle(self, deferred) {
      while (self._state === 3) {
        self = self._value;
      }
      if (self._state === 0) {
        self._deferreds.push(deferred);
        return;
      }
      self._handled = true;
      asap(function () {
        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
          return;
        }
        var ret;
        try {
          ret = cb(self._value);
        } catch (e) {
          reject(deferred.promise, e);
          return;
        }
        resolve(deferred.promise, ret);
      });
    }

    function resolve(self, newValue) {
      try {
        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
          var then = newValue.then;
          if (newValue instanceof Promise) {
            self._state = 3;
            self._value = newValue;
            finale(self);
            return;
          } else if (typeof then === 'function') {
            doResolve(bind(then, newValue), self);
            return;
          }
        }
        self._state = 1;
        self._value = newValue;
        finale(self);
      } catch (e) {
        reject(self, e);
      }
    }

    function reject(self, newValue) {
      self._state = 2;
      self._value = newValue;
      finale(self);
    }

    function finale(self) {
      if (self._state === 2 && self._deferreds.length === 0) {
        asap(function() {
          if (!self._handled) {
            onUnhandledRejection(self._value);
          }
        });
      }

      for (var i = 0, len = self._deferreds.length; i < len; i++) {
        handle(self, self._deferreds[i]);
      }
      self._deferreds = null;
    }

    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
      this.onRejected = typeof onRejected === 'function' ? onRejected : null;
      this.promise = promise;
    }

    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    function doResolve(fn, self) {
      var done = false;
      try {
        fn(function (value) {
          if (done) return;
          done = true;
          resolve(self, value);
        }, function (reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        });
      } catch (ex) {
        if (done) return;
        done = true;
        reject(self, ex);
      }
    }

    Promise.prototype['catch'] = function (onRejected) {
      return this.then(null, onRejected);
    };

    Promise.prototype.then = function (onFulfilled, onRejected) {
      var prom = new (this.constructor)(noop);

      handle(this, new Handler(onFulfilled, onRejected, prom));
      return prom;
    };

    Promise.all = function (arr) {
      var args = Array.prototype.slice.call(arr);

      return new Promise(function (resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;

        function res(i, val) {
          try {
            if (val && (typeof val === 'object' || typeof val === 'function')) {
              var then = val.then;
              if (typeof then === 'function') {
                then.call(val, function (val) {
                  res(i, val);
                }, reject);
                return;
              }
            }
            args[i] = val;
            if (--remaining === 0) {
              resolve(args);
            }
          } catch (ex) {
            reject(ex);
          }
        }

        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };

    Promise.resolve = function (value) {
      if (value && typeof value === 'object' && value.constructor === Promise) {
        return value;
      }

      return new Promise(function (resolve) {
        resolve(value);
      });
    };

    Promise.reject = function (value) {
      return new Promise(function (resolve, reject) {
        reject(value);
      });
    };

    Promise.race = function (values) {
      return new Promise(function (resolve, reject) {
        for (var i = 0, len = values.length; i < len; i++) {
          values[i].then(resolve, reject);
        }
      });
    };

    /**
     * Set the immediate function to execute callbacks
     * @param fn {function} Function to execute
     * @private
     */
    Promise._setImmediateFn = function _setImmediateFn(fn) {
      asap = fn;
    };

    Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
      onUnhandledRejection = fn;
    };

    return Promise;
});
/* Done importing _promise_polyfill.js */

/* Done importing _desktop.js */

/////////////////////////
// END FILE promise.js
/////////////////////////
// END ASSET AmazonUIPromise-3.0.335545.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS@base", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS@base-3.2.15990.0
/////////////////////////
// BEGIN FILE @js_debug_flag.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
var AUI_JS_DEBUG = true;
/////////////////////////
// END FILE @js_debug_flag.js
/////////////////////////
/////////////////////////
// BEGIN FILE a.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Base

'use strict';

P.when('jQuery').register('a-base', function(jQuery){

  return {
    version : function(){
      return '3.0';
    },
    $ : jQuery
  };
});
/////////////////////////
// END FILE a.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_declarative_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AmazonUI declarative action register instrumentation
 */
'use strict';

P.when('p-recorder-events', 'jQuery', 'a-analytics', 'a-util', 'a-constants', 'prv:a-post-atf')
  .register("prv:a-declarative-analytics", function (recorderEvents, $, analytics, util, constants, postAtf) { // jshint ignore:line
    var COUNT_NAME = 'usage:tti',
      // if ue is available, ue.t0 should be always available. if ue is not available, t0 will not be used.
      t0 = window.ue_t0 || window.aPageStart || Date.now(),
      daQueue = {}, // the queue for non-logged declarative action
      loggedDa = {}, // the already logged declarative action
      daSpots = {}; // a map for all the declarative elements on the page

    // AUI_TNR_UNHANDLED_EVENTS_167823:T1 is for Interaction Latency Log. Only record da register latency when the the weblab
    // is T1. We check it via check recorderEvents (work around for variant exploding)
    if (!(recorderEvents.length > 0 && window.ue)) {
      return {
        notify: constants.constants.NOOP,
        setOptions: constants.constants.NOOP
      };
    }

    /**
     * When A.declarative is called, push the action record to log queue. It does record every A.declarative
     * call, as far as the eventType is declared in recorderEvents. It doesn't care if there is elements for
     * this declarative action.
     * @param daName {string} the declarative event name
     * @param eventType {string} the event type, e.g. 'click'...
     */
    function recordDa(daName, eventType) {
      if (!daName || !eventType || util.indexOfArray(recorderEvents, eventType) === -1) {
        return;
      }
      var daKey = daName + '/' + eventType;
      if (loggedDa[daKey] || daQueue[daKey]) {
        return;
      }
      var latency = Date.now() - t0;
      daQueue[daKey] = {
        daName: daName,
        eventType: eventType,
        latency: latency
      };

      postAtf.execute(logQueuedDa);
    }

    /**
     * Scan the queued declarative actions, if the actionable elements exist on the page, then log it.
     * After scanning, empty the queue.
     * Note: If there is no actionable element for a declarative event, there are 2 possibilities:
     * 1. The DA is registered for a component doesn't exist on the page (it happens a lot for AUI components)
     * 2. The event handler is registered before the element is added to the page. In this case it will not cause
     * any non-actionable gap, so we ignore it.
     */
    function logQueuedDa() {
      /**
       * 1. Check the DA queue with the declarative markup recorded early, log and remove any action matched.
       * 2. If there is DA left in the queue, update the declarative markup map.
       * 3. Check the DA queue with updated declarative markup again, log and clean.
       * 4. If there is still DA left, there must be no declarative markup for it, clean them all.
       */
      processDaQueue();
      if (util.objectIsEmpty(daQueue)) {
        return;
      }
      // update the daSpots with all the data-action available on the page.
      $('[data-action]').each(function () {
        var daName = this.getAttribute('data-action');
        daSpots[daName] = true;
      });
      processDaQueue();
      daQueue = {};
    }

    /**
     * Go through DA queue, if the DA matches with a data-action on the page, log it.
     */
    function processDaQueue() {
      util.each(daQueue, function (daItem, daKey) {
        if (daSpots[daItem.daName]) {
          analytics.count(COUNT_NAME, daItem.latency);
          delete daQueue[daKey];
          loggedDa[daKey] = daItem;
        }
      });
    }

    return {
      notify: recordDa
    };
  });
/////////////////////////
// END FILE a_declarative_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_guard.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * Provides a set of helpers for building 'guards' around customer callbacks.
 * This depends on the 'decorate' function you see in 'a_ending.js'.
 */
P.register("prv:a-guard", function () {

    /** Wraps a function in a guard */
    function applyGuard(self, fn) {
        return self._guard && typeof fn === 'function' ?
            self._guard(fn) :
            fn;
    }

    return {

        /** Applies a guard to a function */
        fn: applyGuard,

        /** Produces version of an object with all functions guarded */
        obj: function (self, obj) {
            if ( !self._guard ) {
                return obj;
            }
            var result = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    result[key] = applyGuard(self, obj[key]);
                }
            }
            return result;
        }
    };
});

/////////////////////////
// END FILE a_guard.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_timing_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Wrapped Client Side Metric (CSM) APIs for tracking life cycle of AUI component.
 * This module will only work in weblab AUI_TNR_UNHANDLED_EVENTS_167823.
 */

'use strict';

P.when('p-recorder-events', 'a-analytics')
  .register("a-timing-analytics", function (recorderEvents, analytics) {

  /**
   * WORKAROUND
   * Due to variant explosion in filename, we put weblab control in code, rather
   * than variant control.
   *
   * @return {Boolean} Whether we are in weblab AUI_TNR_UNHANDLED_EVENTS_167823
   */
  function isWeblab() {
    return recorderEvents.length !== 0;
  }

  // -------------------------------------------------------------------------
  /**
   * Client Side Metric (CSM) provides API to log life cycle of widget/feature,
   * rather than the whole page. We use it for tracking when a P component
   * (aka feature) is ready.
   *
   * see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/Instrumentation/InstrumentingWidgets
   */

  /**
   * A list of feature names that are initialized for the logger. Log request on
   * non-initialized feature will be ignored.
   *
   * For AUI, the name represents the functionality we want to track.
   * For CSM, it's the namespace for log data.
   */
  var features = {};

  /**
   * The marks of CSM life cycle.
   * see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/Instrumentation/CSMforAJAX#How_the_scopes_are_combined
   */
  var MARK_START = 'bb'; // indicates the starting time of feature
  var MARK_DONE = 'cf'; // indicates the feature (P component) is ready
  var MARK_FLUSH = 'ld'; // tells CSM to publish to log result to server

  /**
   * A CSM parameter indicates we do logging in feature level rather than page level.
   */
  var WIDGET_INDICATOR = {wb: 1};

  var isWidgetApiAvailable = function() {
    return window.uet && window.uex;
  };

  /**
   * Register the given feature on logger.
   * @param feature An identifier; see `features`
   */
  function startWidgetLogging(feature) {
    features[feature] = true;
    if (!isWeblab() || !isWidgetApiAvailable()) { // always check availability lazily
      return;
    }
    window.uet(MARK_START, feature, WIDGET_INDICATOR);
  }

  /**
   * CALL `startWidgetLogging(feature)` BEFORE USING THIS.
   *
   * Mark the given feature as ready. If the feature is not registered with
   * `startWidgetLogging(feature)`, the request will be ignored.
   *
   * @param feature An identifier; see `features`
   */
  function stopWidgetLogging(feature) {
    if (!isWeblab() ||
        !isWidgetApiAvailable() ||
        !(feature in features)
      ) {
      return;
    }
    window.uet(MARK_DONE, feature, WIDGET_INDICATOR);
    window.uex(MARK_FLUSH, feature, WIDGET_INDICATOR);
  }

  function initMetrics() {
    startWidgetLogging("declarative");
    startWidgetLogging("A");
    startWidgetLogging("dropdown");
    startWidgetLogging("carousel");
  }
  initMetrics();

  return {
    startWidgetLogging: startWidgetLogging,
    stopWidgetLogging: stopWidgetLogging
  };
});
/////////////////////////
// END FILE a_timing_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_event_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Event handlers to track user interactions before the page is considered ready.
 *
 * Declarative Action (DA) will start to work until —
 * 1. corresponding dom family is ready
 * 2. declarative system is ready (aka `a-declarative`)
 * 3. interactive component register it's handler with declarative system
 *
 * * jquery event will start to work until —
 * 1. corresponding dom family is ready
 * 2. jquery system is ready ($.delegate, $.bind ...)
 * 3. interactive component register it's handler with jquery system
 *
 *
 * User might try to use (e.g. click or mouse over) these components
 * (e.g. dropdown or expander) before they are ready.
 *
 * We want to learn more details from this kind of user experience. This module
 * provides temporary event handlers which capture failed attempts, and log them
 * into Client Side Metric (CSM) system.
 *
 * Event handlers to track failed user attempts on declarative actions/jquery events
 * @see SIM-4780490 for a discussion
 */

// -----------------------------------------------------------------------------

"use strict";

P.when('p-recorder-events', 'jQuery', 'a-analytics', 'a-util', 'prv:a-event-context', 'prv:a-post-atf', 'prv:a-collect-p-debug')
  .register("a-event-analytics", function (recorderEvents, $, analytics, util, EventContext, postAtf, collectDebug) { // jshint ignore:line

    /**
     * WORKAROUND
     * Due to variant explosion in filename, we put weblab control in code, rather
     * than variant control.
     *
     * @return {Boolean} Whether the module functionalities should be activate
     */
    function isWeblab() {
      return recorderEvents.length !== 0;
    }

    // ---------------------------------------------------------------------------
    // cache
    // ---------------------------------------------------------------------------

    /**
     * Getting a captured event without corresponding handler comes from two scenario:
     * 1. handler registration is delayed (which indicates a true udac)
     * 2. page owner does not care about this event, no handler will be registered
     *
     * Ideally, we should only track first scenario. But user might drop the page
     * even before registration happened. Therefore, we log both of them with different
     * metric keys (see method `logUdac`)
     *
     * The following cache utils will help us to tracking the first scenario
     * lazily and passively.
     */

    var profiles = {};
    var jqueryEvents = {};

    function updateProfile(context) {
      var key = context.daName + ':' + context.eventType;
      if (!(key in profiles)) {
        profiles[key] = [];
      }
      profiles[key].push(context);
    }

    function updateJqueryEvent(context) {
      var eventType = context.eventType;
      var target = context._subject;
      if (!(eventType in jqueryEvents)) {
        jqueryEvents[eventType] = [];
      }
      jqueryEvents[eventType].push([target, context]);
    }

    function pickProfile(daName, eventType) {
      var key = daName + ':' + eventType;
      if (!(key in profiles)) {
        return [];
      } else {
        var profile = profiles[key];
        delete profiles[key];
        return profile;
      }
    }

    function pickJqueryEvent(selector, eventType) {
      if ( !(eventType in jqueryEvents)) {
        return [];
      }
      var eventTypeRecords = jqueryEvents[eventType];
      var contextList = [];
      var newEventTypeRecords = util.filter(eventTypeRecords, function(eventRecord) {
        var subject = eventRecord[0];
        var records = $(subject).closest(selector).length;
        if(records) {
          contextList.push(eventRecord[1]);
        }
        return !records;
      });
      jqueryEvents[eventType] = newEventTypeRecords;
      return contextList;
    }

    // ---------------------------------------------------------------------------
    // inspecting
    // ---------------------------------------------------------------------------

    /**
     * Log one failed attempt in CSM.
     * see https://w.amazon.com/index.php/AUI/Metrics/Definitions#udac_-_Unavailable_declarative_action_count
     *
     * @param {String} daName     e.g. a-secondary-view or thumb-action
     * @param {String} eventType  e.g. click or keydown (see EVENTS)
     * @param {Number} handlerRegisterLatency, the latency from t0 to the declarative handler register time
     *
     */
    function logUdac(daName, eventType, handlerRegisterLatency) {
      var contextList = pickProfile(daName, eventType);
      if (!contextList || !contextList.length) {
        return;
      }

      try {
        var udacKey = 'true_udac';
        // CSM
        analytics.increment('usage:' + udacKey, contextList.length);

        // RTLA
        var info = 'aui|udac|' + udacKey + '|' + eventType + '|' + daName + '|see: https://tiny.amazon.com/1jppzyki8';
        var attribution = {
          daName: daName,
          eventType: eventType,
          events: []
        };

        P.when('afterLoad').execute('logUdac', function() {
          util.each(contextList, function (contextEntry) {
            var context = EventContext.from(contextEntry)
              .collect(collectATF)
              .collect(collectPath)
              .collect(collectFeatureName)
              .dump();

            attribution.events.push({
              atf: context.isATF,
              xpath: context.xpath,
              selector: context.cssSelector,
              feature: context.feature,
              data: context.daData,
              eventLatency: context.eventLatency,
              handlerLatency: handlerRegisterLatency,
              attributionChain: util.attributionChain(context.target)
            });
          });
          P.log(
            info,
            'WARN',
            (JSON && JSON.stringify) ? JSON.stringify(attribution) : ''
          );
        });
      } catch (e) {
        // fail silently, don't shake the world
      }
    }

    // ---------------------------------------------------------------------------
    // inspecting
    // ---------------------------------------------------------------------------

    /**
     * Log one failed attempt in CSM.
     * see https://w.amazon.com/index.php/AUI/Metrics/Definitions#ujac_-_Unavailable_jQuery action count
     *
     * @param {String} selector     e.g. jquery event handler current target
     * @param {String} eventType  e.g. click or keydown (see EVENTS)
     * @param {Number} handlerRegisterLatency, the latency from t0 to the jquery event handler register time
     *
     */
    function logUjac(selector, eventType, handlerRegisterLatency) {
      var contextList = pickJqueryEvent(selector, eventType);
      if (!contextList || !contextList.length) {
        return;
      }

      try {
        var ujacKey = 'true_ujac';
        // CSM
        analytics.increment('usage:' + ujacKey, contextList.length);
        var contextXpath = util.xpath(contextList[0]._subject);
        // RTLA
        var info = 'aui|ujac|' + ujacKey + '|' + eventType + '|' + contextXpath + '|see: https://tiny.amazon.com/1jppzyki8';
        var attribution = {
          xpath: contextXpath,
          eventType: eventType,
          events: []
        };
        P.when('afterLoad').execute('logUjac', function() {
          util.each(contextList, function (contextEntry) {
            var context = EventContext.from(contextEntry)
              .collect(collectATF)
              .collect(collectPath)
              .collect(collectFeatureName)
              .dump();

            attribution.events.push({
              atf: context.isATF,
              xpath: context.xpath,
              selector: context.cssSelector,
              feature: context.feature,
              eventLatency: context.eventLatency,
              handlerLatency: handlerRegisterLatency,
              attributionChain: util.attributionChain(context.target)
            });
          });
          P.log(
            info,
            'WARN',
            (JSON && JSON.stringify) ? JSON.stringify(attribution) : ''
          );
        });
      } catch (e) {
        // fail silently, don't shake the world
      }
    }

    // ---------------------------------------------------------------------------

    // [AUI-7181] IE8 events lost their context in async calls.
    // We simply drop metric of IE8 due to its low traffic.
    function notIeEvent(event) {
      return typeof event.type !== 'unknown';
    }

    // Event could be captured from PageJS without jQuery
    function fixEvent(event) {
      return $.event.fix(event);
    }

    // We want to limit the logging in "active events",
    // otherwise, result will be too noisy. See EVENTS.
    function notPassiveEvent($event) {
      return util.indexOfArray(recorderEvents, $event.type) !== -1;
    }

    // We are not interested in document event
    function notTopLevelTarget($event) {
      return $event.target !== document;
    }

    function collectEventType($event) {
      return {eventType: $event.type};
    }

    // only wrapping da element holds the context
    function extractDaElement($event) {
      var target = $event.target;
      var daElement = $(target).closest('[data-action]').get(0);
      return daElement === undefined ? null : daElement; // EventContext is null-sensitive
    }

    // only wrapping delegate event hnadler holds the context
    function extractjQueryElement($event) {
      return $event.target;
    }

    // context of udac
    function collectDaName(daElem) {
      return {daName: daElem.getAttribute('data-action')};
    }

    function collectDaData(daElem) {
      var daName = daElem.getAttribute('data-action');
      return {daData: daElem.getAttribute('data-' + daName) || ''};
    }

    function collectATF(daElem) {
      return {isATF: util.isATF(daElem)};
    }

    function collectPath(daElem) {
      return {
        xpath: util.xpath(daElem),
        cssSelector: util.cssSelector(daElem)
      };
    }

    function collectTarget($event) {
        return {target: $event.target};
    }

    var FEATURE_ELEM_SELECTOR = '[id$=_feature_div],.feature';
    var FEATURE_NAME_PROPNAME = 'data-feature-name';
    var FEATURE_ID_POSTFIX = '_feature_div';

    /**
     * Collect feature name from feature block if possible
     * @param daElem the event target element
     * @returns {{feature: string}} the feature name
     * Feature name can give a clud that which team is the feature owner.
     * A feature's elements are always contained inside a feature block
     * element.
     * feature block is the closest ancestor element which has an ID of
     * 'XXXX_feature_div', or has a 'feature' CSS class name.
     * The feature name could be:
     * 1. a 'data-feature-name' property value;
     * 2. XXXX at the 'XXXX_feature_div' element ID.
     */
    function collectFeatureName(daElem) {
      var featureName;
      var featureElement = $(daElem).closest(FEATURE_ELEM_SELECTOR).get(0);
      if (featureElement) {
        featureName = featureElement.getAttribute(FEATURE_NAME_PROPNAME);
        if (!featureName) {
          var id = featureElement.id;
          if(id && id.length > FEATURE_ID_POSTFIX.length && id.indexOf(FEATURE_ID_POSTFIX) === (id.length - FEATURE_ID_POSTFIX.length)) {
            featureName = id.slice(0, id.length - FEATURE_ID_POSTFIX.length);
          }
        }
      }
      return {feature: featureName || ''};
    }

    function collectEventLatency(latency) {
      return function () {
        return {eventLatency: latency};
      };
    }

    function getRegisterLatency() {
      return Date.now() - t0;
    }

    var t0 = window.ue_t0 || window.aPageStart || Date.now();

    /**
     * When an event captured, we have a series of checking for identifying a valid UDAC, UJAC.
     * We also collect a group of derived context which helps later investigation easier.
     *
     * @param {Event} event  A captured event
     */
    function inspectUacCandidate(event, latency) {
      if (!isWeblab()) {
        return;
      } // TODO remove this workaround after we improve variant explosion issue

      if (arguments.length < 2) {
        latency = getRegisterLatency();
      }
      var commonEventContext = new EventContext(event)
          .filter(notIeEvent)
          .transform(fixEvent)
          .filter(notPassiveEvent)
          .filter(notTopLevelTarget)
          .collect(collectEventType)
          .collect(collectEventLatency(latency))
          .collect(collectTarget);

        var daEventContext = EventContext.fromEventContext(commonEventContext)
          .transform(extractDaElement)
          .collect(collectDaName)
          .collect(collectDaData);

        var jqEventContext = commonEventContext
          .transform(extractjQueryElement);

        var daContext = daEventContext.dump();
        if (daContext) {
          updateProfile(daContext);
        }

        var jqContext = jqEventContext.dump();
        if (jqContext) {
          updateJqueryEvent(jqContext);
        }
    }

    // ---------------------------------------------------------------------------

    function resolveUdacCandidate(daName, eventType) {
      if (!isWeblab()) {
          return;
      }
      logUdac(daName, eventType, getRegisterLatency());
      collectDebug();
    }

    function resolveUjacCandidate(selector, eventType) {
      if (!isWeblab()) {
          return;
      }
      util.each(eventType.split(' '), function (event) {
          logUjac(selector, event, getRegisterLatency());
      });
      collectDebug();
    }

    // ---------------------------------------------------------------------------
    // module
    // ---------------------------------------------------------------------------

    /**
     * This module is strongly coupled with p-event-recorder:
     * The p-event-recorder will relentlessly record any event on the page,
     * but it needs a partner to inspect and handle the recorded events.
     *
     *  "handle" will take this responsibility
     *
     * After DA system is ready, this module will still work passively in the DA system.
     * It listens all the event, but only dispatches the ones
     * who have business logic (event handler) registered.
     */

    return {
      handle: inspectUacCandidate,
      notifyDeclarativeAction: resolveUdacCandidate,
      notifyJquery: resolveUjacCandidate

    };
  });

P.when('a-util', 'a-class').register('prv:a-event-context', function (util, aClass) {
  /*
   * A Monad class which hosts a subject during a series of given transformations.
   * It covers the null and exception cases in the following logic:
   * - if subject is null, do nothing, but don't break the chained transformations.
   * - if exception happens, catch it and make the rest transformations invalid
   *   by setting the subject as null.
   *
   * In this class, we also provides two helping methods:
   *
   * `filter`
   * is a gatekeeper, any false returned by it's predicator will
   * make the reset transformation invalid
   *
   * `collect`
   * allows us to gather information from subject during the transformation.
   * Any single failed point will be ignore individually. The accumulated result
   * will only available if subject is still valid.
   *
   * Please see test/a_event_analytics/a_event_context.test.js for more details.
   */
  var EventContext = aClass.createClass({
    init: function (subject, collected) {
      this.subject = subject;
      this.collected = collected || {};
    },
    transform: function (transformer) {
      if (this.subject === null) {
        return this;
      }

      var newSubject;
      try {
        newSubject = transformer(this.subject);
      } catch (e) {
        this.subject = null;
        return this;
      }

      this.subject = newSubject;
      return this;
    },
    filter: function (predicator) {
      return this.transform(function filterTransformer(subject) {
        if (!predicator(subject)) {
          return null;
        }
        return subject;
      });
    },
    collect: function (collector) {
      var self = this;
      return this.transform(function collectorTransformer(subject) {
        try {
          var hash = collector(subject);
          self.collected = util.extend(self.collected, hash);
        } catch (e) {
          // just ignore this collector
        }
        return subject;
      });
    },
    dump: function () {
      if (this.subject === null) {
        return null;
      }
      this.collected._subject = this.subject;
      return this.collected;
    }
  });
  EventContext.from = function (context) {
    return new EventContext(context._subject, context);
  };
  EventContext.fromEventContext = function (context) {
    return new EventContext(context.subject, context.collected);
  };
  return EventContext;
});
/////////////////////////
// END FILE a_event_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_visibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.register('priv:a-visibility', function() {
    /**
     *  A factory to return the isPageHidden implementation.
     *
     *  isPageHidden will return true if the page is hidden, defaulting to false
     *  if the visiblity can not be determined.
     *
     *  We expose this function as an AUI module for testing as PhantomJS makes
     *  it near impossible to mock the visibility object and we need a way to
     *  mock the document object. In production, doc === document.
     *
     *  @public
     *  @return {boolean}
     */
    function Visibility(doc) {
        var propertyName = getHiddenProperty(doc);

        if (!propertyName) {
            // Unsupported browser, assume the page is never hidden
            return function() {
                return false;
            };
        }
        else {
            // Supported browser, use the property specific to this browser
            return function() {
                return doc[propertyName];
            };
        }
    }

    /**
     * Helper function to return the correct property of the document object.
     *
     * Outside of prefering the 'hidden' property above the others, the
     * ordering is arbitrary. It's assumed a browser will not support
     * multiple vendor prefixes.
     */
    function getHiddenProperty(doc) {
        var properties = [
            'hidden',       // Modern HTML5 Browser
            'webkitHidden', // Legacy Safari and Chrome
            'mozHidden',    // Legacy Firefox
            'msHidden',     // Legacy Internet Explorer
            'oHidden'       // Legacy Opera
        ];

        for (var i = 0; i < properties.length; i += 1) {
            if (properties[i] in doc) {
                return properties[i];
            }
        }
    }

    return Visibility;
});
/////////////////////////
// END FILE a_visibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_debug_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Utils that are only needed for AUI_JS_DEBUG=true usecases
if (AUI_JS_DEBUG) {
  P.when('a-util').register('a-util-dbg', function(util) {
      // Returns the value of a query param, or null if it is not present in the query string
      var getQueryParamValue = function (key, localWindow) {
        if (localWindow.URLSearchParams && localWindow.URLSearchParams.prototype.get) {
          var urlParams = new URLSearchParams(localWindow.location.search);
          return urlParams.get(key) || null;
        } else {
          var queryString = localWindow.location.search;
          var keyRegex = new RegExp('[?|&]' + key + '=([^&]+)');
          var keyMatch = keyRegex.exec(queryString);
          if (keyMatch && keyMatch.length >= 2) {
            return keyMatch[1] || null;
          } else {
            return null;
          }
        }
      };

      // Manually parse the weblab cookie and return the exact treatment string of the passed-in weblab
      // Will always return an uppercase value, e.g "C" or "T1", when the treatment contains letters
      var getCookieWeblabTreatment = function (weblabId) {
        var weblabCookie = util.cookies.get('experiment');
        var weblabTreatment = "";
        if (weblabCookie) {
          // let's work with only uppercase ids and treatments
          weblabCookie = weblabCookie.toUpperCase();
          weblabId = weblabId.toUpperCase();
          // search for our weblab
          weblabCookie.split("&").filter(function(weblabInfo) {
            return weblabInfo.indexOf(weblabId) === 0;
          }).forEach(function(weblabInfo) {
            var weblabTokens = weblabInfo && weblabInfo.split(":");
            // pull the treatment out of the matching weblab
            weblabTreatment = weblabTokens && weblabTokens.length >= 2 && weblabTokens[1];
          })
        }

        return weblabTreatment;
      }

      // Return the integer time to delay "ready" by in ms if specified, otherwise return 0
      // Only delay loading of events if query param OR debug weblab is present with non-zero value
      // Give precedence to query param delay
      // NOTE: Must be called after "a-bodyBegin", to guarantee access to the document.body variable
      var getLoadEventsDelay = function (window) {
        var queryParamLoadEventsDelay = getQueryParamValue("aui_load_events_delay", window);
        var weblabLoadEventsDelay = getCookieWeblabTreatment("aui_load_events_delay");
        var resolvedDelay = queryParamLoadEventsDelay || weblabLoadEventsDelay;

        try {
          resolvedDelay = parseInt(resolvedDelay);
        } catch (_) {
          resolvedDelay = 0;
        }

        return resolvedDelay || 0;
      };

      // Displays debug information about firing of AUI "ready" event
      // NOTE: Must be called after "a-bodyBegin", to guarantee access to the document.body variable
      var displayReadyDebug = function () {
        var loadEventsDelay = getLoadEventsDelay(window);
        if (loadEventsDelay) {
          // When we fire AUI ready as a module, add a visual marker to the page
          P.when('ready').execute('update-ready-marker', function () {
            var markerId = 'aui-ready-delay-marker';
            var currentMarker = document.getElementById(markerId);
            // We will already have a marker on OTP and other test-environments, so only add one if we don't have one already
            if (!currentMarker) {
              var markerDiv = document.createElement('div');
              markerDiv.id = markerId;
              markerDiv.style = 'z-index:10000;background-color: rgba(0,0,255,0.5);width: 250px;height: 100px;position: fixed;pointer-events: none;color: yellow';
              markerDiv.innerText = 'AUI ready triggered!';
              if (typeof document.body.insertBefore === 'function') {
                document.body.insertBefore(markerDiv, document.body.firstChild);
              } else {
                console.log('DEBUG: AUI ready triggered!');
              }
            }
          });
        }
      };


      // Expose the utils
      return {
        getQueryParamValue: getQueryParamValue,
        getCookieWeblabTreatment: getCookieWeblabTreatment,
        getLoadEventsDelay: getLoadEventsDelay,
        displayReadyDebug: displayReadyDebug
      }
    });
}
/////////////////////////
// END FILE a_debug_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_prv_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Utility functions that we don't want to publicly expose on "A" (since every new util function in a_util.js is automatically
//exposed on "A", as a result of how "A" construction happens in a_ending.js)
'use strict';

P.register('prv:a-private-util', function () {

    // Sometimes in IE, accessing the userAgent can cause a permission denied error
    var ua;
    try {
        ua = navigator.userAgent;
    } catch (e) {
        ua = "";
    }

  /**
   *  Safely execute feature tests.
   *
   *  Chrome, Firefox, and IE10 occasionally throw exceptions when
   *  checking for the existence of some feature properties.
   *
   *  If a test throws an exception, just assume the test returned false.
   *
   *  @private
   *  @param {function} testFn
   *
   *  @return {boolean}
   */
  function safeTest(testFn) {
    try {
      return testFn();
    } catch (e) {
      return false;
    }
  }

    return {
        ua: ua,
        safeFeatureTest: safeTest
    }
});
/////////////////////////
// END FILE a_prv_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Utility Functions
'use strict';

P.when('priv:a-visibility', 'prv:a-guard', 'prv:a-private-util')
.register('a-util', function (visibility, guard, privateUtil) {
    // Shared variables used by imported code
    //Expose ua for imported files
    var ua = privateUtil.ua;

    /**
     *
     * @param {string|DOMElement|NodeList|jQueryObject|Array[DomElement]} selector
     * @returns {Array} Array of DOMElements
     */
    function normalizeSelector (selector) {
        if (isDomElement(selector)) {
            return [selector];
        }
        if (selector.jQuery) {
            return selector.get();
        }
        var type = Object.prototype.toString.call(selector);
        if (type === "[object String]") {
            return arrayLikeToArray(document.querySelectorAll(selector));
        }
        if (type === "[object Array]") {
            return selector.filter(selector, isDomElement);
        }
        // https://stackoverflow.com/a/7238344
        if (typeof selector === 'object' &&
                /^\[object (HTMLCollection|NodeList|Object)\]$/.test(type) &&
                (typeof selector.length === 'number') &&
                (selector.length === 0 || (typeof selector[0] === "object" && selector[0].nodeType > 0))) {
            return arrayLikeToArray(selector);
        }
        return [];
    }

    function isDomElement (element) {
        return element instanceof Element || element instanceof HTMLDocument;
    }

    function arrayLikeToArray (arraylike) {
        return Array.prototype.slice.call(arraylike);
    }

    var util = {
        now: Date.now,
        isPageHidden: visibility(document)
    };

    /* Importing utils/_collections.js */
//  Collections methods
//  Adapted from http://underscorejs.org/ and altered for ease of
//  understanding / readability in a few spots
function collectionUtils(util) {
    var breaker = {};

    // For each
    function each(obj, iterator, context) {
        if (obj === null) {
            return;
        }

        // Delegate to native method if it exists
        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
            obj.forEach(iterator, context);
            return;
        }

        // Array
        if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (i in obj) {
                    iterator.call(context, obj[i], i, obj);
                }
            }
            return;
        }

        // Object
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
            }
        }
    }

    // Map / Collect
    function map(obj, iterator, context) {
        var results = [];
        if (obj === null) {
            return results;
        }

        // Delegate to the native method if it exists
        if (Array.prototype.map && obj.map === Array.prototype.map) {
            return obj.map(iterator, context);
        }

        util.each(obj, function (value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });

        if (obj.length === +obj.length) {
            results.length = obj.length;
        }

        return results;
    }

    // Reduce
    function reduce(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj === null) {
            obj = [];
        }

        if (Array.prototype.reduce && obj.reduce === Array.prototype.reduce) {
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }

        util.each(obj, function (value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });

        if (!initial) {
            P.error('Reduce of empty array with no initial value', 'A.util', 'reduce');
        }

        return memo;
    }

    // Filter
    function filter(obj, iterator, context) {
        var results = [];

        if(obj === null) {
            return results;
        }

        if(Array.prototype.filter && obj.filter === Array.prototype.filter) {
            return obj.filter(iterator, context || obj);
        }

        util.each(obj, function(value, index, list) {
            if(iterator.call(context || obj, value, index, list)) {
                results.push(value);
            }
        });

        return results;
    }

    function range(start, stop, step) {
        if (stop === undefined) {
            stop = start || 0;
            start = 0;
        }
        step = step || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var array = new Array(length);

        for (var i = 0; i < length; i++, start += step) { // jshint ignore:line
            array[i] = start;
        }

        return array;
    }

    return {
        each: each,
        map: map,
        reduce: reduce,
        filter: filter,
        range: range,
        breaker: breaker
    };
}
/* Done importing utils/_collections.js */

    /* Importing utils/_fn.js */
// Functional Utilities
function fnUtils(util) {

    //Function call throttling
    function throttle(func, wait, options) {
        var context, args, result;
        var guarded = guard.fn(this, func);
        var timeout = null;
        var previous = 0;
        options = options || {};
        var later = function() {
            previous = options.leading === false ? 0 : util.now();
            timeout = null;
            result = guarded.apply(context, args);
            context = args = null;
        };

        return function() { 
            var current = util.now();
            if (!previous && options.leading === false) {
                previous = current;
            }
            var remaining = wait - (current - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = current;
                result = func.apply(context, args);
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };

    //Function call debouncing

    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        var guarded = guard.fn(this, func);

        var later = function () {
            var last = util.now() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = guarded.apply(context, args);
                    context = args = null;
                }
            }
        };

        return function () {
            context = this;
            args = arguments;
            timestamp = util.now();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    // Wrapper for setTimeout

    function delay(fn, wait) {
        var callback = guard.fn(this, fn);
        var args = Array.prototype.slice.call(arguments, 2);
        return setTimeout(function () {
            return callback.apply(null, args);
        }, wait); 
    };

    // Delay one frame
    function animationFrameDelay(fn) {
        return this.delay(fn, 16);
    };

    //Wrapper for setInterval
    function interval(fn, interval) {
        var callback = guard.fn(this, fn);
        return setInterval(callback, interval);
    };

    // Guarantees that a function will only be called once. Subsequent calls
    // will return the result from the first call
    function once(fn) {
        var called = false;
        var callback = guard.fn(this, fn);
        var result;
        return function () {
            if (!called) {
                called = true;
                result = callback.apply(this, arguments);
            }
            return result;
        };
    };

    // Sequences a series of functions by passing each function a next function to call
    // on completion. Example:
    //     function foo(nextFunc) {
    //          do some foo work;
    //          nextFunc();
    //     };
    //
    function sequence() {
        var slice = [].slice;
        var fns = slice.call(arguments).reverse();

        // This will serve as the execution context for all of the functions
        // passed in. Context can be provided by binding sequence() to the desired context.
        var context = this; // jshint ignore:line

        // The collection variable comes from the _collection.js utils file which is
        // joined with this file making its self available.
        return util.reduce(fns, function (composed, fn) {
            return function () {
                var fnArgs = slice.call(arguments);
                fnArgs.push(composed);
                fn.apply(context, fnArgs);
            };
        }, function () {});
    };

    
    /* 
    Functional programming emulation of the ES2015 "...rest" operator
    https://babeljs.io/docs/learn-es2015/#default-rest-spread

    Based on Lodash's 4.x implementation of rest.
    */
    function rest(fn, start) {
    
        if(!fn) { return; } // Should probably error here?

        /*
          When calling the function returned by rest(), offset
          is the index at which supplied arguments will be 
          collected into a single array. 
        */
        var offset = Math.max(start === undefined ? (fn.length - 1) : start, 0);



        return function() {

            var args  = arguments,
               index  = -1,
               length = Math.max(args.length - offset, 0),
               array  = Array(length);

            // Collect arguments into array (starting at offset)        
            while(++index < length) {
                array[index] = args[index + offset];
            }

            /*
              Common cases, when we pass in a function, we're 
              usually separating the first/second param from 
              the remainder of params. These 3 cases are for
              faster eval as they won't take more calculations
              for a 'sane' offset number.
            */

            switch(offset) {
                case 0: return fn.call(this, array);
                case 1: return fn.call(this, args[0], array);
                case 2: return fn.call(this, args[0], args[1], array);
            }

            /* 
              If we reach here: Uncommon case.
              we're dealing with > 2 params in the 'fn' call 
              (excluding rest), so we'll need to copy the 
              non-rest params into their own array, add the 
              rest params array to the end of it, and call fn 
              with .apply() instead of .call(). 
            */ 

            var all = Array(offset + 1);
            
            index = -1;

            // Collect arguments from beginning to offset
            while (++index < offset) {
                all[index] = args[index];
            }

            // Put grouped (...rest) arguments at the end
            all[offset] = array;

            return fn.apply(this, all);

        };
    }

    //Parse the name of a function
    function parseFunctionName (fn) {
        if (fn.name) {
            return fn.name === 'anonymous' ? '' : fn.name;
        }
        // IE8
        else {
            var parsed = fn.toString().match(/^function\s*([^\s(]+)/);
            return parsed ? parsed[1] : '';
        }
    }

    return {
        throttle: throttle,
        sequence: sequence,
        debounce: debounce,
        delay: delay,
        animationFrameDelay: animationFrameDelay,
        interval: interval,
        once: once,
        rest: rest,
        parseFunctionName: parseFunctionName
    };

}
/* Done importing utils/_fn.js */
 // Uses `guard`
    /* Importing utils/_object.js */
// Object utility functions
function objectUtils(util) {

    /**
     *  Finds the first index at which the given search element can be found in the given array.
     *  Falls back to the native Array.indexOf, if available.
     *
     *  @param {array} arr The array to search
     *  @param {object} searchElement The object to search for
     *  @param {number} The index at which the search should start (optional)
     *
     *  @return {number} The first index at which a given element can be found in the array, or -1 if it is not present.
     */

    function indexOfArray(arr, searchElement, startIdx) {
        if (Array.prototype.indexOf && arr.indexOf === Array.prototype.indexOf) {
            return arr.indexOf(searchElement, startIdx);
        }

        if (!(arr && arr instanceof Array)) {
            P.error('Invalid arr passed to A.indexOfArray: ' + arr, 'A.util', 'indexOfArray');
        }

        startIdx = parseInt(startIdx, 10);
        var n = isNaN(startIdx) ? 0 : startIdx;
        if (!isFinite(n)) {
            return -1;
        }

        for (var l = arr.length; n < l; n++) {
            if (arr[n] === searchElement) {
                return n;
            }
        }
        return -1;
    }

    /**
     *  Deep + Recursive object extend
     *
     *  @param {object...} arguments
     *
     *  @return {object} The object with the various objects extended onto it
     */

    function extend(target /* , ...sources */) {
        var copyIsArray;
        
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && typeof target !== "function") {
            target = {};
        }
    
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            // Only deal with non-null/undefined values
            if (source != null) {
        
                // Extend the base object
                for (var sourceKey in source) {
                    var sourceValue = source[sourceKey];
                    // Prevent never-ending loop
                    // Don't bring in undefined values
                    if (target === sourceValue || sourceValue === undefined) {
                        continue;
                    }
                    var targetValue = target[sourceKey];

                    // Recurse if we're merging plain objects or arrays
                    if ((isPlainObject(sourceValue) || (copyIsArray = isArray(sourceValue)))) {
                        
                        // Ensure proper type for the source value
                        if (copyIsArray && !isArray(targetValue)) {
                            targetValue = [];
                        } else if (!copyIsArray && !isPlainObject(targetValue)) {
                            targetValue = {};
                        }
                        copyIsArray = false;

                        // Never move original objects, clone them
                        extend(targetValue, sourceValue);

                    } else {
                        targetValue = sourceValue;
                    }

                    target[sourceKey] = targetValue;
                }
            }
        }
    
        // Return the modified object
        return target;
    }

    /**
     *  Makes a copy of objects and arrays, returns everything else
     *
     *  @param {object} obj The thing to be copied
     *
     *  @return {object} The copy of the object, or the original input if the input does not conform
     */

    function copy(obj) {
        if (isArray(obj)) {
            return extend([], obj);
        }
        if (isPlainObject(obj)) {
            return extend({}, obj);
        }

        return obj;
    }

    /**
     *  Add methods from `source` to `target`.
     *
     *  @public
     *  @param {object} target The object to which methods will be added
     *  @param {object} source The object from which methods will be copied
     *  @param {array} methods (optional) An array of method names to mix in.
     *      If ommitted, all methods from source will be added to target.
     */

    function mixin(target, source, methods) {
        if(!methods) {
            for(var prop in source) {
                if(typeof source[prop] === 'function') {
                    target[prop] = source[prop];
                }
            }
        } else {
            for(var i=0,l=methods.length;i<l;i++) {
                target[methods[i]] = source[methods[i]];
            }
        }
    }

    // Recursive object diff

    function diff(a, b) {
        a = a || {};
        b = b || {};
        var objDiff = {};

        for (var key in a) {
            if (a.hasOwnProperty(key)) {
                objDiff[key] = (typeof a[key] === 'object') && a[key] ? diff(a[key], b[key]) : a[key] !== b[key];
            }
        }

        for (var key in b) {
            if (b.hasOwnProperty(key) && !objDiff[key]) {
                objDiff[key] = (typeof b[key] === 'object') && b[key] ? diff(b[key], a[key]) : b[key] !== a[key];
            }
        }

        return objDiff;
    }

    /**
     *  Equality function.  Does a deep equality check for objects and arrays.
     *
     *  @private
     *  @param {object} first
     *  @param {object} second
     *
     *  @return {boolean}
     */

    function equals(first, second) {
        var i;
        // Simple
        if (first === second) {
            return true;
        }

        // Array
        if (isArray(first)) {
            if (!isArray(second) || first.length !== second.length) {
                return false;
            }
            i = first.length;
            while (i--) {
                if (!equals(first[i], second[i])) {
                    return false;
                }
            }
            return true;
        }

        // Plain object
        if (isPlainObject(first)) {
            if (!isPlainObject(second)) {
                return false;
            }
            if (objectIsEmpty(first) && !objectIsEmpty(second)) {
                return false;
            }
            for (i in first) { // jshint ignore:line
                if (!equals(first[i], second[i])) {
                    return false;
                }
            }
            return true;
        }

        // FAIL!!!!!!
        return false;
    }

    /**
     *  Determine of the passed object is a finite number.
     *
     *  @public
     *  @param {object}
     *
     *  @return {boolean}
     */

    function isFiniteNumber(num) {
        return typeof num === "number" && !isNaN(num) && isFinite(num);
    }

    /**
     *  Determine if an object has any properties on it which aren't inherited from the base JS object class.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {boolean}
     */

    function objectIsEmpty(obj) {
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                return false;
            }
        }
        return true;
    }

    /**
     *  Get the names of an object’s properties.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {array}
     */

    function getKeys (obj) {
        var isObject = typeof obj === 'function' || typeof obj === 'object' && !!obj;
        if (!isObject) {
            return [];
        }
        if (Object.keys) {
            return Object.keys(obj);
        }

        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    }

    /**
     *  Get the values of an object’s properties.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {array}
     */

    function getValues (obj) {
        var keys = getKeys(obj);
        var values = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    /**
     *  Determine if the passed object is an Array.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {boolean}
     */
    function isArray (obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    // Copied from jQuery 1.6 source. When removing IE8 IE9 support, trim this.
    function isPlainObject (obj) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if (!obj || typeof obj !== "object" || obj.nodeType || obj === window) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if ( obj.constructor &&
                !obj.hasOwnProperty("constructor") &&
                !obj.constructor.prototype.hasOwnProperty("isPrototypeOf") ) {
                return false;
            }
        } catch ( e ) {
            // IE8, IE9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.

        var key;
        for ( key in obj ) {}

        return key === undefined || obj.hasOwnProperty(key);
    }
    
    /**
      * Defines an immutable value on obj
      * @param {Object} obj The object to set value on
      * @param {String} name The value to set
      * @param {*} value The value to set
      * @return {Object} value Returns the value for additional use
      */

    function defineProp(obj, name, value) {
        Object.defineProperty(obj, name, { value: value, writable: false });
        return value;
    }

    /**
      * Polyfill for defineProp
      */
    function assignProp(obj, name, value) {
        if (!obj.hasOwnProperty(name)) {
            obj[name] = value;    
        }
        return value;
    }
    
    var constProp = typeof Object.defineProperty === 'function' ? defineProp : assignProp;

    return {
        keys: getKeys,
        values: getValues,
        extend: extend,
        mixin: mixin,
        diff: diff,
        equals: equals,
        copy: copy,
        indexOfArray: indexOfArray,
        isArray: isArray,
        isPlainObject: isPlainObject,
        isFiniteNumber: isFiniteNumber,
        objectIsEmpty: objectIsEmpty,
        constProp: constProp
    };
}
/* Done importing utils/_object.js */

    /* Importing utils/_string.js */
// String utils

// Depends on object being previously defined
function stringUtils(util) {
    /**
     *  The HTML entity map for encoding
     *
     *  @private
     *  @constant
     *  @type {object}
     */
    var HTML_ENTITY_MAP = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '/': '&#x2F;'
    };

    // String utility regexps
    var regexps = {
        trimLeft: /^\s+/,
        trimRight: /\s+$/,
        html: new RegExp('[' + util.keys(HTML_ENTITY_MAP).join('') + ']', 'g'),
        jquery: /([!"#$%&'\(\)*+,./:;<=>?@\[\\\]^`{|}~])/g
    };

    // Trims right + left whitespace off of a string, and defers to the native
    // method if available

    function trim(text) {
        if (String.prototype.trim) {
            return String.prototype.trim.call(text);
        }

        return text.replace(regexps.trimLeft, "").replace(regexps.trimRight, "");
    }

    //Returns true if string contains substring
    function contains(string, substring) {
        return ('' + string).indexOf(substring) !== -1;
    }

    /**
     *  Given an unsafe html string, generate the safe html string
     *
     *  @public
     *  @param {string} content The unsafe html string content
     *
     *  @return {string}  The safe html string
     */
    function escapeHtml(content) {
        return ('' + content).replace(regexps.html, function(s){
          return HTML_ENTITY_MAP[s];
        });
    }

    /**
     *  Escape jquery selector http://api.jquery.com/category/selectors/
     *
     *  @public
     *  @param {string} s The string would be used as a selector or part of a selector
     *
     *  @return {string}  The escaped string applicable for jquery selector
     */
    function escapeJquerySelector(s) {
        return ('' + s).replace(regexps.jquery, '\\$1');
    }

    // Parses JSON using the best method available
    function parseJSON(data) {
        return JSON.parse(data);
    }

    return {
        trim: trim,
        contains: contains,
        escapeHtml: escapeHtml,
        escapeJquerySelector: escapeJquerySelector,
        parseJSON: parseJSON
    };
}
/* Done importing utils/_string.js */

    /* Importing utils/_attribution.js */
function attributionUtils(util) {
  function xpath(dom) {
    if (dom.id !== '') return '//*[@id="' + dom.id + '"]';
    if (dom === document.documentElement) return '/html';

    var idx = util.indexOfArray(util.filter(dom.parentNode.childNodes, function (sibling) {
        return sibling.tagName === dom.tagName;
    }), dom);
    if (idx === -1) {
        throw new Error('can not evaluate xpath of element ' +
            '`' +
            (dom.tagName) + (dom.id ? '#' + dom.id : '') +
            '`');
    }
    return util.xpath(dom.parentNode) + '/' + dom.tagName + '[' + (idx + 1) + ']';
  }

  /**
   * Return the CSS selector string for the target element
   * @param dom the target element
   * @returns {string} the CSS selector
   * We return the CSS selector sting in format of:
   * [tag_name][.css_class_name][#element_id]
   * It's often not the best CSS selector, and not a unique CSS selector
   * But usually it's good enough to describe what kind of element it is.
   */
  function cssSelector(dom) {
      var result = [dom.tagName || ''];
      // SVG elements' className is an object, not a string
      if(dom.className && dom.className.trim) {
          result.push('.' + dom.className.trim().replace(/\s+/g, '.'));
      }
      if(dom.id) {
          result.push('#' + dom.id);
      }
      return result.join('');
  }

  /**
   * Returns identifying attributes for the entire "chain of custody" for an
   * element. This is used for error attribution when an element is used by
   * AUI but the element does not belong to AUI.
   * This may produce an invalid CSS selector, since the attribute values
   * are not quoted or escaped.
   */
  var attributionAttributes = [
    'id',
    'cel_widget_id', // CSM instrumentation
    'data-feature-name', // Detail page features
    'data-action', // Declarative actions
    'data-aui-build-date'
  ];
  function attributionSelector(dom) {
    return util.map(attributionAttributes, function (attr) {
      var val = dom.getAttribute(attr);
      return val && '[' + attr + '=' + val + ']';
    }).join('');
  }
  function attributionChain(dom) {
    var chain = [];
    do {
      chain.push(attributionSelector(dom));
      dom = dom.parentElement;
    } while (dom);
    return util.filter(chain, Boolean).reverse().join(' ');
  }

  return {
    xpath: xpath,
    cssSelector: cssSelector,
    attributionChain: attributionChain
  };
}
/* Done importing utils/_attribution.js */

    /* Importing utils/_visibility_fn.js */
function visiblityUtils(util) {

  /**
   *  Hide the object Element
   *
   *  @public
   *  @param {object} selector The DOM element to hide
   *
   */
  function hide(selector) {
    util.each(normalizeSelector(selector), function (element) {
      util.addClass(element, 'aok-hidden');
    });
  }

  /**
   *  Show the object Element
   *
   *  @public
   *  @param {object} element The DOM element to show
   *
   */
  function show(selector) {
    util.each(normalizeSelector(selector), function (element) {
      util.removeClass(element, 'aok-hidden');
    });
  }

  return {
    hide: hide,
    show: show
  };
}
/* Done importing utils/_visibility_fn.js */
 // Uses `normalizeSelector`
    /* Importing utils/_cookies.js */
// Cookie reading utils; cookie setting is not supported, due to Amazon's cookie policy:
// https://w.amazon.com/index.php/AmazonCookiePolicy
// Author: stamps@

// Depends on these a-util variables being previously defined:
// - object
// - string
function cookieUtils(util) {
    var allCookies;

    // RFC2109 allows for double-quoted strings with embedded backslash escapes, and the original
    // spec allows for URL encoding. Support both, with stripped whitespace.
    function decodeCookieString(str) {
        str = util.trim(str);
        if (/^"/.test(str)) {
            // Assume that the string is quoted at both ends; only " and \ should be escaped,
            // but it's simpler to unescape everything.
            str = str.slice(1, -1).replace(/\\(.)/g, '$1');
        }
        return window.decodeURIComponent(str);
    }

    // Minimal deconstruction of the cookie string, based partly on HTTP cookie specs, and partly
    // on observation in major browsers. Note that the specs are about HTTP headers, not JavaScript
    // string representations, so some aspects may vary.
    //   http://curl.haxx.se/rfc/cookie_spec.html (v0 Netscape cookies)
    //   https://tools.ietf.org/html/rfc2109      (v1 cookie standard)
    //   https://tools.ietf.org/html/rfc2965      (v2 cookie standard)
    // In practice, Amazon cookies seem to be represented as v0 URI-encoded strings, occasionally
    // wrapped by double quotes.
    function parseCookies() {
        allCookies = {};
        // IMPORTANT: We should protect against splitting an undefined document.cookie, which will
        // obviously fail. There's no easy, robust way to add a unit test around this because
        // cookies persist in Phantom and another test could have defined document.cookie for us.
        var avPairs = (document.cookie || '').split(';');
        for (var i = avPairs.length - 1; i >= 0; i--) {
            // The .split() length arg discards part of the value if there are embedded '=', so
            // don't use it. Instead, use a regular split and join the value back together below.
            var avPair = avPairs[i].split('=');
            // trim() can't handle undefined inputs, but avPair[0] is always a string.
            var attr = util.trim(avPair[0]);
            if (attr) {
                // If there was no value (i.e. no '='), value is an emtpy string, to distinguish
                // from an undefined cookie. avPair[1] could be undefined, but the join() always
                // returns a string.
                allCookies[attr] = decodeCookieString(avPair.slice(1).join('='));
            }
        }
    }

    // Returns a single cookie, looked up by name. If a cookie is modified after the first call to
    // get() or getAll(), get() will not reflect the change until after refresh() is called.
    function get(cookieName) {
        // lazy parsing
        if (!allCookies) { parseCookies(); }
        return allCookies[cookieName];
    }

    // Returns a map of all cookies, keyed by name. If a cookie is modified after the first call to
    // get() or getAll(), getAll() will not reflect the change until after refresh() is called.
    function getAll() {
        // lazy parsing
        if (!allCookies) { parseCookies(); }
        return util.extend({}, allCookies);
    }

    // Resets the memoized cookie state, so that a subsequent call to get() or getAll() will
    // re-parse cookies.
    function refresh() {
        allCookies = null;
    }

    return {
        cookies: {
            // NOTE: Browser cookie architecture simply cannot support unrestricted use by teams at
            // Amazon. (See the cookie policy link above for details.) This API should never be
            // extended to support setting cookies, because making it too easy will inevitably lead
            // to (well-intentioned) abuse.
            get: get,
            getAll: getAll,
            refresh: refresh
        }
    };
}
/* Done importing utils/_cookies.js */

    /* Importing utils/_on_screen.js */
function onScreenUtils(util) {
    /**
     *  Determine whether the object Element is onScreen within a certain Buffer distance
     *
     *  @public
     *  @param {object} element The DOM element to determine if onScreen
     *  @param {number} buffer The distance from viewport that the object would still be deemed onScreen
     *
     *  @return {boolean}
     */
    function onScreen(element, buffer) {
        if (!element) return false;
        if (element.jquery) element = element[0];
        if (!element) return false;

        // Default buffer is 100
        buffer = (typeof buffer === "number" && !isNaN(buffer) && isFinite(buffer))? buffer : 100;

        if (!((element.nodeType === 1) && (element.offsetWidth || element.offsetHeight || element.getClientRects().length))) {
            return false;
        }

        //Window
        var windowSize = util.size(window);
        var windowScroll = util.scroll(window);
        var windowTop = windowScroll.top;
        var windowHeight = window.innerHeight ? window.innerHeight : windowSize.height;
        var windowBottom = windowTop + windowHeight;
        var windowLeft = windowScroll.left;
        var windowWidth = window.innerWidth ? window.innerWidth : windowSize.width;
        var windowRight = windowLeft + windowWidth;

        // Add in the buffer
        windowTop -= buffer;
        windowBottom += buffer;
        windowLeft -= buffer;
        windowRight += buffer;

        //Element
        var elementOffset = util.offset(element);
        var elementSize = util.size(element);
        var top = elementOffset.top;
        var height = elementSize.height;
        var bottom = top + height;
        var left = elementOffset.left;
        var width = elementSize.width;
        var right = left + width;

        return  (
                    (top >= windowTop && top < windowBottom) ||
                    (bottom > windowTop && bottom <= windowBottom) ||
                    (height > windowHeight && top <= windowTop && bottom >= windowBottom)
                ) &&
                (
                    (left >= windowLeft && left < windowRight) ||
                    (right > windowLeft && right <= windowRight) ||
                    (width > windowWidth && left <= windowLeft && right >= windowRight)
                );
    }

    return {
        onScreen: onScreen
    };
}
/* Done importing utils/_on_screen.js */

    /* Importing utils/_atf.js */
function atfUtils(util) {
  /**
   * Determine whether element is Above The Fold within a certain Buffer distance.
   *
   *  @public
   *  @param {object} element The DOM element to determine if isATF
   *  @param {number} buffer The top offset of viewport from the document top
   *                         that we treat viewport is not moved yet.
   *                         Default buffer is 100px.
   *
   *  @return {boolean}
   */
  function isATF(element, buffer) {
    buffer = (typeof buffer === "number" && !isNaN(buffer) && isFinite(buffer))? buffer : 100;

    var windowHeight = util.size(window).height;

    var boundTop = 0;
    var boundBottom = windowHeight + buffer;

    var top = util.offset(element).top;

    return boundTop <= top && top < boundBottom;
  }

  return {
    isATF: isATF
  };
}
/* Done importing utils/_atf.js */

    /* Importing utils/_css.js */
function cssUtils(util) {
    /**
     *  Set CSS attribute, with the ability to add !important to the style specified
     *
     *  @public
     *  @param {object} dom  DOM object
     *  @param {string} name  css style name
     *  @param {string} value  value of style
     */
    function setCssImportant(dom, name, value) {
        var dom = dom.jquery ? dom[0] : dom;
        if (typeof dom === "undefined") {
            return;
        }

        var style = dom.style;
        var clearRule = new RegExp(name+'\\s*:\\s*[.^;]*(\\s*;)?', 'gmi');
        style.cssText = style.cssText.replace(clearRule, "");
        style.cssText += name + ': ' + value + ' !important;';
    }

    function hasClass(element, className) {
        return element.classList ? element.classList.contains(className)
            : (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0;
    }

    function addClass(element, className) {
        if (hasClass(element, className)) return;
        if (element.classList) element.classList.add(className);
        else element.className += ' ' + className;
    }

    function removeClass(element, className) {
        if (!hasClass(element, className)) return;
        if (element.classList) element.classList.remove(className);
        else element.className = (' ' + element.className + ' ')
            .replace(new RegExp(' ' + className + ' ', 'g'), ' ')
            .replace(/  /g, ' ')
            .replace(/^ | $/g, '');
    }

    function offset(element) {
        if (element.jquery) element = element[0];
        var rect = element.getBoundingClientRect();
        var html = document.documentElement;
        var body = document.body;

        var clientTop  = html && html.clientTop  || body && body.clientTop  || 0,
            clientLeft = html && html.clientLeft || body && body.clientLeft || 0,
            scrollTop  = window.pageYOffset || html.scrollTop,
            scrollLeft = window.pageXOffset || html.scrollLeft;

        return {
            top: rect.top  + scrollTop  - clientTop,
            left: rect.left + scrollLeft - clientLeft
        };
    }

    function size(element) {
        var html = document.documentElement;
        var body = document.body;

        // window
        if (element === window) {
            return {
                width: html.clientWidth,
                height: html.clientHeight
            };
        }
        // document
        if (element.nodeType === 9) {
            return {
                width: Math.max(
                    html.clientWidth,
                    body.scrollWidth, html.scrollWidth,
                    body.offsetWidth, html.offsetWidth
                ),
                height: Math.max(
                    html.clientHeight,
                    body.scrollHeight, html.scrollHeight,
                    body.offsetHeight, html.offsetHeight
                )
            };
        }
        // element
        var styles = window.getComputedStyle(element);
        var borderTop = parseFloat(styles.borderTopWidth);
        var borderBottom = parseFloat(styles.borderBottomWidth);
        var borderLeft = parseFloat(styles.borderLeftWidth);
        var borderRight = parseFloat(styles.borderRightWidth);
        var paddingTop = parseFloat(styles.paddingTop);
        var paddingBottom = parseFloat(styles.paddingBottom);
        var paddingLeft = parseFloat(styles.paddingLeft);
        var paddingRight = parseFloat(styles.paddingRight);
        return {
            width: element.offsetWidth - borderLeft - borderRight - paddingLeft - paddingRight,
            height: element.offsetHeight - borderBottom - borderTop - paddingTop - paddingBottom
        };
    }

    function scroll(element) {
        var html = document.documentElement;
        var body = document.body;

        if ( !element ) {
            return null;
        }

        if (element === window || element.nodeType === 9) return {
            top: ('pageYOffset' in window) ? window.pageYOffset : html.scrollTop || body.scrollTop,
            left: ('pageXOffset' in window) ? window.pageXOffset : html.scrollLeft || body.scrollLeft
        };

        // Return the scroll offset
        return {
            top: element.scrollTop,
            left: element.scrollLeft
        };
    }

    var el = document.createElement('fakeelement');
    var transitions = {
        'transition':'transitionend',
        'OTransition':'oTransitionEnd',
        'MozTransition':'transitionend',
        'WebkitTransition':'webkitTransitionEnd'
    };
    var cachedTransitionEndEvent = null;

    /**
     *  Get the correct name of the transitionend event for the current platform
     *  Adapted from https://davidwalsh.name/css-animation-callback
     *
     *  @public
     *  @return {string} event name
     */
    function getTransitionEndEvent() {
        //ua is expected to be defined before this is imported, in a_util.js
        if ((/UCBrowser/).exec(ua)) {
            // UCBrowser accepts `transition` as style but only fires `webkitTransitionEnd`
            cachedTransitionEndEvent = transitions.WebkitTransition;
        }

        if (cachedTransitionEndEvent === null) {
            for (var t in transitions) {
                if (el.style[t] !== undefined){
                    cachedTransitionEndEvent = transitions[t];
                    break;
                }
            }
        }

        return cachedTransitionEndEvent;
    }

    /**
     *  Trigger a reflow, flushing the CSS changes. Pass the jQuery element you want to refresh.
     *  Ref: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
     *
     *  @params targets: jQuery object or array of elements
     */
    function reflowCssChanges(targets) {
        util.each(targets, function(obj) {
            // dummy read statement to trigger the reflow
            var blackHole = obj.offsetHeight;
        });
    }

    return {
        setCssImportant: setCssImportant,
        hasClass: hasClass,
        addClass: addClass,
        removeClass: removeClass,
        offset: offset,
        size: size,
        scroll: scroll,
        getTransitionEndEvent: getTransitionEndEvent,
        reflowCssChanges: reflowCssChanges
    };
}
/* Done importing utils/_css.js */
 // Uses `ua`
    /* Importing utils/_widescreen.js */
/**
 *  Return true if "a-ws" class present on html element. This class is setup by AmazonUIPageJS to indicate widescreen mode.
 *
 *  @public
 *  @return {boolean}
 */
function widescreenUtils(util) {
  function widescreen() {
    return util.hasClass(document.documentElement, 'a-ws');
  }

  return {
    widescreen: widescreen
  };
}
/* Done importing utils/_widescreen.js */


    var utilModules = [
        collectionUtils,
        fnUtils,
        objectUtils,
        stringUtils,
        attributionUtils,
        visiblityUtils,
        cookieUtils,
        onScreenUtils,
        atfUtils,
        cssUtils,
        widescreenUtils
    ];

    for (var i = 0; i < utilModules.length; i++) {
        var mod = utilModules[i](util);
        for (var fn in mod) {
            util[fn] = mod[fn];
        }
    }
    
    return util;
});
/////////////////////////
// END FILE a_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_prv_capabilities.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI JS Detection - private version. This module returns an object that is a subset of what a-detect.capabilities
 *  returns - where all of the exposed capabilities are designated as unsafe. The difference is that this module does
 *  not do any tracking of whether or not you use the bad capabilities (hence it being designated private). In contrast,
 *  a-detect is added to the big A - where tracking and monitoring is setup (see a_ending.js)
 */

"use strict";


P.when("p-detect", "a-util", 'prv:a-private-util').register("prv:a-capabilities", function (pDetect, util, privateUtil) {
  var privateCapabilities = {};

  /**
   * A pre-evaluated flag to save computation and file size for further detections
   * @private
   * @type {boolean}
   */
  var isTrident = (/Trident/).test(privateUtil.ua);

  /**
   *  These are tests that are generally less reliable and accurate than tests in a_detect.js. The AUI documentation
   *  does not document these feature detections.
   *  NOTE: The order of this list of tests matters, because there are interdependencies when evaluating them.
   *  For example, isIE10Plus is used in isIETouchCapable and isMetroIEGuess - so isIE10Plus has to be evaluated first
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var PRIVATE_TESTS = {
    isChrome: function () {
      return (/Chrome/).test(privateUtil.ua);
    },
    isUCBrowser: function() {
      return (/UCBrowser/).test(privateUtil.ua);
    },
    isSafari: function () {
      var styleObj = document.documentElement.style;
      // This crazy looking code was grabbed from a_preload.js (lines 176-194)
      return (!('MozAppearance' in styleObj) && ('webkitAppearance' in styleObj) && /^Apple/.test(navigator.vendor));
    },
    /*
     It's not technically feasible or really possible to detect that the browser is the Android stock
     browser with absolute certainty due to the custom UA strings from vendors and the general vagueness
     of the info in the UA string.  Also, the dolphin browser has the same UA string as the stock browser.
     This is my attempt at a best guess.  If it's an Android browser, but not another, known brand of browser,
     and the WebKit version isn't too high, we're going to guess that this is the stock browser.

     Upshot:  We can't guarantee that this is correct, but it's our best guess.
     */
    isAndroidStockGuess: function () {
      var result = false;
      if (pDetect.capabilities.android && !(/Chrome|Opera|Firefox|UCBrowser/).test(privateUtil.ua)) {
        var matches = (/AppleWebKit\/(\d+\.\d+)/).exec(privateUtil.ua);
        result = matches[1] && matches[1] < "535"; // Android stock browser never got above AppleWebKit version 534.x
      }
      return result;
    },
    isFirefox: function () {
      return (/Firefox/).test(privateUtil.ua);
    },
    /*
     IE11 maintains compatibility with the prefixed version of the Pointer Event, and thus this would
     false positive without the third check
     */
    isIE: function() {
      return isTrident;
    },
    isIE10: function() {
      return isTrident && "onmspointerup" in document && !("onpointerup" in document);
    },
    isIE10Plus: function() {
      return isTrident && ("onpointerup" in document || "onmspointerup" in document);
    },
    isIE11Plus: function() {
      return isTrident && "onpointerup" in document;
    },
    isiOS8: function() {
      return pDetect.capabilities.ios && (/Version\/8\./).test(privateUtil.ua);
    },
    /*
     Useful for determining if you will ever see an on screen keyboard causing the viewport to shrink
     upon text input.
     */
    isIETouchCapable: function() {
      return privateCapabilities.isIE10Plus && (/Touch;/).test(privateUtil.ua);
    },
    /*
     It is not possible to detect the difference between Metro IE and IE because Microsoft wanted it that way. Sigh.
     - Metro is always ActiveX disabled (it *can* be disabled outside, but this is the best indicator)
     - Confirm IE10+ and not mobile
     */
    isMetroIEGuess: function() {
      var activeXEnabled = true;
      try {
        activeXEnabled = new ActiveXObject("htmlfile");
      } catch(e) {
        activeXEnabled = false;
      }
      return privateCapabilities.isIE10Plus && !pDetect.capabilities.mobile && !activeXEnabled;
    }
  };

  // Expose the private tests safely
  util.each(PRIVATE_TESTS, function (fn, name) {
    privateCapabilities[name] = privateUtil.safeFeatureTest(fn);
  });

  return privateCapabilities;
});
/////////////////////////
// END FILE a_prv_capabilities.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_detect.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI JS detection library
 *
 */

"use strict";

/**
 *  Useful detection features for JS code which don't need a corresponding CSS class to be placed on the <html> node.
 */
P.when("p-detect", "prv:a-capabilities", "a-util", 'prv:a-private-util').register("a-detect", function (pDetect, privateCapabilities, util, privateUtil) {

  /**
   *  A copy of the results of p-detect which is going to end up on the A library.
   *
   *  @public
   *  @type {object}
   */
  var detect = util.copy(pDetect);

  /**
   * Retrieves the version of Android
   *
   * @return {string | null} Android version or null if not Android
   */
  var getAndroidVersion = function () {
    var matches = (/(?:Android\s+|Windowshop.*Android\/|Android\/)(\d+(?:\.\d+)*)/).exec(privateUtil.ua);
    return matches && matches[1];
  };

  /**
   *  A list of test functions to execute and place onto the capabilities object from p-detect
   *  NOTE: The order of this list of tests matters, because there are interdependencies when evaluating them.
   *  For example, pointerPrefix is used in evaluating actionMode - so pointerPrefix always has to come first.
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var PUBLIC_TESTS = {
    isAmazonApp: function () {
      // See AUI-4222 for how this works
      return (/(Windowshop|Amazon|Amazon\.com)\//).test(util.cookies.get('amzn-app-id'));
    },
    isGen5App: function () {
      return (/Windowshop.*(?:KFOT|KFTH|KFJWA|KFJWI|KFTT)/).test(privateUtil.ua);
    },
    isAndroid: function () {
      return detect.capabilities.android;
    },
    androidVersion: function () {
      return getAndroidVersion();
    },
    isAndroidKitkatPlus: function () {
      var version = getAndroidVersion();
      return version && version.match(/(^4\.[4-9]|^[5-9]|^\d\d)/) !== null;
    },
    isOldAndroid: function () {
      return (/Android\s[12]/).test(privateUtil.ua);
    },
    pointerPrefix: function() {
      if ("onmspointerup" in document || "onpointerup" in document) {
        return "onpointerup" in document ? "pointer" : "MSPointer";
      }
      return false;
    },
    actionMode: function() {
      var prefix = detect.capabilities.pointerPrefix;
      return prefix ? prefix : (detect.capabilities.touch ? "touch" : "mouse");
    }
  };

  /**
   *  A mapping of event name suffixes to their relevant input types
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var SUFFIXES = {
    start: {
      mouse: "down",
      touch: "start",
      pointer: "down",
      MSPointer: "Down"
    },
    end: {
      mouse: "up",
      touch: "end",
      pointer: "up",
      MSPointer: "Up"
    },
    move: {
      mouse: "move",
      touch: "move",
      pointer: "move",
      MSPointer: "Move"
    },
    //http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx (enter/leave)
    enter: {
      mouse: "enter",
      touch: "enter",
      pointer: "enter"
    },
    leave: {
      mouse: "leave",
      touch: "leave",
      pointer: "leave"
    },
    cancel: {
      touch: "cancel",
      pointer: "cancel",
      MSPointer: "Cancel"
    },
    over: {
      mouse: "over",
      pointer: "over",
      MSPointer: "Over"
    },
    out: {
      mouse: "out",
      pointer: "out",
      MSPointer: "Out"
    }
  };

  /**
   *  A generated object of functions that returns the appropriate event action
   *
   *  @public
   *  @type {object}
   */
  var action = {};

  // Expose the public tests safely
  util.each(PUBLIC_TESTS, function (fn, name) {
    detect.capabilities[name] = privateUtil.safeFeatureTest(fn);
  });

  // Extend capabilities with private capabilities
  util.extend(detect.capabilities, privateCapabilities);

  //Generate appropriate return functions for given action types
  util.each(SUFFIXES, function (obj, name) {
    /*
    1. If the suffix doesn't have variation, store the string
    2. If the suffix has variations, store the appropriate variation
    -- START MECHA TERNARY --
    3. If the variation exists, output the prefix + suffix pair
    4. Otherwise, if the variation turns out to be undefined, fall back to mouse events
    5. Then, if the fallback mouse event (touch/pointer/mspointercancel) doesn't exist,
       output "" instead, as undefined throws a TypeError when used in jQuery bind

    Ultimately this should mean all events will output something except requests for
    mousecancel which doesn't exist.
    */
    var am = detect.capabilities.actionMode;
    var suffix = typeof obj === "string" ? obj : obj[am];

    action[name] = suffix ? am + suffix : obj.mouse === undefined ? "": "mouse" + obj.mouse;
  });

  //attach the generated action functions to detect
  detect.action = action;

  /**
   *  A generated object of properties that normalize the differences in pointer types between IE10 and 11
   *
   *  @public
   *  @type {object}
   */
  var pointerType = {};

  if (detect.capabilities.pointerPrefix === "pointer") {
    pointerType.touch = "touch";
    pointerType.pen = "pen";
    pointerType.mouse = "mouse";
    pointerType.unknown = "";
  }
  else if (detect.capabilities.pointerPrefix === "MSPointer") {
    pointerType.touch = 2;
    pointerType.pen = 3;
    pointerType.mouse = 4;
  }

  detect.pointerType = pointerType;

  return detect;
});
/////////////////////////
// END FILE a_detect.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_defer.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Defer Queue

'use strict';

P.when('prv:a-guard').register('a-defer', function(guard) {
  var deferQueue = [];
  var executing = false;
  var TIME_SLICE = 50;
  var WAIT_TIME = 50;
  var executionTime = 0;

  function partialExecute(queue) {
    var wait = 0;
    var safetyTimeout = setTimeout(function() {
      partialExecute(queue);
    }, 0);

    if (queue.length === 0) {
      clearTimeout(safetyTimeout);
      executing = false;
      return;
    }

    var start = Date.now();

    queue.shift().call();

    executionTime = executionTime + (Date.now() - start);

    if (executionTime > TIME_SLICE) {
      wait = WAIT_TIME;
      executionTime = 0;
    }

    setTimeout(function() {
      partialExecute(queue);
    }, wait);
    clearTimeout(safetyTimeout);
  }

  // Execute on a timesliced queue

  var defer = function defer(fn) {

    deferQueue.push( guard.fn(this, fn) );

    if (!executing) {
      executing = true;
      setTimeout(function() {
        partialExecute(deferQueue);
      }, 0);
    }
  };

  function executeDeferred() {
    // Deprecated (AUI-2910)
  }

  function pauseDeferred() {
    // Deprecated (AUI-2910)
  }

  return {
    defer: defer,
    pauseDeferred: pauseDeferred,
    executeDeferred: executeDeferred
  };
});
/////////////////////////
// END FILE a_defer.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Events
'use strict';

/**
 * Notes on naming conventions:
 *
 * Internally,
 *   Callbacks are Subscribed to Topic Names.
 *   Messages are Published to Topic Names.
 *   By publishing, a Send Queue is created then processed.
 *
 * Externally (visible to clients),
 *   Callbacks are Registered to Event Names with ".on".
 *   Callbacks are Deregistered from Event Names with ".off".
 *   Callbacks are Tiggered with Messages to Event Names with ".trigger".
 */

// When in debug mode, add an additional dependency on debug-only utils
 var A_EVENTS_DEPENDENCIES;
if (AUI_JS_DEBUG) {
  A_EVENTS_DEPENDENCIES = P.when('a-util', 'a-util-dbg');
} else {
  A_EVENTS_DEPENDENCIES = P.when('a-util');
}

A_EVENTS_DEPENDENCIES.register('a-events', function(util, dbgUtil) {
  /*
   * `topics` is modified in-place with `unshift` and `shift`.
   * Never re-assign to any queues.
   * Be careful with caching length, it may change from under you.
   */
  var topics = {};
  var TIME_SLICE = 50;
  var WAIT_TIME = 15;

  /**
   * @param {*} array Array to modify in-place
   * @param {*} predicate Return truthy to keep the element.
   */
  function destructiveFilter(array, predicate) {
    var i = array.length;
    while (i--) {
      if (!predicate(array[i], i, array)) {
        array.splice(i, 1);
      }
    }
  }

  /** Reports an error that occurred during event execution. */
  function reportError(callbackObj, error) {
    var message = 'Event execution failed for event ' + callbackObj.topic;
    var logger = callbackObj.logError ? callbackObj : P;
    logger.logError(error, message, 'FATAL');
  }

  /**
   * Publish the first pending callback on the given queue.
   * Return STOP_SENDING if there are no more items to process.
   */
  var STOP_SENDING = {}; // {} is a CONST which can't be faked.
  function sendOne(sendQueue) {
    var callbackObj = sendQueue.shift();
    if (callbackObj === undefined) {
      return STOP_SENDING;
    }
    try {
      // If a callback returns false,
      // don't call any of the others for that particular publishing id
      if (callbackObj.fn.apply(window, callbackObj.args) === false) {
        destructiveFilter(sendQueue, function(queuedCallback) {
          return queuedCallback.id !== callbackObj.id;
        });
      }
    } catch (e) {
      reportError(callbackObj, e);
    }
  }

  var sendTimesliced = (function () {
    var sending = false;
    var queue = [];

    return function (sendQueue) {
      Array.prototype.push.apply(queue, sendQueue);
      if (!sending) {
        sendTimeslicedLoop();
      }
    };

    function sendTimeslicedLoop() {
      sending = true;
      var start = util.now();
      while (util.now() - start < TIME_SLICE) {
        if (sendOne(queue) === STOP_SENDING) {
          sending = false;
          return;
        }
      }
      util.delay(sendTimeslicedLoop, WAIT_TIME);
    }
  })();

  /*
   * process already wraps a try/catch and reports errors,
   * so we do not need retry logic here.
   */
  var sendSync = (function () {
    var sending = false;
    var queue = [];

    return function (sendQueue) {
      Array.prototype.push.apply(queue, sendQueue);
      if (!sending) {
        sending = true;
        while (sendOne(queue) !== STOP_SENDING);
        sending = false;
      }
    };
  })();

  var publishId = 0;
  function publish(topicName, messages) {
    if (!isSubscribed(topicName)) {
      return;
    }

    var id = publishId++;
    var subscriptions = topics[topicName];
    messages = messages || [];

    var sendQueue = util.map(subscriptions, function(subscription) {
      return {
        topic: topicName,
        id: id,
        fn: subscription.guard ? subscription.guard(subscription.fn) : subscription.fn,
        args: messages,
        logError: subscription.logError
      };
    });

    if (subscriptions.occurred) {
      unsubscribeAll(topicName);
    }

    if (subscriptions.isTimeSliced) {
      sendTimesliced(sendQueue);
    } else {
      sendSync(sendQueue);
    }
  }

  function subscribe(topicName, callback, logHandlers) {
    if (typeof callback !== 'function') {
      return;
    }

    var subscription = {
      fn: callback,
      logError: logHandlers && logHandlers.logError,
      guard: logHandlers && logHandlers.guard
    };

    // Note: this function effectively reverses the order of the handlers when it moves them from the subscriptions array
    // to the timesliceQueue.  We could change this later on (so it's a FIFO instead of a LIFO), but it's technically
    // backwards incompatible.  Still, hopefully no one is really depending on order.
    (topics[topicName] = topics[topicName] || []).unshift(subscription);

    return {
      event: topicName,
      callback: callback
    };
  }

  function unsubscribeAll(topicName) {
    topics[topicName].length = 0; // in-place, not reassignment
  }

  function unsubscribe(topicNames, callback) {
    util.each(
      util.filter(topicNames.split(' '), isSubscribed),
      callback ? unsubscribeCallback : unsubscribeAll
    );

    function unsubscribeCallback(topicName) {
      destructiveFilter(topics[topicName], function(subscription) {
        return subscription.fn !== callback;
      });
    }
  }

  function isSubscribed(topicName) {
    return topics.hasOwnProperty(topicName) && topics[topicName].length > 0;
  }

  var eventDefaults = {
    input: 'change',
    select: 'change',
    a: 'click',
    button: 'click',
    form: 'submit'
  };

  var on = (function() {
    var onFn = function(eventNames, fn, one) {
      var eventNameList = eventNames.split(' ');
      var subscribedEventNames = [];

      var finalCallback = fn;
      if (one === true) {
        finalCallback = function() {
          // arguments come from publish --> partial publish
          fn.apply(window, arguments);
          // only one event is coming through when one === true
          unsubscribe(eventNames, finalCallback);
        };
      }

      // Extra parameters to pass when subscribing to an event. In this context, `this` will
      // be either the `a-events` object returned by this module, or `A` itself. When `this` is
      // `A`, these functions will apply proper attribution to any errors that get thrown
      // by event observers
      var logHandlers = this ? { logError: this._logError, guard: this._guard } : {};

      util.each(eventNameList, function(topicName) {
        if ((topics[topicName] || []).occurred) {
          // deliberately use fn as we don't store these events past their singular execution
          subscribe(topicName, fn, logHandlers);
          publish(topicName);
        } else {
          subscribedEventNames.push(subscribe(topicName, finalCallback, logHandlers).event);
        }
      });

      return {
        event: subscribedEventNames.join(' '),
        callback: finalCallback
      };
    };

    var onEventList = ['ready', 'load', 'unload', 'afterLoad', 'scroll', 'resize', 'orientationchange', 'zoom'];

    util.each(onEventList, function(eventName) {
      onFn[eventName] = function(fn, one) {
        onFn.call(this, eventName, fn, one);
      };
    });

    return onFn;
  })();

  function one(topicName, fn) {
    var singleTopicCheck = topicName.split(' ');

    if (singleTopicCheck.length > 1) {
      P.error(
        'A.one only accepts a single event name, but was provided with: ' +
        singleTopicCheck.length + ', (' + topicName + ')',
        'A.events',
        'one'
      );
      return;
    }

    return on(topicName, fn, true);
  }

  function off(handleOrName, fn) {
    var eventToUnsubscribe;
    var fnToUnsubscribe;
    if (typeof handleOrName === 'object') {
      // An eventHandle (returned by A.on) is given
      eventToUnsubscribe = handleOrName.event;
      fnToUnsubscribe = handleOrName.callback;
    } else {
      eventToUnsubscribe = handleOrName;
      fnToUnsubscribe = fn;
    }
    return unsubscribe(eventToUnsubscribe, fnToUnsubscribe);
  }

  function trigger(eventName /*, ...messages */) {
    var argsLength = arguments.length;
    var messages = new Array(argsLength);
    for (var i = 0; i < argsLength; i++) {
      messages[i] = arguments[i];
    }
    messages.shift();

    publish(eventName, messages);
  }

  /**
   *  Trigger a one-time event, like "ready" for DOMReady.  If event listeners bind to this event after the event has
   *  fired, they will be immediately invoked; it behaves like a P module, in that regard.
   *
   *  @private
   *  @param {string} topicName The name of the event to trigger.
   *  @param {boolean} [shouldTimeSlice=true] Whether the event listeners for this event should be timesliced.
   */
  function oneTimeEvent(topicName, shouldTimeSlice) {
    var eventRegisterFn = function() {
      P.register(topicName, function() {
        var start = window.aPageStart;
        return { time: start ? util.now() - start : 0 };
      });
    };

    var subscriptions = topics[topicName] = topics[topicName] || [];
    if (!subscriptions.occurred) {
      subscriptions.isTimeSliced = shouldTimeSlice !== false;
      subscriptions.occurred = true;
      subscribe(topicName, eventRegisterFn);
      publish(topicName);
    }
  }

  function Events(guard, logError) {
    var originalOn = this.on;

    // The event module's implementation of on() expects to have `A` as its caller in order to gain access to
    // its error attribution data. We'll also provide _guard/_logError to this instance's on(), so A.on.* calls
    // also attribute errors correctly.
    this.on = function() { return originalOn.apply(this, arguments); };
    this.on._guard = guard;
    this.on._logError = logError;

    for (var topicName in originalOn) {
      if (originalOn.hasOwnProperty(topicName)) {
        this.on[topicName] = originalOn[topicName];
      }
    }

    // This is to ensure the constructor for this module doesn't get applied to A
    this.constructor = undefined;
  }

  Events.prototype = {
    isListening: isSubscribed,
    on: on,
    one: one,
    off: off,
    trigger: trigger,
    events: {
      defaults: eventDefaults
    }
  };

  Events.prototype.constructor = Events;

  // Util function used below to hook an event listener up for the window
  // attachEvent is included for ie8 compatability
  function windowOn(listener, fn) {
    if (window.attachEvent) {
      window.attachEvent("on" + listener, fn);
    } else {
      window.addEventListener(listener, fn, false);
    }
  }

  // Set up these two page lifecycle events outside of 'prv:a-register-load-events'
  // This is so they get triggered in the right order (or at all) even when the load/ready events are delayed
  P.when('a-bodyBegin').execute(function () {
    // Re-trigger the 'bodyBegin' event from PageJS so it can be consumed with A.on
    oneTimeEvent('bodyBegin');
  });
  // Window unload
  windowOn('unload', function () {
    oneTimeEvent('unload', false);
  });

  // Function to call to register `load` and `ready` events (along with associated before/after events)
  function registerLoadEvents(detect) {
    // Triggers the 'load' event
    var load = util.once(function () {

      oneTimeEvent('beforeLoad');
      oneTimeEvent('load');

      // After window load
      util.delay(function () {
        oneTimeEvent('beforeAfterLoad');
        oneTimeEvent('afterLoad');
      }, 1500);
    });

    // Triggers the 'ready' event. This can be called multiple times and only
    // the first time will actually have an effect
    var ready = util.once(function () {
      if (detect.responsiveGridEnabled()) {
        detect.toggleResponsiveGrid(true);
      }
      oneTimeEvent('beforeReady');
      oneTimeEvent('ready');
      oneTimeEvent('afterReady');

      // Fire load after ready if window.load occurred before the JS was loaded
      if (document.readyState === 'complete') {
        load();
      }
    });

    // Trigger the 'ready' event when jquery tells us its okay
    documentReady(ready);

    // Sometimes, jQuery will load after DOMContentLoaded has fired. If that
    // happens, we need to listen to the a-domready event, which is guaranteed
    // to be hooked in before the dom is fully loaded
    P.when('a-domready').execute(ready);

    // Trigger the 'load' event
    windowOn('load', load);

    function documentReady(fn) {
      if (document.readyState != 'loading') {
        fn();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        document.attachEvent('onreadystatechange', function () {
          if (document.readyState != 'loading') fn();
        });
      }
    }
  }

  // For debugging, when right url param is present, delay page load and dom ready events
  if (AUI_JS_DEBUG) {
    //Setup visual cues for "ready" event firing
    dbgUtil.displayReadyDebug();
    var loadEventsDelay = dbgUtil.getLoadEventsDelay(window);
    if (loadEventsDelay) {
      util.delay(function () {
        P.declare('delay-load-events');
      }, loadEventsDelay);

      P.when('p-detect', 'delay-load-events').execute(registerLoadEvents);
    } else {
      P.when('p-detect').execute(registerLoadEvents);
    }
  } else {
    // Setup execution of registering load events, with no delaying dependency
    P.when('p-detect').execute(registerLoadEvents);
  }

  return Events.prototype;
});
/////////////////////////
// END FILE a_events.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_prefix.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI prefix detection for events and CSS rules.
 *
 */

"use strict";

/**
 *  Returns methods which can be used to detect whether or not a CSS rule or event is supported by the browser
 *  as well as any vender prefixes which need to be applied for that rule/event.
 */
P.when("a-util", "a-events").register("a-prefix", function (util, events) {

  /**
   *  Keep track of the status of event tests.
   *    null means that the test hasn't been run.
   *    false means that the test has run and the event isn't supported
   *    a string means that the event is supported and the string is the possibly prefixed name of the test.
   *
   *  @private
   *  @type {object}
   */
  var prefixedEvents = {
    transitionend: null
  };

  /**
   *  Keep the element's style attributes in memory for prefix testing.
   *
   *  @private
   *  @type {object}
   */
  var style = document.createElement("div").style;


  /**
   *  A map of unprefixed CSS attributes with their prefixed JS equivalents.
   *
   *  @private
   *  @type {object}
   */
  var prefixedRules = {};

  /**
   *  The browser prefixes we're testing for.
   *
   *  @private
   *  @type {array}
   */
  var prefixes = ["o", "ms", "moz", "webkit"];

  /**
   *  Convert a dash delimited string to a camel case string.
   *
   *  @private
   *  @param {string} str  The string to convert
   *
   *  @return {string}
   */

  function toCamelCase(str) {
    return str.toLowerCase().replace(/-(.)/g, function (match, group1) {
      return group1.toUpperCase();
    });
  }

  /**
   *  Convert a non-prefixed CSS rule and return the optionally prefixed version of the
   *  corresponding JS style property.
   *  Memoized
   *
   *  @private
   *  @param {string} rule
   *
   *  @return {string}
   */

  function prefixRule(rule) {
    if (!prefixedRules[rule]) {
      var jsRule = toCamelCase(rule);
      if (jsRule in style) {
        prefixedRules[rule] = jsRule;
      } else {
        var capitalized = jsRule.charAt(0).toUpperCase() + jsRule.slice(1);
        var i = prefixes.length;
        while (i--) {
          var prefixedRule = prefixes[i] + capitalized;
          if (prefixedRule in style) {
            prefixedRules[rule] = prefixedRule;
          }
        }
      }
    }
    return prefixedRules[rule];
  }

  /**
   *  Run these event tests during beforeReady so that people will have it as soon as possible.
   */
  events.on("beforeReady", function () {
    if (window.addEventListener) {
      /**
       *  Test for the transitionend event by trying to trigger it on a temporary element.
       *  Vendor prefixes taken from https://developer.mozilla.org/en-US/docs/Web/Reference/Events/transitionend?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Ftransitionend
       */
      var div = document.createElement("div");
      var transitionendhandler = function (event) {
        prefixedEvents.transitionend = event.type;
        this.removeEventListener("webkitTransitionEnd", transitionendhandler, false);
        this.removeEventListener("transitionend", transitionendhandler, false);
        this.removeEventListener("otransitionend", transitionendhandler, false);
        this.removeEventListener("oTransitionEnd", transitionendhandler, false);
      };
      var transition = "transition:top 1ms ease";
      div.setAttribute("style", "position:absolute;top:0px;z-index:-1;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;");
      div.addEventListener("transitionend", transitionendhandler, false);
      div.addEventListener("webkitTransitionEnd", transitionendhandler, false);
      div.addEventListener("otransitionend", transitionendhandler, false);
      this.addEventListener("oTransitionEnd", transitionendhandler, false);
      document.body.appendChild(div);

      // Delay to let paint happen
      util.delay(function () {
        div.style.top = "100px";
        // Long ass delay to ensure that the element isn't removed before the test can finish running
        util.delay(function () {
          div.parentNode.removeChild(div);
          div = transitionendhandler = null;
          util.each(prefixedEvents, function (prefix) {
            if (!prefix) {
              prefix = false;
            }
          });
        }, 100); // TODO can we use another technique here to get back the 100ms?
      }, 0);
    }
  });

  return {
    prefixes: {
      getStyle: prefixRule,
      getEvent: function (eventName) {
        return eventName ? prefixedEvents[eventName.toLowerCase()] : undefined;
      }
    }
  };
});
/////////////////////////
// END FILE a_prefix.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_draggable.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Draggable Library

'use strict';

P.when('a-util', 'jQuery', 'a-declarative').register('a-draggable', function (util, $, decl) {
  var DECLARATIVE_ACTION = 'a-draggables';
  var MOUSE_DOWN_LAYER_ID = 'a-draggables-mousedown-layer';
  
  // The initial z-index value for transparent layer. Currently, this value
  // allows 33 draggables to float before they begin to stack on top of regular immersive
  // modals (current the regular modals have z-index of 1009). This might need to be
  // changed to accomodate more draggables (or even made as an option to a-draggable)
  var INITIAL_Z_INDEX = 975;
  
  // A transparent layer that overlays everything beneath the current modeless modal
  var $layer;
  
  /**
   * Method for switching on the transparent layer. This enables
   * the transparent mouse layer for catching mousemove events.
   */
  var _showLayer = function () {
    if ($layer) {
      $layer.removeClass('aok-hidden');
    }
  };
  
  /**
   * Method for switching off the transparent layer. This disables
   * the transparent mouse layer.
   */
  var _hideLayer = function () {
    if ($layer) {
      $layer.addClass('aok-hidden');
    }
  };
  
  /**
   * Manages the z-index of draggables to allow them to be stackable. This could
   * be implemented with simple increment on a global counter, but the counter
   * can grow large enough that the draggables cover other popovers (e.g. it
   * might cover other popover elements within the modal itself).
   */
  var _zIndexManager = {
    _maxZIndex: 0,
    _isInit: false,
    _draggables: [],
    
    /**
    * Initialise data
    */
    _init: function () {
      if (!this._isInit) {
        this._isInit = true;
        this._maxZIndex = INITIAL_Z_INDEX;
      }
    },
    
    /**
     * Create the stackable draggable and push it into the managed array.
     *
     * @param   $obj  The object to be added to the managed queue
     */
    create: function ($obj) {
      this._init();
      
      // zim for Z Index Manager
      if (!$obj._zimIndex) {
        $obj._zimIndex = INITIAL_Z_INDEX;
        this._maxZIndex += 1;
        this._draggables.push($obj);
      }
      
      this.acquireFocus($obj);
    },
    
    /**
     * Grants maximum z-index to the object
     *
     * @param   $obj    The object we want to bring to front
     */
    acquireFocus: function ($obj) {
      // Set the focused object to max index
      $obj.css('zIndex', this._maxZIndex);
      // Set the layer to just one index below focused object
      $layer.css('zIndex', this._maxZIndex - 1);
      
      // Adjust the z-index for each of the managed draggables
      for (var i = 0; i < this._draggables.length; i++) {
        var item = this._draggables[i];
        
        // Do not modify the z-index if the item is already below obj
        if (item[0] !== $obj[0] && item._zimIndex > $obj._zimIndex) {
          // If the item was above layer, move it down by 2 z-indices (one for the focused
          // object and one for the layer itself). Otherwise, simply move it down
          // by 1 z-index
          item._zimIndex -= (item._zimIndex > this._maxZIndex - 1) ? 2 : 1;
          item.css('zIndex', item._zimIndex);
        }
      }
      
      // Lastly, remember to update the _zimIndex
      $obj._zimIndex = this._maxZIndex;
    }
  };
  
  /**
   * Returns the draggable object in the event
   *
   * @param   event   Event fired from an object
   * @return  The draggable object (undefined if event is not from a draggable);
   */
  var _getDraggable = function (event) {
    return event.data.$draggable;
  };
  
  /**
   * Returns the coordinates of where the event happened
   *
   * @param   event   The event to extract coordinates from
   * @return  An object with x and y properties
   */
  var _getEventCoordinates = function (event) {
    var e = event.$event;
    
    // Check for touch events as the touch coordinates are stored
    // differently
    if (util.contains('touchstart touchend touchmove', event.type)) {
      e = e.originalEvent.touches[0];
    }
    
    return {
      x: e.clientX,
      y: e.clientY
    };
  };
  
  /**
   * Handling mouse move event when mouse is down.
   *
   * @param   event   The AUI mouse event
   */
  var mousemoveHandler = function (event) {
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    var coords = _getEventCoordinates(event);
    
    if (data.isMouseDown) {
      $draggable.css({
        left: coords.x - data.clickOffset.x,
        top: coords.y - data.clickOffset.y
      });
      
      event.$event.preventDefault();
    }
  };
  
  /**
   * Handle mouse down event.
   *
   * When mouse is pressed, the method checks whether it is pressed
   * within the specified handle; if so, it sets the state for isMouseDown
   * in the declarative data. This helps mousedragHandler in identifiying
   * whether this is a dragging event.
   *
   * The method then creates a transparent layer covering the full screen,
   * positioned 1 layer below the draggable object (z-index - 1). This layer
   * is needed because JavaScript sometimes cannot catch up to mouse movement,
   * and the event will be generated from outside of the draggable object. This
   * layer will help catch those events generated outside of the draggable and
   * keep updating the position of the object.
   *
   * @param   event   The AUI mouse event
   */
  var mousedownHandler = function (event) {
    var node = event.$event.target || event.$event.srcElement;
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    
    // Bring the object up on click
    _zIndexManager.acquireFocus($draggable);
    
    // Check if the click target is within the handle
    node = $(node).closest(data.$handle, $draggable);
    // Length is 0 if $.closest cannot find anything
    data.isMouseDown = node.length > 0;
    
    if (data.isMouseDown) {
      _showLayer();
      
      var coords = _getEventCoordinates(event);
      
      // Update object position by offset
      data.clickOffset = {
        x: coords.x - parseFloat($draggable.css('left')),
        y: coords.y - parseFloat($draggable.css('top'))
      };
      
      // Update both declarative data
      $draggable.data(DECLARATIVE_ACTION, data);
      $layer.data(DECLARATIVE_ACTION, data);
      
      event.$event.preventDefault();
    }
  };
  
  /**
   * Handle mouse up event. Also removes the transparent layer.
   *
   * @param   event   The AUI mouse event
   */
  var mouseupHandler = function (event) {
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    
    data.isMouseDown = false;
    $draggable.data(DECLARATIVE_ACTION, data);
    _hideLayer();
  };
  
  /**
   * Method for creating the transparent layer (see description in mousedownHandler).
   *
   * @param   options     The options for the draggable declarative
   */
  var _createLayer = function (options) {
    if (!$layer) {
      // Added quotes around class only so that the unminified version runs
      // under old IEs; the build process will have class double quoted either way
      $layer = $('<div>', { id: MOUSE_DOWN_LAYER_ID, 'class': 'aok-hidden' })
          .appendTo('body');
        
      decl.declarative.create($layer, DECLARATIVE_ACTION, options);
    }
  };
  
  return {
    /**
     * Function for making a DOM object draggable.
     *
     * @param   obj       The object to be made draggable. It must have a fixed position
     * @param   options   Options for the draggable. Currently supports the following properties:
     *                      - handle: (Optional) A DOM or jQuery object where mouse dragging
     *                                should happen. If not supplied, the entire obj will be draggable
     */
    draggable: function (obj, options) {
      var $obj = obj.jquery? obj : $(obj);
      var opts = {
        isMouseDown: false,
        $draggable: $obj,
        $handle: options && options.handle ? options.handle : $obj
      };
      
      opts.$handle = opts.$handle.jquery? opts.$handle : $(opts.handle);

      // Set cursor type to move to indicate that the window is movable
      opts.$handle.css('cursor', 'move');
      
      _createLayer(opts);
      _zIndexManager.create(opts.$draggable);
      
      // Create delcarative for the action
      decl.declarative.create(opts.$draggable, DECLARATIVE_ACTION, opts);
      
      // If mousedown within the specified handle, set status 'isMouseDown'
      decl.declarative(DECLARATIVE_ACTION, ['mousedown', 'touchstart'], mousedownHandler);
      
      // Any mouseup event will unset isMouseDown
      decl.declarative(DECLARATIVE_ACTION, ['mouseup', 'touchend'], mouseupHandler);
      
      // Listen to mouse move
      decl.declarative(DECLARATIVE_ACTION, ['mousemove', 'touchmove'], mousemoveHandler);
    }
  };
});
/////////////////////////
// END FILE a_draggable.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_state.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Page State
 *
 */

'use strict';

/**
 *  Allows features on the page to create a namespaced in-memory data hash and register callbacks which listen for
 *  changes on that namespace.
 */
P.when('jQuery', 'a-util', 'a-events', 'a-declarative', 'a-constants', 'a-analytics')
  .register('a-state', function ($, util, events, declarative, constants, analytics) { // jshint ignore:line
  /**
   *  Internal data cache which associates data with certain namespaces
   *
   *  @private
   *  @type {object}
   */
  var states = {};

  /**
   *  Update the data associated with the given namespace based on the new data.
   *  Passing null will clear the namespace. Passing scalar values (numbers,
   *  strings, booleans, or functions) is not supported by this API.
   *
   *  @private
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  New data to be placed on the namespace
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *  @param {boolean} replace  If set to true, the namespace will be overridden with whatever is passed in (optional)
   *
   *  triggers a:state:update:[namespace]
   *
   *  @return {object}  The new hash associated with the namespace
   */
  function updateNamespace(namespace, data, silent, replace) {
    var newNamespace = !hasNamespace(namespace);
    if (data === null || $.isArray(data) || $.isPlainObject(data)) {
      var prev = getNamespace(namespace);
      if (!prev || !data || replace || !($.isArray(prev) || $.isPlainObject(prev))) {
        states[namespace] = util.copy(data);
      } else {
        util.extend(states[namespace], data);
      }
      var changed = util.diff(prev, states[namespace]);
      var newState = getNamespace(namespace);

      if (!silent) {
        events.trigger('a:state:update:' + namespace, newState, changed, prev);
      }

      // declare namespave via P if it's a new set namespace
      if(newNamespace){
        var moduleName = constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + namespace;
        P.declare(moduleName, newState);
      }

      return newState;
    } else {
      P.error("Invalid value passed to A.state with a namespace of " + namespace + ".  Value: " + data, "A.state", "updateNamespace");
    }
  }

  /**
   *  Get a copy of the data associated with the namespace
   *
   *  @private
   *  @param {string} namespace  The namespace of the data to be retrieved
   *
   *  @return {object}  The data hash associated with the namespace
   */
  function getNamespace(namespace) {
    return util.copy(states[namespace]);
  }

    /**
     *  Check is namespace has been set
     * @param namespace
     * @returns {boolean}
     */
  function hasNamespace(namespace){
    return namespace in states;
  }

  /**
   *  Converts an array of strings like ["customer", "firstName"] into an object like:
   *  customer : { firstName : value }, and assigns the passed in value to the last key
   *
   *  @private
   *  @param {object} obj  The object onto which the "keys" will be attached
   *  @param {array} keys  An array of strings which will be converted into a nested object
   *                       with the same order as the array
   *  @param {object} value  The value to attach to the leaf "key"
   *
   *  @return {object} The obj, with the converted "keys" array attached
   */
  function keyNameToObject(obj, keys, value) {
    if (keys.length === 1) {
      obj[keys.shift()] = value;
      return obj;
    }

    obj[keys.shift()] = keyNameToObject({}, keys, value);
    return obj;
  }

  /**
   *  A combined event handler for all a-state related declarative events.
   *
   *  @private
   *  @param {object} event
   */
  function handleEvent(event) {
    var $target = event.$target;
    var namespace = event.data.key;
    var eventProps = event.data[event.type];

    // If no key name is provided for this event, let's fallback to the "name"
    // attribute if the triggering event is the default event for that tag type
    if (!eventProps && events.events.defaults[event.targetTag] === event.type) {
      eventProps = $target.attr("name");
    }

    // Nothing to do for this event
    if (!eventProps || !namespace) {
      return;
    }

    // Handle select elements by getting the currently selected option[s]
    if ($target.is('select')) {
      $target = $target.find(':selected');
    }

    // Handle form elements
    if (typeof $target.val() !== undefined && typeof eventProps === 'string') {
      var val = $target.val();

      // Handle checkboxes
      if ($target.is('input[type=checkbox]') && !($target.prop('checked'))) {
        val = null;
      }

      eventProps = keyNameToObject({}, eventProps.split('.'), val);
    }

    // Save the data
    updateNamespace(namespace, eventProps);
  }

  // Register declarative API bindings
  declarative.declarative('a-state', handleEvent);

  /**
   *  A combined getter and setter for the state data.
   *
   *  @public
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  The object to be extended onto the existing namespace (optional)
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *
   *  @return {object}  The current data associated with the namespace.
   */
  var state = function (namespace, data, silent) {
    return data === undefined ? getNamespace(namespace) : updateNamespace(namespace, data, !!silent);
  };

  /**
   *  Bind a callback function which is triggered when the given namespace changes.
   *  This is attached to the state function declared above.
   *
   *  @public
   *  @param {string} namespace  The namespace which will be monitored.
   *  @param {function} fn  The callback function
   */
  state.bind = function (namespace, fn) {
    events.on('a:state:update:' + namespace, fn);
  };

  /**
   *  A setter which overrides the current state value with whatever's passed in instead of extending the namespace.
   *
   *  @public
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  The object to be placed onto the existing namespace
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *
   *  @return {object}  The current data associated with the namespace.
   */
  state.replace = function (namespace, data, silent) {
    return updateNamespace(namespace, data, !!silent, true);
  };

  /**
   *  Parse script tags generated by the page_state template and load the data into
   *  the state cache.
   *
   *  @public
   */
  function parseScriptTags() {
    var scripts = document.getElementsByTagName('script');
    for (var i = 0, l = scripts.length; i < l; i++) {
      var parsed = $.data(scripts[i], 'a-eval');

      if (parsed) {
        continue;
      }

      var $elem = $(scripts[i]);
      var props = $elem.attr('data-a-state');
      if (!props) {
        continue;
      }
      var propsObj;
      try {
        propsObj = util.parseJSON(props);
      } catch (error) {
        analytics.logError(
          "[AUI] key value interface for accessing state data parsing failed",
          'ERROR',
          JSON.stringify({
            xpath: util.xpath(scripts[i]),
            cssSelector: util.cssSelector(scripts[i]),
            custody: util.attributionChain(scripts[i])
          })
        );
        throw error;
      }

      if (!propsObj.key) {
        continue;
      }

      var obj;
      try {
        obj = util.parseJSON($elem.html());
      } catch (e) {
        P.logError(e, 'State parsing failed for state ' + propsObj.key, 'ERROR');
        continue;
      }

      $.data(scripts[i], 'a-eval', true);

      // If something already exists in the namespace, then make sure that data takes precidence
      var current = states[propsObj.key];
      if (current) {
        util.extend(obj, current);
      }

      updateNamespace(propsObj.key, obj);
    }
  }

  /**
   *  When the DOM is ready, but before any ready callback fire, scan the DOM and
   *  ensure the state data is initialized.
   */
  events.on('beforeReady', parseScriptTags);

  /**
   *  Expose the function to parse the state data output by the page_state template.
   */
  state.parse = parseScriptTags;

  return {
    state: state
  };
});
/////////////////////////
// END FILE a_state.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Amazon UI Ajax
'use strict';

P.when(
  'prv:a-guard', 'jQuery', 'a-util', 'a-events', 'a-declarative', 'a-state'
).register('a-ajax', function (guard, $, util, events, declarative, state) { // jshint ignore:line
  var AUI_TAG = "aui";
  var AUI_AJAX_TAG = AUI_TAG + ":ajax";
  var AOK_HIDDEN_CLASS = 'aok-hidden'; // for showing/hiding the indicator

  /**
   *  Serialize get/post parameters
   *
   *  @private
   *  @param {object} params
   *  @param {String} type, type of params, could be
   *                  'string': params is a string
   *                  'json': params is an object, will be serialized with JSON.stringify
   *                  Anything else: params is an object, will be serialzied to URL query parameter.
   *
   *  @return {string} Serialized query parameters
   */
  function serializeParams(params, paramsFormat) {
    if(!params) {
      return '';
    }
    var isString = typeof params === 'string';
    if(paramsFormat === 'string') {
      return isString ? params : '';
    }
    if(paramsFormat === 'json') {
      if(isString) {
        return params;
      }
      try {
        return (JSON && JSON.stringify) ? JSON.stringify(params) : '';
      } catch(e){
        P.logError(e, 'AJAX POST failed to convert JSON object to string');
      }
      return '';
    }
    return isString ? "" : $.param(params);
  }

  var Ajax = (function () {
    // IE6 stank
    if (!window.XMLHttpRequest) {
      window.XMLHttpRequest = function () {
        return new ActiveXObject('Microsoft.XMLHTTP');
      };
    }

    // Global request Queue
    var requestQueue = (function () {
      var MAX_IN_FLIGHT = 4;
      var queue = [];
      var inFlight = 0;
      /**
       * Track total requests added to the queue
       * @private
       */
      var totalQueued = 0;
      /**
       * Track max requests in queue at any one time
       * @private
       */
      var maxQueued = 0;

      function abort(req) {
        var index = util.indexOfArray(queue, req);
        if (index !== -1) {
          queue.splice(index, 1);
        }

        complete();
      }

      function complete() {
        if (queue.length > 0) {
          queue.pop().send();
        } else {
          inFlight--;
        }
      }

      function add(req) {
        if (inFlight < MAX_IN_FLIGHT) {
          req.send();
          inFlight++;
        } else {
          queue.push(req);
          totalQueued++;
          if (queue.length > maxQueued) {
            maxQueued = queue.length;
          }
          var ue = window.ue;
          if (ue && ue.count) {
            ue.count(AUI_AJAX_TAG + ":queued", totalQueued);
            ue.count(AUI_AJAX_TAG + ":maxQueued", maxQueued);
          }
        }
      }

      return {
        add: add,
        complete: complete,
        abort: abort
      };
    }());

    /**
     *  Useful constants
     *
     *  @private
     *  @constant
     *  @type {object}
     */
    var xhrConstants = {
      // Statuses
      OK: 200,
      NOT_MODIFIED: 304,

      // States
      DONE: 4,
      IN_PROGRESS: 3,
      HEADERS: 2,
      OPENED: 1,
      UNSENT: 0,

      // Misc
      NOOP: function () {},
      DELIM: '&&&',
      DEFAULT_TIMEOUT: 20000, // If you want to change this, you'll need to also change the unit tests which depend on this constant
      DEFAULT_POLL_INTERVAL: 25
    };

    // Response handlers
    var responseHandlers = {
      streaming: function streaming(xhr) {
        var http = xhr.http;
        var buffer = xhr.buffer;

        var responseInProgress = false;
        var responseIsDone = false;

        // In Firefox it seems that the http.readyState can change over the course
        // of the execution of this function. Because of this we need to only
        // reference it once to ensure consistent behavior.
        switch (http.readyState) {
          case xhrConstants.DONE:
            responseIsDone = true;
            break;
          case xhrConstants.IN_PROGRESS:
            responseInProgress = true;
            break;
        }

        var successfulResponse = (http.status === xhrConstants.OK || http.status === xhrConstants.NOT_MODIFIED);
        var responsePosition = xhr.responsePosition;

        if (responseInProgress || (responseIsDone && successfulResponse)) {
          var response = http.responseText;

          if (responsePosition < response.length) {
            var newData = response.substring(responsePosition, response.length);
            var tokens = newData.split(xhrConstants.DELIM);
            var lastDelimPosition = newData.lastIndexOf(xhrConstants.DELIM);

            // No new delim found yet
            if (lastDelimPosition === -1 && responseInProgress) {
              return;
            }

            // The last delim wasn't found at the end, so the last token is not complete yet
            if (lastDelimPosition < (newData.length - xhrConstants.DELIM.length) && responseInProgress) {
              tokens.pop();
            }

            util.each(tokens, function (token, index) {
              var parsed;

              // Only attempt to parse if we're dealing with non-whitespace content as a whitespace response is not worthy of P.logError()
              if (util.trim(token) !== "") {
                try {
                  parsed = util.parseJSON(token);
                } catch (e) {
                  P.logError(e, 'Invalid streaming ajax JSON response: ' + token);
                }
              } else {
                // Pass along the whitespace token
                parsed = token;
              }

              xhr.callbacks.chunk(parsed);
            });

            xhr.responsePosition += lastDelimPosition;
          }
        }

        if (responseIsDone) {
          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.complete();

          if (successfulResponse) {
            xhr.callbacks.success(null, http.statusText, xhr);
          } else {
            xhr.callbacks.failure(xhr, http.statusText, http.statusText);
          }

          events.trigger('a:pageUpdate');
          // WARNING: There are teams that rely on this event ('a:ajax:complete') being named exactly this, as they trigger it themselves
          // to get ajaxed-in AUI templates to initialized correctly. For context, see this sim: https://issues.amazon.com/issues/AUI-21016 
          // and this commit: https://code.amazon.com/packages/ABAUICommonsAssets/commits/6078a7d624eca6bc0ee53d6810bd3825c42c9481
          events.trigger('a:ajax:complete');
        }
      },
      normal: function normal(xhr) {
        var http = xhr.http;

        if (http.readyState === xhrConstants.DONE) {
          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.complete();

          var response = http.responseText;

          // Attempt to parse as JSON, but ignore if there's a parse failure
          try {
            response = util.parseJSON(response);
          } catch (e) {}

          if (http.status !== xhrConstants.OK && http.status !== xhrConstants.NOT_MODIFIED) {
            xhr.callbacks.failure(xhr, http.statusText, http.statusText);
          } else {
            xhr.callbacks.success(response, http.statusText, xhr);
          }
          events.trigger('a:ajax:complete');
        }
      }
    };

    // Main XHR Object
    var StreamingXhr = (function () {

      /**
       *  A hash of default request headers to send with all types of requests.
       *
       *  @private
       *  @constant
       *  @type {object}
       */
      var DEFAULT_HEADERS = {
        all: {
          "X-Requested-With": "XMLHttpRequest"
        },
        get: {
          "Accept": "text/html,*/*"
        },
        post: {
          "Accept": "text/html,*/*",
          "Content-Type": "application/x-www-form-urlencoded"
        }
      };

      /**
       *  Check to see if a request has been open longer than the timeout specified by the user.
       *
       *  @private
       *  @param {Xhr} xhr
       */

      function checkTimeout(xhr) {
        if (xhr.http.readyState < xhrConstants.DONE) {
          clearInterval(xhr.pollTimer);

          // The browser might throw errors if we attempt to access the statusText property while the
          // request is still open
          var statusText = "Request Timeout";
          xhr.callbacks.failure(xhr, statusText, statusText);
          requestQueue.complete();
        }
      }

      /**
       *  Ensure that a string containing serialized query parameters is appended
       *  to the end of any URL properly.  This include URLs which already have some
       *  query parameters on them.
       *
       *  @private
       *  @param {string} url
       *  @param {string} params
       *
       *  @return {string}
       */

      function appendQueryParams(url, params) {
        if (params) {
          var idx = url.indexOf("?");
          var lastChar = url.charAt(url.length - 1);
          if (idx > -1) {
            if (lastChar !== "?" && lastChar !== "&") {
              url += "&";
            }
          } else {
            url += "?";
          }
          url += params;
        }
        return url;
      }

      /**
       *  Sets the request headers for an XHR.  The DEFAULT_HEADERS_ALL is always used, and the
       *  method specific defaults can be passed in to this function as well.  However, the
       *  user supplied headers reign supreme.
       *
       *  @private
       *  @param {XMLHttpRequest} http
       *  @param {string} method - The method of the request
       *  @param {object} headers - The user supplied headers hash
       *
       *  @return {XMLHttpRequest}
       */

      function setHeaders(http, method, headers) {
        headers = headers || {};

        headers = util.extend({}, DEFAULT_HEADERS.all, DEFAULT_HEADERS[method], headers);
        util.each(headers, function (value, name) {
          // We only set the header if the value is not falsey or is an empty string.
          // This allows people the most control since they can either accept our default, change it,
          // or just not send it
          if (value || value === "") {
            http.setRequestHeader(name, value);
          }
        });

        return http;
      }

      /**
       *  The differences in the get and post methods on the XHR prototype are very minor.  Abstract out the common stuff here and
       *  let the prototype methods handle the diff.
       *
       *  @private
       *  @param {Xhr} xhr
       *  @param {string} method
       *  @param {string} url
       *  @param {number} timeout
       *  @param {function} onChunk
       *  @param {function} onSuccess
       *  @param {function} onFailure
       *  @param {function} onAbort
       *  @param {object} headers
       *  @param {boolean} withCredentials
       *
       *  @return {object}
       */

      function setupRequest(xhr, method, url, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials) { // jshint ignore:line
        var http = xhr.http;
        http.open(method, url);
        setHeaders(http, method, headers);

        xhr.timeout = timeout;
        xhr.callbacks.chunk = onChunk || xhr.callbacks.chunk;
        xhr.callbacks.success = onSuccess || xhr.callbacks.success;
        xhr.callbacks.failure = onFailure || xhr.callbacks.failure;
        xhr.callbacks.abort = onAbort || xhr.callbacks.abort;

        /*
         *  IMPORTANT:  If we ever end up allowing synchronous requests, then we need to ensure that this property doesn't get set
         *  for synchronous requests.
         */
        if (withCredentials) {
          http.withCredentials = true;
        }

        requestQueue.add(xhr);

        return {
          abort: function () {
            xhr.abort();
          }
        };
      }

      var Xhr = function () {
        var http = new XMLHttpRequest();

        this.pollTimer = null;
        this.http = http;
        this.responsePosition = 0;
        this.buffer = '';

        this.callbacks = {
          success: xhrConstants.NOOP,
          failure: xhrConstants.NOOP,
          chunk: xhrConstants.NOOP,
          abort: xhrConstants.NOOP
        };
      };

      Xhr.prototype = {
        send: function () {
          var xhr = this;
          xhr.http.send(xhr.params);

          // Begin polling for streaming data
          xhr.pollTimer = setInterval(function () {
            if (xhr.http.readyState >= xhrConstants.HEADERS) {
              // IE stank
              if (typeof xhr.http.responseText !== 'unknown') {
                var lcContentType = xhr.http.getResponseHeader('Content-Type');
                lcContentType = lcContentType ? lcContentType.toLowerCase() : "";
                var streaming = lcContentType.indexOf('application/json-amazonui-streaming') !== -1 || /* Deprecated */ lcContentType.indexOf('application/amazonui-streaming-json') !== -1;
                var handler = streaming ? responseHandlers.streaming : responseHandlers.normal;
                handler(xhr);
              }
            }
          }, xhrConstants.DEFAULT_POLL_INTERVAL);

          // Set our timeout
          xhr.timeout = typeof xhr.timeout === 'undefined' ? xhrConstants.DEFAULT_TIMEOUT : xhr.timeout;

          // Set error timeout check
          xhr.timeoutTimer = util.delay(checkTimeout, xhr.timeout, xhr);
        },

        get: function (url, params, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials) { // jshint ignore:line
          return setupRequest(this, "get", appendQueryParams(url, params), timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials);
        },

        abort: function () {
          var xhr = this;
          if (xhr.http) {
            xhr.http.abort();
          }

          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.abort(xhr);
          xhr.callbacks.abort(xhr);
        },

        post: function (url, params, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials) { // jshint ignore:line
          this.params = params;
          return setupRequest(this, "post", url, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials);
        }
      };

      return Xhr;
    }());

    return StreamingXhr;
  }());

  var responseActions = {
    // Updates the provided target with the provided html
    update: function (command, target, html) {
      $(target).html(html);
    },
    // Appends the provided html to the provided target
    append: function (command, target, html) {
      var $target = $(target);
      $target.html($target.html() + html);
    },
    // Prepends the provided html to the provided target
    prepend: function (command, target, html) {
      var $target = $(target);
      $target.html(html + $target.html());
    },
    // Updates the page state under the provided model with the provided
    // data
    state: function (command, model, data) {
      state.state(model, data);
    },
    // Executes the provided script under the global context of the page
    script: function (command, code) {
      eval(code); // jshint ignore:line
    },
    // Trigger an AUI event of type eventName with any additional arguments
    trigger: function(command, eventName) {
      var context, args;
      args = Array.prototype.slice.call(arguments, 1);
      events.trigger.apply(context, args);
    }
  };

  function handleChunk(chunk, customActionHandler) {
    if (!chunk || chunk.length === 0) {
      return;
    }

    // Check to see if we have a whitespace string that was not passed through util.parseJSON()
    if (typeof chunk === "string" && util.trim(chunk) === "") {
      if (customActionHandler) {
        customActionHandler(chunk);
      }
      return;
    }

    // Check to see if we have a list of commands
    if (!(chunk[0] instanceof Array)) {
      chunk = [chunk];
    }

    util.each(chunk, function (args) {
      var action = responseActions[args[0]];

      // For commands we don't know about, fallback to the custom chunk handler
      if (action) {
        action.apply(window, args);
        return;
      }

      action = customActionHandler;

      //If we still don't have a handler for the command, let's fail
      if (!action) {
        P.error('There is no handler for the streaming ajax command: ' + chunk[0], 'A.ajax', 'chunkHandler');
      }

      action(args);
    });
  }

  var declarativeActions = {
    // Updates one or more targets provided by the server on click with the
    // contents of the provided ajax url
    'a-ajax-update': function (options) {
      var ajax = new Ajax();

      var tagCSM = function () {
        var ue = window.ue;
        if (ue && ue.tag) {
          ue.tag(AUI_TAG);
          ue.tag(AUI_AJAX_TAG);
        }
      };

      var chunkHandler = function (chunk) {
        tagCSM();
        handleChunk(chunk, options.chunk);
      };

      var abortHandler = options.abort;

      // Show the working indicator
      var $indicator = $(options.indicator);
      var needsAOKClass = $indicator.hasClass(AOK_HIDDEN_CLASS);
      $indicator.removeClass(AOK_HIDDEN_CLASS).show();

      var callbackHandler = function(callback, args) {
        $indicator.hide();

        if (needsAOKClass) {
          $indicator.addClass(AOK_HIDDEN_CLASS);
        }

        tagCSM();

        if (callback) {
          callback.apply(window, args);
        }
      };

      // can't use function binding for these handlers because of IE8 :(
      var successHandler = function() {
        callbackHandler(options.success, arguments);
      };

      var failureHandler = function() {
        callbackHandler(options.failure, arguments);
      };

      var method = typeof options.method === 'string' && options.method.toLowerCase() === 'post' ? 'post' : 'get';

      // Disable browser cache by appending timestamp into GET calls
      if (method === "get" && options.cache === false) {
        options.params += [options.params === '' ? '' : '&', '_=', util.now()].join('');
      }

      return ajax[method](options.url, options.params, options.timeout, chunkHandler, successHandler, failureHandler, abortHandler, options.headers, options.withCredentials);
    }
  };

  function handleEvent(event) {
    var $target = event.$target;
    var action = event.action;
    var eventProps = event.data;

    // If no config properties are included, we should only act on the default
    // event for the targeted element --> <a data-action=update>
    if (!eventProps && events.events.defaults[event.targetTag] !== event.type) {
      return;
    }

    // Handle the object case where events with options are specified
    if (typeof eventProps === 'object' && !eventProps[event.type]) {
      return;
    }

    eventProps = eventProps || {};
    var url = eventProps.url || $target.attr('href') || $target.attr('action');
    var params = serializeParams(eventProps.params, eventProps.paramsFormat);
    var method = $target.attr('method') || eventProps.method;
    var indicator = eventProps.indicator;
    var timeout = eventProps.timeout;

    // If we don't have a URL or cached data, nothing to do
    if (!url) {
      P.error('No ajax url provided.', 'A.ajax', 'declarativeHandler');
    }

    // If we have a form submission, let's serialize the input elements as parameters
    if (event.targetTag === 'form' && event.type === events.events.defaults.form) {
      var formParams = $target.serialize();
      params += formParams;
    }

    // Prevent form submissions or clicks
    event.$event.preventDefault();

    // Do this thang
    return declarativeActions[action]({
      url: url,
      params: params,
      method: method,
      indicator: indicator,
      operation: action,
      timeout: timeout
    });
  }

  // Register declarative API bindings
  declarative.declarative('a-ajax-update', handleEvent);



  /**
   *  Construct a new Ajax request object which will send an XMLHttpRequest to the
   *  given URL.
   *
   *  @public
   *  @param {string} url
   *  @param {object} options
   *
   *  @return {Ajax}
   */
  var ajax = function ajax(url, options) {
    options = options || {};

    // Normalize the request headers with the convenience "accepts" and "contentType"
    // options taking precidence over equivalent entries on the headers hash.
    var headers = options.headers || {};
    if (options.accepts !== undefined) {
      headers.Accept = options.accepts;
    }
    if (options.contentType !== undefined) {
      headers["Content-Type"] = options.contentType;
    }

    var params = serializeParams(options.params, options.paramsFormat);

    return declarativeActions['a-ajax-update'](guard.obj(this, {
      url: url,
      cache: options.cache,
      params: params,
      method: options.method,
      chunk: options.chunk,
      success: options.success,
      failure: options.failure || options.error,
      abort: options.abort,
      indicator: options.indicator,
      timeout: options.timeout,
      headers: headers,
      withCredentials: !! options.withCredentials
    }));
  };

  return {
    ajax: ajax,

    /**
     *  Convenience method for creating a GET request.
     *
     *  @public
     *  @param {string} url
     *  @param {object} options
     *
     *  @return {Ajax}
     */
    get: function get(url, options) {
      options = options || {};
      options.method = 'get';
      return ajax.call(this, url, options);
    },

    /**
     *  Convenience method for creating a POST request.
     *
     *  @public
     *  @param {string} url
     *  @param {object} options
     *
     *  @return {Ajax}
     */
    post: function post(url, options) {
      options = options || {};
      options.method = 'post';
      return ajax.call(this, url, options);
    }
  };
});
/////////////////////////
// END FILE a_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_animate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Animations
 *
 */

"use strict";

/**
 *  An animation library which will use CSS3 animations when possible, but fall back to jQuery if
 *  the browser doesn't support that.
 */
P.when("a-util", "p-detect", "a-prefix").register("a-animate", function (util, detect, prefix) {

  /**
   *  Default timeslice delay for executing animation function
   *  @private
   *  @type {number}
   *  @constant
   */
  var ANIMATE_DELAY = 4;

  /**
   *  Default animation duration
   *  @private
   *  @type {number}
   *  @constant
   */
  var DEFAULT_TIME = 250;

  /**
   *  Default easing type for transitions
   *  @private
   *  @type {string}
   *  @constant
   */
  var DEFAULT_EASING = "linear";

  /**
   *  A set of CSS properties which we are certain can be hardware accelerated.
   *  @private
   *  @type {array}
   *  @constant
   */
  var GPU_PROPERTIES = ["top", "left", "scale"];

  /**
   *  CSS rules often have vendor prefixes, especially for CSS3 rules.
   *  This function will take the CSS rule name and the desired value and
   *  applies all vendor prefixed versions of the rule paired up with the value.
   *
   *  @private
   *  @param {DOM Node} $target  The DOM node where the rule will be applied
   *  @param {string} rule  The CSS rule to apply.
   *  @param {object} value  The value of the CSS rule
   */

  function prefixedCSS($target, rule, value) {
    var node = $target.jquery ? $target[0] : $target;
    rule = prefix.prefixes.getStyle(rule);
    node.style[rule] = value;
  }

  /**
   *  Generate the CSS rule to translate the top and left property as well as
   *  scale the target.  If the browser supports translate3d, set the translate
   *  Z properties as well to prevent bugs.
   *
   *  @private
   *  @param {properties} props  The properties which should be in the rule
   *
   *  @return {string} The transform CSS rule to change the properties
   */

  function translateScale(props) {
    var translateString = "";
    var transform3d = detect.capabilities.transform3d; // Alias for minimization

    // If both x and y coords are available, use the shortcut
    if (props.top !== undefined && props.left !== undefined) {
      translateString = "translate";
      if (transform3d) {
        translateString += "3d";
      }
      translateString += "(" + props.left + ", " + props.top;
      if (transform3d) {
        translateString += ", 0";
      }
      translateString += ")";
    } else {
      // If only x or y are available, translate them individually
      if (props.top !== undefined) {
        translateString = "translateY(" + props.top + ")";
      } else if (props.left !== undefined) {
        translateString = "translateX(" + props.left + ")";
      }
      if (transform3d) {
        translateString += " translateZ(0)";
      }
    }

    // Add in the scale if desired
    if (props.scale !== undefined) {
      translateString += " scale(" + props.scale + ")";
    }

    return translateString;
  }

  /**
   *  Given a set of CSS properties, pull out and return the properties
   *  which can be animated using hardware acceleration.
   *
   *  @private
   *  @param {array} props  The list of properties
   *
   *  @return {object}  The GPU enabled properties or null if none are present
   */

  function gpuProperties(props) {
    var gpu = {};
    var hasGPUProps = false;

    util.each(GPU_PROPERTIES, function (prop) {
      if (prop in props) {
        hasGPUProps = true;
        gpu[prop] = props[prop];
        delete props[prop];
      }
    });

    return hasGPUProps ? gpu : null;
  }

  /**
   *  CSS 3 transforms take a value relative to the current value of top and left.
   *  Transitions just take an absolute value.  We're assuming that the user is
   *  passing in an absolute value to maintain compatibility with jQuery's API.
   *  So, if we're using a CSS 3 transform, we may have to mutate the top/left property.
   *  If we're using a transition and the user passed in a number, we'll need to append "px".
   *
   *  @private
   *  @param {object} $dom   The jQuery wrapped DOM node which is being animated
   *  @param {string} name   The name of the property being normalized (ex: top)
   *  @param {string|number} value  The value passed in by the user.  Could be a string or a number.
   *
   *  @return {string}  The new value of the property ready to be used in the animation.
   */

  function normalizeProp($dom, name, value) {
    if (detect.capabilities.transform) {
      if (typeof value === "string") {
        value = parseInt(value, 10);
      }
      if (!util.isFiniteNumber(value)) {
        value = 0;
      }

      var current = parseInt($dom.css(name), 10);
      if (!util.isFiniteNumber(current)) {
        current = 0;
      }
      value -= current;
      value += "px";
    } else if (util.isFiniteNumber(value)) {
      value += "px";
    }
    return value;
  }

  /**
   *  JS versions of the animation API.  Right now, we delegate to jQuery.
   */
  var js = {
    animate: function ($target, properties, time, easing, callback) { // jshint ignore:line
      if (!$target._a) {
        $target._a = 0;
      }
      $target._a++;
      var onComplete = function () {
        $target._a--;
        if (callback) {
          callback();
        }
      };
      $target.queue("fx", [
        function () {
          $target.animate(properties, {
            duration: time,
            easing: easing === "linear" ? easing : "swing",
            complete: onComplete,
            queue: false
          });
        }
      ]);
    },
    fadeIn: function ($target, time, easing, callback) {
      // if aok-hidden or a-hidden class is present,
      // replace it with display:none
      if ($target.hasClass('aok-hidden') || $target.hasClass('a-hidden')) {
        $target.css('display', 'none').removeClass('aok-hidden a-hidden');
      }

      // stop the currently running animation if any before starting this animation
      this.stopAnimation($target, true, true);

      $target.fadeIn({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: callback,
        queue: false
      });
    },

    fadeOut: function ($target, time, easing, callback) {
      // stop the currently running animation if any before starting this animation
      this.stopAnimation($target, true, true);

      // Record original opacity for IE
      // fadeOut will set the opacity back to its original opacity after animation
      var origOpacity = $target.css('opacity');
      $target.fadeOut({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: function () {
          $target.css("opacity", origOpacity);

          if (callback) {
            callback();
          }
        },
        queue: false
      });
    },
    fadeToggle: function ($target, time, easing, callback) {
      $target.fadeToggle({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: callback,
        queue: false
      });
    },
    slideUp: function ($target, time, easing, callback) {
      $target.slideUp({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: callback,
        queue: false
      });
    },
    slideDown: function ($target, time, easing, callback) {
      $target.slideDown({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: callback,
        queue: false
      });
    },
    slideToggle: function ($target, time, easing, callback) {
      $target.slideToggle({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: callback,
        queue: false
      });
    },
    isAnimated: function ($target) {
      var node = $target.jquery ? $target[0] : $target;
      return node._a && node._a > 0;
    },
    stopAnimation: function ($target, clearQueue, jumpToEnd) {
      $target.stop(clearQueue, jumpToEnd);
    }
  };

  /**
   *  CSS3 enabled versions of the animation library API
   */
  var css3 = {
    animate: function ($target, properties, time, easing, callback) { // jshint ignore:line
      // If there are no elements, dont do anything
      if (!$target || !$target.length) {
        return;
      }

      var gpuProps;
      var target = $target[0];
      properties = util.copy(properties); // The gpuProps function can be destructive.  Make a copy to be safe.
      time = time === undefined ? DEFAULT_TIME : time;
      easing = easing || DEFAULT_EASING;

      // CSS 3 transforms are relative to the current top and left while translate is an absolute setter.
      // Normalize
      if (properties.top !== undefined) {
        properties.top = normalizeProp($target, "top", properties.top);
      }
      if (properties.left !== undefined) {
        properties.left = normalizeProp($target, "left", properties.left);
      }

      prefixedCSS($target, "transition", time < ANIMATE_DELAY ? "all 0ms" : "all " + time + "ms " + easing);

      // Increment counter for the number of running animations and queue up an end action
      if (time > ANIMATE_DELAY) {
        // Keep track of the number of running animations
        if (target._a === undefined) {
          target._a = 0;
        }
        target._a++;

        var onComplete = function () {
          if (target._a > 0) {
            target._a--;
          }

          if (!target._a) {
            prefixedCSS($target, "transition", "");
          }

          $target
                .removeData('aAnimateTimeoutId')
                .removeData('aAnimateOnComplete');

          if (callback) {
            callback();
          }
        };

        $target
            .data('aAnimateOnComplete', onComplete)
            .data('aAnimateTimeoutId', util.delay(onComplete, time));
      } else {
      // If no animation is happening, we need to execute callbacks now
        if (callback) {
          util.delay(callback, 0);
        }
      }


      // Use the GPU for top, left, and scale, if possible
      if (detect.capabilities.transform) {
        gpuProps = gpuProperties(properties);

        if (gpuProps) {
          prefixedCSS($target, "transform", translateScale({
            top: gpuProps.top,
            left: gpuProps.left,
            scale: gpuProps.scale
          }));
        }
      }

      // Calling .css with an empty properties object causes some issue in some Android stock browsers, so don't do that.
      if (!util.objectIsEmpty(properties)) {
        $target.css(properties);
      }
    },
    fadeIn: function ($target, time, easing, callback) {
      // Fade in animation goes from 0 to X where X is the targetOpacity

      // stop the currently running animation if any before starting this animation
      this.stopAnimation($target, true, true);

      // if aTargetOpacity is defined, then the base animation has already set
      // the intial value and this should be treated as the target opacity under
      // all circumstances.
      // if aTargetOpacity is not set, then this is the base animation and is
      // responsible for setting the target opacity
      // This behavior was implied earlier.
      // However it caused the element to disappear when fadeIn/fadeOut animations were stacked
      var targetOpacity;
      if ($target.data("aTargetOpacity") === undefined) {
        targetOpacity = $target.css("opacity") || 1;
        $target.data("aTargetOpacity", targetOpacity);
      } else {
        targetOpacity = $target.data("aTargetOpacity");
      }

      $target.css("opacity", "0").removeClass('a-hidden aok-hidden').show();

      util.reflowCssChanges($target);

      var onComplete = function() {
        $target.show();
        if (callback) {
          callback();
        }
      };

      this.animate($target, {
        opacity: targetOpacity
      }, time, easing, onComplete);
    },
    fadeOut: function ($target, time, easing, callback) {
      // Fade out animation goes from X to 0 where X is the initialOpacity

      // stop the currently running animation if any before starting this animation
      this.stopAnimation($target, true, true);

      // fadeOut will set the opacity back to its original opacity after animation and hide the element
      // using jQuery hide()
      var origOpacity = $target.css('opacity');

      // if aTargetOpacity is not set, then this is the base animation and is
      // responsible for setting the target opacity which shall be used in for
      // subsequent fadeIn/fadeOut calls
      if ($target.data("aTargetOpacity") === undefined) {
        $target.data("aTargetOpacity", origOpacity);
      }

      var onComplete = function() {
        $target.hide().css("opacity", origOpacity);
        if (callback) {
          callback();
        }
      };
      this.animate($target, {
        opacity: 0
      }, time, easing, onComplete);
    },
    fadeToggle: function ($target, time, easing, callback) {
      var fade = ($target.css("display") === "none" || +$target.css("opacity") < 0.05) ? this.fadeIn : this.fadeOut;
      fade.call(this, $target, time, easing, callback);
    },
    slideUp: function ($target, time, easing, callback) {
      var animate = this.animate;
      $target.css({
        "height": $target.innerHeight(),
        "overflow": "hidden"
      });

      // Very small timeout for DOM changes to reflect before adding animation
      util.delay(function () {
        animate($target, {
          height: 0
        }, time, easing, function () {
          $target.hide();
          $target.css({
            "height": "",
            "overflow": ""
          });

          if (callback) {
            callback();
          }
        });
      }, 0);
    },
    slideDown: function ($target, time, easing, callback) {
      var targetHeight = $target.innerHeight(),
        animate = this.animate;

      $target.css({
        "height": 0,
        "overflow": "hidden"
      });

      $target.show();
      // Very small timeout for DOM changes to reflect before adding animation
      util.delay(function () {
        animate($target, {
          height: targetHeight
        }, time, easing, function () {
          if (callback) {
            callback();
          }

          $target.css({
            "height": "",
            "overflow": ""
          });
        });
      }, 0);
    },
    slideToggle: function ($target, time, easing, callback) {
      var slide = $target.is(":visible") ? this.slideUp : this.slideDown;
      slide.call(this, $target, time, easing, callback);
    },
    isAnimated: function ($target) {
      var node = $target.jquery ? $target[0] : $target;
      return node._a && node._a > 0;
    },
    stopAnimation: function ($target, clearQueue, jumpToEnd) {
      // If there are no elements, dont do anything
      if (!$target || !$target.length) {
        return;
      }

      // currently css transitions are always going to be jumpToEnd as
      // there is no way to stop the transition threads fired
      var target = $target[0];
      prefixedCSS($target, "transition",  "all " + (jumpToEnd ? "1" : "0") + "ms");
      if (clearQueue) {
        target._a = 0;
      }
      util.reflowCssChanges($target);

      // execute the callbacks
      clearTimeout($target.data('aAnimateTimeoutId'));
      if ($target.data('aAnimateOnComplete')) {
        $target.data('aAnimateOnComplete')();
      }
    }
  };

  /**
   *  Only return the CSS3 version if we're reasonably certain that hardware acceleration exists.
   */
  return detect.capabilities.transition ? css3 : js;
});
/////////////////////////
// END FILE a_animate.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image_lazy_loader.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Lazy-loads images that are on screen or within 500px of being on screen.
 * 
 * A check to see if any images need to be loaded occurs when:
 *   - the page first loads
 *   - the user scrolls
 *   - the user stops scrolling
 *   - the user resizes the window
 * 
 * We also leverage an image attribute cache in order to avoid rechecking
 * the image offset and height when the user is scrolling (causing jank).
 * This cache is updated when:
 *   - the page first loads
 *   - the user stops scrolling (also triggers a lazy load check)
 *   - an image is finished lazy loading
 */

P.when('A', 'jQuery').register('a-image-lazy-loader', function (A, $) {
  var LAZY_LOAD_THRESHOLD = 500;
  
  var scrollTimer;

  // store of an image's offset and height
  var imageAttributeCache = (function() {
    var cache = {};
    var counter = 0;

    function get($image) {
      return cache[$image.data('cacheKey')];
    }

    function set($image) {
      if (!$image.data('cacheKey')) {
        $image.data('cacheKey', counter);
        counter++;
      }

      cache[$image.data('cacheKey')] = {'top' : $image.offset().top, 'height' : $image.height()};
    }

    function remove($image) {
      if ($image.data('cacheKey')) {
        delete cache[$image.data('cacheKey')];
      }
    }

    return {
      get : get,
      set : set,
      remove : remove
    };
  })();

  function populateCache() {
    $('.a-lazy-loaded').each(function() {
      imageAttributeCache.set($(this));
    });
  }

  // checks if a lazy load image is on or close to being on screen
  // if so, swap the src to download the image
  function lazyLoad() {
    var $imagesToLoad = [];

    $('.a-lazy-loaded').each(function() {
      var $image = $(this);
      
      // if the image has a src and is 500 pixels away from being in view, load it
      if ($image.data('src') && onScreen($image)) {

        // bind to image 'load' event, indicating image has finished loading
        $image.load(function() {
          // trigger callback so clients know when image is available
          A.trigger('a:image:lazyLoaded', $image);
          // repopulate the cache as offsets may have changed
          populateCache();
        });

        $imagesToLoad.push($image);

        // remove a-lazy-loaded class so we don't try to load again
        $image.removeClass('a-lazy-loaded');

        // remove from the cache, we don't need it
        imageAttributeCache.remove($image);
      }
    });

    A.each($imagesToLoad, function($image) {
      $image.attr('src', $image.data('src'));
    });
  }

  // returns true if the image is on screen, or within LAZY_LOAD_THRESHOLD pixels of being on screen
  function onScreen($image) {
    if (!imageAttributeCache.get($image)) {
      imageAttributeCache.set($image);
    }

    var $window = $(window);
    var windowTop = $window.scrollTop();
    var windowHeight = window.innerHeight ? window.innerHeight : $window.height();
    var windowBottom = windowTop + windowHeight + LAZY_LOAD_THRESHOLD;
    windowTop -= LAZY_LOAD_THRESHOLD;

    var imageAttributes = imageAttributeCache.get($image);
    var top = imageAttributes.top;
    var height = imageAttributes.height;
    var bottom = top + height;

    // return true if any of the following are true:
    //   - top of image is visible in the window
    //   - bottom of image is visible in the window
    //   - height of image is greater than window size, and top/bottom of image are beyond the window's top/bottom
    return (top >= windowTop && top < windowBottom) ||
           (bottom > windowTop && bottom <= windowBottom) ||
           (height > windowHeight && top <= windowTop && bottom >= windowBottom);
  }

  // try to lazy load as early as possible
  populateCache();
  lazyLoad();

  // lazy load on scroll
  A.on("scroll", function() {
    lazyLoad();
  });

  A.on("scroll", A.debounce(function() {
    // if we've stopped scrolling, repopulate our image attribute cache
    populateCache();
    lazyLoad();
  }, 250));

  // lazy load on resize
  A.on("resize", lazyLoad);

  // supply a trigger mechanism for clients, in case of ajaxed in images (etc)
  A.on("a:image:lazyLoad", lazyLoad);

  // load on dom ready, in case images were parsed after initial JS execution
  A.on.ready(lazyLoad);

});
/////////////////////////
// END FILE a_image_lazy_loader.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image_url_key_handler.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// no-op image url key handler for use in AUI_72554:C
// The url key is simply the url.

'use strict';

P.register('a-image-url-key-handler', function() {

  /**
   * Generate a key for url and crossOrigin value
   *
   * @param {string} url
   * @param {string} crossOrigin
   *
   * @return {string} generated composite key
   */
  function generate(url, crossOrigin) {
    return url;
  }

  /**
   * Parse composite key into respective parts for url and crossOrigin value
   *
   * @param {string} composite key
   *
   * @return {object} decomposed key parts
   */
  function parse(key) {
    return {
      url : key
    };
  }

  return {
    generate : generate,
    parse : parse
  };

});
/////////////////////////
// END FILE a_image_url_key_handler.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Hi-Res Image Replacement

'use strict';

P.when('jQuery', 'a-util', 'a-events', 'a-defer', 'p-detect', 'a-image-url-key-handler').register('a-image', function ($, util, events, defer, detect, urlKeyHandler) { // jshint ignore:line
  //Images as live node list
  var images = document.getElementsByTagName('img');
  //Url -> list of image elements map
  var imageElements = {};

  //Download throttle; throttleInFlight is the current number of active image downloads, up to THROTTLE_LIMIT
  var throttleInFlight = 0;
  var THROTTLE_LIMIT = 2;

  //Loading queue
  var queue = (function () {
    var urlKeyQueue = [];
    var urlKeyQueueSet = {};

    function schedule(url, $image) {
      var urlKey = urlKeyHandler.generate(url, $image.attr('crossorigin'));

      if (!urlKeyQueueSet[urlKey]) {
        urlKeyQueue.push(urlKey);
        urlKeyQueueSet[urlKey] = true;
      }

      imageElements[urlKey] = imageElements[urlKey] || [];

      //Prevent the queue from filling with dups
      for (var i = 0; i < imageElements[urlKey].length; i++) {
        if ($image.is(imageElements[urlKey][i])) {
          return;
        }
      }

      imageElements[urlKey].push($image);
    }

    function fill() {
      for (var i = 0; i < THROTTLE_LIMIT - throttleInFlight; i++) {
        if (urlKeyQueue.length > 0) {
          var urlKey = urlKeyQueue.shift();
          urlKeyQueueSet[urlKey] = false;
          image.load(urlKey);
        }
      }
    }

    return {
      schedule: schedule,
      fill: fill
    };
  }());

  //Image functions
  // FIXME remove JSHint exception
  var image = (function () { // jshint ignore:line
    var alreadyLoaded = {};
    var IMAGE_REPLACEMENT_KEY = 'a-image-replaced';
    var IMAGE_REPLACEMENT_EVENT = 'a:image:load';

    //Do the replacement

    function replace(urlKey) {
      var elements = imageElements[urlKey];
      var url = urlKeyHandler.parse(urlKey).url;

      if (!elements) {
        return;
      }

      util.each(elements, function($element) {
        /*
          This ensures that if replacement for the same image is queued twice,
          (most notably due to explicit calls to A.loadDynamicImage) the replacement
          happens only once. It allows replacement again, only if the URL is different,
          due to resize or orientation change events that lead to a new URL being selected.
        */
        if($element.data(IMAGE_REPLACEMENT_KEY) !== url) {
          $element.data(IMAGE_REPLACEMENT_KEY, url);

          defer.defer(function () {
            $element.attr('src', url);
            events.trigger(IMAGE_REPLACEMENT_EVENT, {$imageElement: $element, url: url});
            var imageName = $element.data('a-image-name');
            if(imageName) {
              events.trigger(IMAGE_REPLACEMENT_EVENT+':'+imageName, {$imageElement: $element, url: url});
            }
          });

        }
      });

      //Remove elements from the imageElements queue
      imageElements[urlKey] = [];
    }

    //Loads the image at url

    function load(urlKey) {
      //The image is already loaded, go ahead and replace it
      if (alreadyLoaded[urlKey]) {
        replace(urlKey);
        return;
      }

      //The image failed to load before, let's not try again
      if (alreadyLoaded[urlKey] === false) {
        return;
      }

      var img = new Image();

      img.onload = function () {
        throttleInFlight--;
        replace(urlKey);
        alreadyLoaded[urlKey] = true;
        queue.fill();
      };

      img.onerror = function () {
        throttleInFlight--;
        alreadyLoaded[urlKey] = false;
        queue.fill();
      };

      throttleInFlight++;
      defer.defer(function () {
        var urlKeyParts = urlKeyHandler.parse(urlKey);
        var crossOrigin = urlKeyParts.crossOrigin;
        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }
        img.src = urlKeyParts.url;
      });
    }

    //Polls images

    function poll() {
      //Early return if the page isn't visible
      if (util.isPageHidden()) {
        return;
      }

      util.each(images, function (image) {
        var $image = $(image);

        // Inexpensive early return checks
        if (!$image.data('a-hires') || $image.data('a-hires-loaded') || $image.data('a-manual-replacement')) {
          return;
        }

        // Expensive early return checks
        if ($image.is(':hidden') || !util.onScreen($image)) {
          return;
        }

        // Schedule the image for loading
        queue.schedule($image.data('a-hires'), $image);
        $image.data('a-hires-loaded', true);
      });
    }

    return {
      load: load,
      poll: poll
    };
  }());

  //Replace images with scaled 2x size on hi-dpi screens
  if (detect.capabilities.hires) {
    events.on.ready(function () {
      util.interval(function () {
        image.poll();
        queue.fill();
      }, 2000);
    });
  }

  //Load dynamically sized images

  function loadDynamicImage(image) {
    var $image = $(image);
    var sizes = $image.data('a-dynamic-image');

    if (!sizes || typeof sizes !== 'object') {
      return;
    }

    //Allow optional use of a parent element marked as the size container
    var $container = $image.data('a-dynamic-image-container');

    if (typeof $container === 'undefined') {
      $container = $image.closest('.a-dynamic-image-container');

      if ($container.length === 0) {
        $container = $image.parent();
      }

      $image.data('a-dynamic-image-container', $container);
    }

    var pixelRatio = detect.capabilities.hires && window.devicePixelRatio ? window.devicePixelRatio : 1;
    var width = $container.width() * pixelRatio;
    var height = $container.height() * pixelRatio;
    var closestSizeDiff = Number.MAX_VALUE;
    var closestLargerSizeDiff = Number.MAX_VALUE;
    var closestUrl = $image.attr('src') || '';
    var closestLargerUrl;
    var aspectRatio = width / height;

    //Check all the image sizes
    util.each(sizes, function (size, url) {
      var proposedHeight = parseInt(size[0], 10);
      var proposedWidth = parseInt(size[1], 10);
      var heightDiff = proposedHeight - height;
      var widthDiff = proposedWidth - width;

      var sizeDiff = aspectRatio >= 1 ? widthDiff : heightDiff;

      //Keep track of the closest image that is larger
      if (Math.abs(sizeDiff) < closestLargerSizeDiff && sizeDiff >= 0) {
        closestLargerSizeDiff = Math.abs(sizeDiff);
        closestLargerUrl = url;
      }

      //Keep track of the closest image
      if (Math.abs(sizeDiff) < closestSizeDiff) {
        closestSizeDiff = Math.abs(sizeDiff);
        closestUrl = url;
      }
    });

    //If there is an image that is larger than the current container, take it.
    //Otherwise, fall back to the closest sized image
    if (closestLargerUrl) {
      closestUrl = closestLargerUrl;
    }

    //Load the appropriate image
    queue.schedule(closestUrl, $image);
    queue.fill();

    return closestUrl;
  }

  function selectDynamicImages() {
    var $dynamicImages = $('img.a-dynamic-image');

    $dynamicImages.each(function () {
      var $t = $(this);
      if (!$t.data('a-manual-replacement')) {
        loadDynamicImage(this);
      }
    });
  }

  events.on.ready(selectDynamicImages);
  $(window).resize(selectDynamicImages);

  return {
    loadHiResImage: function (images) {
      var $images = $(images);
      var urls = [];

      $images.each(function () {
        var $image = $(this);
        var hiResUrl = $image.data('a-hires');

        if (hiResUrl) {
          queue.schedule(hiResUrl, $image);
          queue.fill();
          urls.push(hiResUrl);
        }

        $image.data('a-hires-loaded', true);
      });

      return urls;
    },
    loadDynamicImage: function (images) {
      var $images = $(images);
      var urls = [];

      $images.each(function () {
        urls.push(loadDynamicImage(this));
      });

      return urls;
    },
    // Switch any images flagged as "manually loaded" into a visible state
    loadImageManually: function (images, ctx) {
      var urls = [];

      $(images, ctx).each(function () {
        var $t = $(this);
        if (!$t.data("a-image-already-loaded")) {
          $t.data("a-image-already-loaded", true);
          var dynamicUrl = loadDynamicImage($t);
          var $img = $("<img>").attr("src", dynamicUrl || $t.data("a-image-source"));

          urls.push(dynamicUrl);

          //Copy classes
          var classes = "" + this.className;
          var extraClasses = $t.data("a-extra-classes");
          if (extraClasses) {
            classes += " " + extraClasses;
          }
          $img.attr('class', classes);

          //Copy other attributes
          $img.attr("id", this.id);
          $img.attr("style", $t.attr("style"));
          $img.attr("alt", $t.attr("alt"));
          $img.attr("usemap", $t.attr("usemap"));
          $img.attr("title", $t.attr("title"));
          $img.attr("role", $t.attr("role"));

          //Copy cross origin attribute
          var crossOrigin = $t.data("a-image-crossorigin");
          if (crossOrigin) {
            $img.attr("crossorigin", crossOrigin);
          }

          // Preserve data attributes
          util.each(this.attributes, function (attr) {
            if (attr && attr.name && (attr.name.indexOf("data-") === 0 || attr.name.indexOf("aria-") === 0)) {
              $img.attr(attr.name, attr.value);
            }
          });

          // Copy over jQuery's internal data hash
          $img.data($t.data());

          // Add the image + remove the wrapper div
          $t.replaceWith($img);
        }

        return urls;
      });
    },
    loadDescendantImagesManually: function (imagesRoot, ctx) {
      var images = $(imagesRoot, ctx).find("div.a-manually-loaded").filter(function () {
        return !$(this).data("a-image-already-loaded");
      });

      return this.loadImageManually(images);
    }
  };
});
/////////////////////////
// END FILE a_image.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_class.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/*
 * Class object for simple inheritance.  Modified version of Simple JavaScript Inheritance by John Resig.
 *
 * Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
P.register('a-class', function() {
    "use strict";

    // ignore jshint error about undefined xyz
    /*global xyz:true */
    var fnTest = /xyz/.test(function () {
        xyz; // jshint ignore:line
    }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    function BaseClass() {
    }

    // Create a new Class that inherits from this class
    BaseClass.extend = function (props) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        var proto = (!!Object.create) ? Object.create(_super) : (function(o) {
            function F() {}
            F.prototype = o;
            return new F();
        }(_super));

        // Copy the properties over onto the new prototype
        // ignore jshint error about for in loops
        /*jshint forin:false */
        for (var name in props) {
            // Check if we're overwriting an existing function
            proto[name] = typeof props[name] === "function" &&
                typeof _super[name] === "function" && fnTest.test(props[name]) ?

                (function (name, fn) { // jshint ignore:line
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                }(name, props[name])) :
                    props[name];
        }

        // The constructor will be assigned as follows:
        // proto.init is a function and is a property of proto object itself, not its prototype -> proto.init
        // proto.init is a function and it's on proto's prototype -> new fuction that calls _super.init.apply
        // proto.init is not a function -> empty function
        var newClass = typeof proto.init === "function" ?
            proto.hasOwnProperty('init') ?
                proto.init :// All construction is actually done in the init method
                function SubClass() { _super.init.apply(this, arguments); } :
            function NewClass() {};

        // Populate our constructed prototype object
        newClass.prototype = proto;

        // Enforce the constructor to be what we expect
        proto.constructor = newClass;

        // And make this class extendable
        newClass.extend = BaseClass.extend;

        return newClass;
    };

    return {
        createClass: function(properties) {
            return BaseClass.extend(properties);
        }
    };
});
/////////////////////////
// END FILE a_class.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Useful Constants
 */

"use strict";

P.register("a-constants", function () {
  return {
    constants: {
      keycodes: {
        "BACKSPACE": 8,
        "TAB": 9,
        "ENTER": 13,
        "ESCAPE": 27,
        "SPACE": 32,
        "LEFT_ARROW": 37,
        "UP_ARROW": 38,
        "RIGHT_ARROW": 39,
        "DOWN_ARROW": 40,
        "DELETE": 46,
        "HOME": 36,
        "END": 35
      },
      declarativeEvents: 'blur click dblclick focus focusin focusout mousedown mouseup mouseenter mouseleave mousemove change submit ' +
        'touchstart touchend touchmove touchcancel keydown keyup keypress MSPointerDown pointerdown MSPointerUp pointerup ' +
        'MSPointerMove pointermove MSPointerCancel pointercancel MSPointerOver pointerenter MSPointerOut pointerleave',
      HIDE_CLASS: 'aok-hidden',
      BROWSER_EVENTS: {
            SCROLL: 'scroll',
            RESIZE: 'resize',
            ORIENTATION_CHANGE: 'orientationChange'
      },
      // when a new pagestate namespace is registered, P.declare related module to notify the namespace is ready.
      // the name used at P.declare is "page-state-loaded:" + namespace
      PAGESTATE_LOADED_MODULE_PREFIX: 'page-state-loaded:',
      NOOP: function () {}
    }
  };
});
/////////////////////////
// END FILE a_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_browser_events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Browser Event Bindings
 */

"use strict";

/**
 *  Creates A.events for standard window events (scroll, resize, orientationchange) which are throttled to prevent
 *  a bad UX.  Also exposes an A.viewport() method which returns window dimension properties which are automatically
 *  updated on those events.
 */
P.when("jQuery", "a-detect", "a-events", "a-util", "a-defer").register("a-browser-events", function ($, detect, events, util, defer) { // jshint ignore:line
  var $window = $(window);

  /**
   *  A hash of constants for event name strings.
   *
   *  @private
   *  @constant
   *  @type{object}
   */
  var EVENT_NAMES = {
    ORIENTATION_CHANGE: "orientationchange",
    SCROLL: "scroll",
    RESIZE: "resize",
    ZOOM: "zoom",
    ALL: "all"
  };


  // ***************************** VIEWPORT MEASUREMENT AND MEMOIZATION ***************************** //


  /**
   *  Convenience method for determining device orientation, event when not supported by the browser.
   *
   *  @private
   *  @return {number} orientation
   */

  function getOrientation() {
    return window.orientation === undefined ? getWindowWidth() > getWindowHeight() ? 90 : 0 : window.orientation;
  }

  /**
   *  Get the window's height in the most accurate/efficient manner available.
   *
   *  @private
   *  @return {number}
   */

  function getWindowHeight() {
    return window.innerHeight ? window.innerHeight : document.documentElement.clientHeight;
  }

  /**
   *  Get the window's width in the most accurate/efficient manner available.
   *
   *  @private
   *  @return {number}
   */

  function getWindowWidth() {
    return window.innerWidth ? window.innerWidth : document.documentElement.clientWidth;
  }

  /**
   *  Get the vertical scroll position of the window.
   *
   *  @private
   *  @return {number}
   */

  function getWindowScrollY() {
    return window.scrollY ? window.scrollY : $window.scrollTop();
  }

  /**
   *  Get the horizontal scroll position of the window.
   *
   *  @private
   *  @return {number}
   */

  function getWindowScrollX() {
    return window.scrollX ? window.scrollX : $window.scrollLeft();
  }

  /**
   *  Get the height of the page
   *
   *  @private
   *  @return {number}
   */

  function getScrollHeight() {
    return document && document.body && document.body.scrollHeight ? document.body.scrollHeight : 0;
  }

  /**
   *  Get the browser's zoom ratio. return 1 if browser not supported, eg IE < 9
   *
   *  @private
   *  @return {number}
   */

  function getZoomRatio() {
    return window.innerWidth ? Math.round(document.documentElement.clientWidth / window.innerWidth * 10) / 10 : 1;
  }

  /**
   *  This is a hash of commonly needed window properties.  It's set on each fired resize, scroll,
   *  and orientationchange event and has a public getter.
   *
   *  @private
   *  @type {object}
   */
  var viewport = {
    scrollLeft: 0,
    scrollTop: 0,
    height: getWindowHeight(),
    width: getWindowWidth(),
    orientation: getOrientation(),
    zoom: getZoomRatio()
  };

  /**
   *  Public getter for the window properties hash.
   *
   *  @public
   *  @param {boolean} forceRefresh  get new viewport data
   *
   *  @return {object} viewport
   */

  function getViewport(forceRefresh) {
    if (forceRefresh) {
      measure(EVENT_NAMES.ALL);
    }
    return util.copy(viewport);
  }

  /**
   *  Sets the properties enumerated in the "properties" parameter off of the window object and caches them onto
   *  a local object and return a hash of the changes.  This will allow for fewer DOM reads on window events.
   *
   *  @private
   *  @param {array} properties  An array of property names to read
   *
   *  @return {object} changed  A hash where the key is the property which changed and the value is the old value of the property
   */

  function getViewportProperties(properties) {
    var changed = {};
    var tmp, property;

    while ((property = properties.pop()) !== undefined) {
      tmp = viewport[property];
      if (property === "orientation") {
        viewport[property] = getOrientation();
      } else if (property === "height") {
        viewport[property] = getWindowHeight();
      } else if (property === "width") {
        viewport[property] = getWindowWidth();
      } else if (property === "scrollTop") {
        viewport[property] = getWindowScrollY();
      } else if (property === "scrollLeft") {
        viewport[property] = getWindowScrollX();
      } else if (property === "zoom") {
        viewport[property] = getZoomRatio();
      }

      if (viewport[property] !== tmp) {
        changed[property] = tmp;
      }
    }

    return changed;
  }

  /**
   *  Caches the viewport properties appropriate for the given event type and returns a hash
   *  of any changes.
   *
   *  @private
   *  @param {string} eventType
   *
   *  @return {object}
   */

  function measure(eventType) {
    var props;

    // Only update the window properties that might have changed
    switch (eventType) {
    case EVENT_NAMES.ALL:
      props = ["orientation", "height", "width", "zoom", "scrollLeft", "scrollTop"];
      break;
    case EVENT_NAMES.SCROLL:
      props = ["scrollLeft", "scrollTop"];
      break;
    case EVENT_NAMES.ZOOM:
      props = ["height", "width", "zoom", "scrollLeft", "scrollTop"];
      break;
    default:
      props = ["orientation", "height", "width", "scrollLeft", "scrollTop"];
    }
    
    return getViewportProperties(props);
  }


  /**
   *  Ensure the window properties hash is up to date after the DOM has loaded.
   */
  events.on("beforeReady", function () {
    measure(EVENT_NAMES.ALL);
  });


  // ***************************** DETERMINE SCROLLBAR WIDTH ************************* //

  /**
   * Gets the page scroll page width by checking the difference between the width
   * when there is/isnt scrollbar
   *
   * @public
   * @param {boolean} force  Whether to force calculation despite no scrollbar on the page
   *
   * @return {number}  Width of the scrollbar
   */

  function getScrollBarWidth(force) {
    //only return a width when the page requires scrolling unless forced
    if (force || getScrollHeight() > getWindowHeight()) {
      // Create a component with oveflow scroll. The component will implicitly take on
      // the size of the browser's scrollbars, allowing us to measure them.
      var scrollDiv = document.createElement("div");
      scrollDiv.style.visibility = "hidden";
      scrollDiv.style.width = "100%";
      scrollDiv.style.overflowX = "scroll";

      document.body.appendChild(scrollDiv);
      var scrollBarWidth = scrollDiv.offsetHeight;
      document.body.removeChild(scrollDiv);
      return scrollBarWidth;
    } else {
      return 0;
    }
  }
  

  // ***************************** MOUSE CURSOR TRACKING ***************************** //


  var MOUSE_THROTTLE_DELAY = 50;
  var MOUSE_RUN_MEAN = 4; // 50 * 4 = 200ms
  var MAX_POLL_COUNT = 30; // 100ms * 30 = 3 seconds

  /**
   *  A hash of commonly cursor related attributes
   *
   *  @private
   *  @type {object}
   */
  var cursor = {
    speed: 0,
    degree: 0, // E:0, NE:45, NW:135, W=180, SE:-45, SW:-135
    direction: "",
    positionX: 0,
    positionY: 0
  };

  /**
   *  Public getter for the cursor hash
   *
   *  @public
   *  @return {object} viewport
   */

  function getCursor() {
    return util.copy(cursor);
  }

  /**
   *  A stack containing historical cursor speed and movement degree
   *
   *  @private
   *  @type {array}
   */
  var cursor_hist = [];

  /**
   *  The most recent cursor position.
   *
   *  @private
   *  @type {object}
   */
  var prev_cursor_pos;

  /**
   *  Updates attributes of the cursor hash, include velocity and direction
   *
   *  @private
   */

  function getCursorAttributes(event) {
    var curr = {
      x: event.clientX,
      y: event.clientY
    };

    if (!prev_cursor_pos) {
      if (curr) {
        prev_cursor_pos = curr;
      }
      return;
    }

    var prev = prev_cursor_pos,
      dist = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)),
      speed = dist / MOUSE_THROTTLE_DELAY * 10,
      degree = Math.atan2(curr.y - prev.y, curr.x - prev.x) / (Math.PI / 180),
      meanSpeed = 0,
      meanDeg = 0,
      direction;

    // Get speed/degree from running means
    cursor_hist.push({
      speed: speed,
      degree: degree
    });
    if (cursor_hist.length > MOUSE_RUN_MEAN) {
      cursor_hist = cursor_hist.slice(-1 * MOUSE_RUN_MEAN);
    }

    var l = cursor_hist.length;
    for (var i = 0; i < l; i++) {
      meanSpeed += cursor_hist[i].speed;
      meanDeg += cursor_hist[i].degree;
    }
    meanSpeed = Number((meanSpeed / l).toFixed(2));
    meanDeg = Math.round(meanDeg / l);

    // Found direction from degree
    if (meanDeg >= 0) {
      if (meanDeg > 157.5) {
        direction = "W";
      } else if (meanDeg > 112.5) {
        direction = "SW";
      } else if (meanDeg > 67.5) {
        direction = "S";
      } else if (meanDeg > 22.5) {
        direction = "SE";
      } else {
        direction = "E";
      }
    } else {
      if (meanDeg < -157.5) {
        direction = "W";
      } else if (meanDeg < -112.5) {
        direction = "NW";
      } else if (meanDeg < -67.5) {
        direction = "N";
      } else if (meanDeg < -22.5) {
        direction = "NE";
      } else {
        direction = "E";
      }
    }

    cursor = {
      speed: meanSpeed,
      degree: meanDeg,
      direction: direction,
      positionX: curr.x,
      positionY: curr.y
    };

    // Put current position as prev after calculation
    prev_cursor_pos = curr;
  }

  $window.bind("mousemove", util.throttle(getCursorAttributes, MOUSE_THROTTLE_DELAY));


  // **************************** NON-MOUSE-SPECIFIC EVENT VARS ***************************** //


  /**
   *  Events which occur in rapid succession are throttled. This is the interval in milliseconds.
   *
   *  @private
   *  @type {number}
   */
  var EVENT_THROTTLE_DELAY = 100;
  

  // ***************************** SCROLL DEBOUNCING ***************************** //


  // Do a simple throttle on the scroll event
  $window.bind(EVENT_NAMES.SCROLL, util.throttle(function () {
    var changed = measure(EVENT_NAMES.SCROLL);
    events.trigger(EVENT_NAMES.SCROLL, viewport, changed);
  }, EVENT_THROTTLE_DELAY));


  // ***************************** BASIC POLLING FUNCTIONALITY ***************************** //


  var eventData = {};
  util.each([EVENT_NAMES.RESIZE, EVENT_NAMES.ZOOM], function (eventName) {
    eventData[eventName] = {
      handler: function () {},
      lastViewport: util.copy(viewport),
      maxPollCount: 5,
      pollCounter: 5,
      pollInterval: 100,
      intervalId: 0
    };
  });

  /**
   *  Resets the countdown of handler calls. If an interval is running, this is called when a
   *  new event comes in and we want to continue polling for a period of time for changes. If
   *  no interval is running, it starts one with settings based on the event type.
   *
   *  This polling is used in lieu of util.throttle() as we are already scheduling a timer and
   *  only acting on the events in defined intervals for a defined period of time and because
   *  simply using throttle can result in missed events.
   *
   *  @private
   *  @param {string} eventName
   */
  function resetPolling(eventName) {
    var event = eventData[eventName];
    if (event) {
      event.pollCounter = event.maxPollCount;
      if (!event.intervalId) {
        event.intervalId = setInterval(event.handler, event.pollInterval);
      }
    }
  }

  /**
   *  Stops an interval that is checking event-related changes to the page if one exists
   *
   *  @private
   *  @param {string} eventName
   */
  function stopPolling(eventName) {
    var event = eventData[eventName];
    if (event && event.intervalId) {
      clearInterval(event.intervalId);
      event.intervalId = 0;
    }
  }


  // ***************************** RESIZE EVENT NORMALIZATION ***************************** //


  /**
   *  Called based on defined polling intervals to determine when changes to the viewport
   *  have occurred. Checks for differences between polls, and based on the differences
   *  detected, triggers the appropriate events
   *
   *  @private
   */
  function normalizeResizeEvent() {
    var publishedEvents = [];
    var resizeEvent = eventData.resize;
    measure("resize");
    var changed = util.diff(viewport, resizeEvent.lastViewport);
    
    if (changed.orientation) {
      publishedEvents.push(EVENT_NAMES.ORIENTATION_CHANGE);
    }
    if (changed.width || changed.height) {
      publishedEvents.push(EVENT_NAMES.RESIZE);
    } else if (detect.capabilities.isIETouchCapable && changed.scrollTop) {
      // When IE Mobile and IE w/ On Screen Keyboard (in Modern UI/Metro) spawn a keyboard
      // They trigger a resize event which is helpful to us, however they then animate and
      // manipulate the scroll position of the page some 300-700ms later (Phone seems to once,
      // but tablet seems to up to 3 times over that time span). As scroll position is integral
      // to the positioning of elements on screen, we dispatch one or more extra resize events
      // so that other code can get all relevant updates to the viewport for positioning.
      publishedEvents.push(EVENT_NAMES.RESIZE);
    }

    if (publishedEvents.length) {
      resizeEvent.lastViewport = util.copy(viewport);
      util.each(publishedEvents, function (eventName) {
        events.trigger(eventName, viewport, changed);
      });
    }
    
    if (--resizeEvent.pollCounter === 0) {
      stopPolling(EVENT_NAMES.RESIZE);
    }
  }

  eventData.resize.handler = normalizeResizeEvent;
  eventData.resize.pollInterval = EVENT_THROTTLE_DELAY;
  eventData.resize.maxPollCount = 10;

  $window.bind(EVENT_NAMES.RESIZE, function (event) {
    resetPolling(EVENT_NAMES.RESIZE);
  });


  // ***************************** ZOOM DETECTION ***************************** //

  /**
   *  Check if the zoom level has change, and fire events accordingly
   *
   *  @private
   */
  function detectZoom() {
    measure(EVENT_NAMES.ZOOM);
    var zoomEvent = eventData.zoom;
    var changed = util.diff(viewport, zoomEvent.lastViewport);

    if (changed.zoom) {
      zoomEvent.lastViewport = util.copy(viewport);
      events.trigger(EVENT_NAMES.ZOOM, viewport, changed);
    }

    if (--zoomEvent.pollCounter === 0) {
      stopPolling(EVENT_NAMES.ZOOM);
    }
  }

  eventData.zoom.handler = detectZoom;
  eventData.zoom.pollInterval = 200;

  // Android: Using two fingers to trigger a touchcancel event, very likely a pinch-zoom
  if (detect.capabilities.android) {
    $window.bind("touchcancel", function (event) {
      if (event.originalEvent.changedTouches.length === 2) {
        var zoomEvent = eventData.zoom;
        eventData.zoom.maxPollCount = 15;
        resetPolling(EVENT_NAMES.ZOOM);
      }
    });
  }

  // iOS: Leaving a finger but still keeping a finger, likely a 2+ finger operation like zoom
  if (detect.capabilities.ios) {
    $window.bind("touchend", function (event) {
      if (event.originalEvent.touches.length === 1) {
        eventData.zoom.maxPollCount = 1;
        resetPolling(EVENT_NAMES.ZOOM);
      }
    });
  }

  // Desktop & Win tablets: Zooming fires resize event
  // TODO: only "zoom in" fires resize in Nokia win8 phone, "zoom out" misses 99% of the time
  if (!detect.capabilities.ios && !detect.capabilities.android) {
    $window.bind("resize", function (event) {
      eventData.zoom.maxPollCount = 5;
      resetPolling(EVENT_NAMES.ZOOM);
    });
  }

  return {
    viewport: getViewport,
    cursor: getCursor,
    scrollBarWidth: getScrollBarWidth
  };
});
/////////////////////////
// END FILE a_browser_events.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * AUI Analytics Module. Simple methods for gathering data about usage
 * of AUI components, behaviors, and features.
 *
 * Private - for AUI use only. Not exposed as part of "A" module.
 */
P.register('a-analytics', function() {

    var ueTag = window && window.ue && window.ue.tag;

    /**
     * Increment a specific counter by 1, and initialize
     * the counter to 1 if it doesn't exist.
     *
     * This method is for a simple incrementer and to accommodate
     * the most common use cases for analytics internal to our JS.
     *
     * Use a counter name unique to the use case you're measuring.
     * We don't do anything fancy to guard against collisions,
     * and this makes the assumption the counter only uses a numeric
     * integer value.
     *
     * @see http://w?ClientSideMetrics/UserDocs/Instrumentation/ClientSideCounters
     * @param {String} name The event to increment
     * @param {Integer} amount The amount to increment by; defaults to 1
     */
    function increment(name, amount) {
        if(name) {
            var orig = count(name) || 0;
            count(name, orig + (amount || 1));
        }
    }

    /**
     * Sets and reports a specific UE counter value.
     * @see http://w?ClientSideMetrics/UserDocs/Instrumentation/ClientSideCounters
     * @param {String} name The identifier for the counter
     * @param {Integer ?} value (optional)
     */
    function count(name, value) {
        var ueCount = window && window.ue && window.ue.count;
        if (ueCount && name) {
            var key = 'aui:' + name;
            if (arguments.length > 1) {
                ueCount(key, value);
            }
            return ueCount(key);
        }
    }

    /**
     * Method to log custom errors using CSM's ueLogError() if it is present on the page.
     * Does NOT do anything if ueLogError is NOT present on the page.
     *
     * @see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/JavascriptErrors#Error_levels
     * @param {String} message The error message to log.
     * @param {String} logLevel Whether it should be ERROR, WARN or FATAL. We do NOT provide a default if value NOT provided.
     *                          We fallback to the default used by ueLogLevel which is "ERROR"
     * @param {String} attribution The attribution to attach the error-message to.
     */
    function logError(message, logLevel, attribution){
        if (!window.ueLogError) { return; }
        window.ueLogError(
            {message: message},
            {
                logLevel: logLevel,
                attribution: attribution
            }
        );
    }

    /**
     * Proxy call to CSM tag.
     */
    function tag(label) {
        if (ueTag && label) {
            ueTag('aui:' + label);
        }
    }

    // -------------------------------------------------------------------------

    return {
        increment: increment,
        count: count,
        logError: logError,
        tag: tag
    };
});
/////////////////////////
// END FILE a_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_request_animation_frame.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  window.requestAnimationFrame ployfill with an A.requestAnimationFrame interface.
 *  Code adapted from Paul Irish's github:  https://gist.github.com/paulirish/1579671
 *
 */

"use strict";

P.when("a-util").register("a-request-animation-frame", function (util) {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  // If window.requestAnimationFrame isn't present, check to see if there's a prefixed version
  // of the API.
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  // If there's no prefixed version of the API either, fall back to using setTimeout
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      var currTime = util.now();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }

  // We can't just return window.requestAnimationFrame here since the browser will throw an error if we
  // assign a native function to on of our objects and then call our object.  Therefore, we need to
  // wrap the function call.
  return {
    requestAnimationFrame: function (callback, element) {
      return window.requestAnimationFrame(callback, element);
    },
    cancelAnimationFrame: function (id) {
      window.cancelAnimationFrame(id);
    }
  };
});
/////////////////////////
// END FILE a_request_animation_frame.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_form_controls_api.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls API
 */

'use strict';

P.when('jQuery').register('a-form-controls-api', function ($) {
  /**
   *  The prefix for the form controls auto ID string
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var AUTO_ID_STRING = "a-form-controls-autoid-";

  /**
   *  Page-specific ID counter so we can assign unique IDs to all appropriate elements on the page in such a case that the implementer
   *  has not provided an ID for either the input or the label
   *
   *  @private
   *  @type {number}
   */
  var idCount = 0;

  /**
   *  Take a hypothetical element, confirm it's a jQuery object or a DOM node, and make sure we hand back a jQuery obj in the latter case
   *
   *  @private
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   *
   *  @return {object} - Returns the jQuery object representing the element passed in, or null if the element provided was not a DOM node
   */
  var _normalizeFunctionInput = function(element) {
    return (element && element.jquery) ? element : (element && element.nodeType === 1) ? $(element) : null;
  };

  /**
   *  Take a given element and properly search for its underlying form control
   *
   *  .first() is important for cases where similar elements turn up inside the label.
   *
   *  @private
   *  @param {object} $element - jQuery object representing a single form control element (radio/checkbox/touch-multi-select)
   *
   *  @return {object} - jQuery object for the underlying form control of the element
   */
  var _findInnerInput = function($element) {
    return $element.find('input').first();
  };

  /**
   *  Take a given element and properly search for its underlying form control
   *
   *  .first() is important for cases where similar elements turn up inside the label.
   *
   *  @private
   *  @param {object} $element - jQuery object representing a single icon element (radio/checkbox/touch-multi-select)
   *
   *  @return {object} - jQuery object for the underlying icon of the element
   */
  var _findInnerIcon = function($element) {
    return $element.find('i.a-icon').first();
  };

  /**
   *  Traverse upwards from a given element to find the most appropriate container to use when finding other elements that are related
   *
   *  @public
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   */
  var findFormElementContainer = function(element) {
    var $element = _normalizeFunctionInput(element);

    if ($element && $element.length === 1) {
      var $container = $element.closest('form');

      if ($container.length === 0) {
        $container = $element.closest('fieldset');
        if ($container.length === 0) {
          $container = $(document);
        }
      }

      return $container;
    }
  };

  /**
   *  Set the state of a single touch multiselect row.
   *
   *  @private
   *  @param {object} $element - jQuery object containing the touch multi select row
   *  @param {boolean} checkedState - State to set the checked attribute
   */
  var _setMultiSelectState = function($element, checkedState) {
    var $icon = _findInnerIcon($element);

    $icon
      .toggleClass('a-icon-touch-multi-select-active', checkedState)
      .toggleClass('a-icon-touch-multi-select', !checkedState);

    $element.attr('aria-checked', checkedState);
  };

  /**
   *  Set the state of a single checkbox/radio. Expects to be passed the <div> wrapping the label/input/i/text.
   *
   *  @private
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   *  @param {boolean} checked - State to set the checked attribute
   *  @param {boolean} disabled - State to set the disabled attribute
   */
  var _setInputState = function(element, checked, disabled) {
    var $element = _normalizeFunctionInput(element),
      $input, checkedState, disabledState;

    if (!$element || $element.length !== 1) {
      return false;
    }

    $input = _findInnerInput($element);

    // Check the original value for undefined for cases where we only want to change disabled state.
    if (checked !== undefined) {
      checkedState = !!checked;

      if ($element.hasClass('a-touch-multi-select')) {
        _setMultiSelectState($element, checkedState);
      }

      // Don't change the input or dispatch if it's already set correctly
      if ($input.prop('checked') !== checkedState) {
        $input.prop('checked', checkedState).trigger('change');
      }
    }

    // Check the original value for undefined for cases where we only want to change checked state.
    if (disabled !== undefined) {
      disabledState = !!disabled;

      // Don't change the input if it's already set correctly
      if ($input.prop('disabled') !== disabledState) {
        $input.prop('disabled', disabledState);
      }
    }
  };

  /**
   *  Convenience function to set the checkbox state to its opposite state.
   *
   *  @public
   *  @param {object} element - The element to toggle, otherwise attempt to use the context var
   */
  var toggleCheckboxState = function(element) {
    var $element = _normalizeFunctionInput(element),
      $input;

    if ($element && $element.length === 1) {
      $input = _findInnerInput($element);
      _setInputState($element, !$input[0].checked);
    }
  };

  /**
   *  Ensure a given elements visual appearance matches its underlying form element
   *
   *  @public
   *  @param {object} [element] - Optional, the element to normalize, otherwise attempt to use the context var
   */
  var normalizeElement = function(element) {
    /*jshint validthis:true */
    var $element = _normalizeFunctionInput(element);
    // if we didn't get passed an element directly, assume we're iterating, and test 'this' as the element
    $element = $element ? $element : _normalizeFunctionInput(this);

    if ($element && $element.length === 1) {
      var $input = _findInnerInput($element);
      var inputType = $input.attr('type');
      var isTouchMultiSelect = $element.hasClass('a-touch-multi-select');

      // If regular radio or checkbox, the label or the input inside may have an ID
      // If a touch-multi-select checkbox, the label's parent or the input may have an ID
      // Rule out element and input first, then if not touch multi, proceed, if is touch multi, check to see if the parent has an ID before proceeding
      if (!$element.attr('id') && !$input.attr('id') && (!isTouchMultiSelect || (isTouchMultiSelect && !$element.parent().attr('id')))) {
        var autoID = AUTO_ID_STRING + idCount;
        $element.attr('aria-labelledby', autoID).find('.a-checkbox-label, .a-radio-label, .a-touch-multi-select-item-label').attr('id', autoID);
        idCount++;
      }

      _setInputState($element, $input[0].checked, $input[0].disabled);
    }
  };

  /**
   *  For accessibility purposes, we need to associate legends to fieldsets so checkboxes and radio buttons announce
   *  their legend when they receive focus.
   *
   *  @public
   *  @param {string} selector - The selector for a given set of elements (they differ on desktop and mobile)
   */
  var normalizeFieldsets = function(selector) {
    // Get deduplicated list of fieldsets
    var $fieldsets = $(selector).closest('fieldset');

    $fieldsets.each(function(index, element) {
      var $fieldset = $(element);
      var $legend = $fieldset.find('legend').first();

      // If our fieldset has a legend, associate the two with aria roles and IDs.
      if ($legend.length) {
        var legendID = $legend.attr('id');

        if (!legendID) {
          legendID = AUTO_ID_STRING + idCount;
          $legend.attr('id', legendID);
          idCount++;
        }

        $fieldset.attr('aria-describedby', legendID);
      }
    });
  };

  return {
    findFormElementContainer: findFormElementContainer,
    toggleCheckboxState: toggleCheckboxState,
    setCheckboxState: _setInputState,
    setRadioState: _setInputState,
    normalizeElement: normalizeElement,
    normalizeFieldsets: normalizeFieldsets
  };
});
/////////////////////////
// END FILE a_form_controls_api.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_weblab.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Team Client-Side Weblabs
 */
'use strict';

/**
 *  Private API for querying AUI template weblab state.
 *
 *  IMPORTANT NOTICE:
 *  This API is solely for use with weblabs implemented by the AUI team and should not be used
 *  in any way by any other team.
 *
 *  WARNING:
 *  Because it relies on page state, a-weblab must be deferred until DOM ready (the 'ready' event).
 *  This means that all logic depending on a-weblab is also deferred. Design accordingly!
 */
P.when('a-util', 'a-constants')
  .execute('prepare-a-weblab', function (util, constants) {

    var WLAB_STATES_NAMESPACE = 'a-wlab-states';
    var LTREE_STATES_NAMESPACE = 'a-ltree-states';

    P.when(constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + WLAB_STATES_NAMESPACE)
      .register('a-weblab', function (wlabValue) {
        // a-wlab-states is standard page state for AUI template weblabs
        // We only take the first weblab value which comes from AUI body component. All the following weblab pagestate
        // update will be ignored. So that there is no way to change weblab setting from client side.
        var aWlabStates = wlabValue || {};
        // a-ltree-states, if it exists, is a LinkTree/Nav hack to inject weblab state data
        var aLtreeStates;
        // Record every queried weblab before a-ltree-states is ready, so we know if a-ltree-states
        // changes any weblab value
        var wlabQueried = {};
        var DEFAULT_TREATMENT = 'C';

        P.when(constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + LTREE_STATES_NAMESPACE).execute(function onLtreeUpdated (ltreeValue) {
            /**
             * Searching source code founds no one is using a-ltree-states. We still bind to it, and record an error if
             * a-ltree-states data cause any weblab status changing.
             */
            aLtreeStates = ltreeValue || {};
            util.each(util.keys(wlabQueried), function (wlabId) {
              if ((aLtreeStates[wlabId] || wlabQueried[wlabId]) && aLtreeStates[wlabId] !== wlabQueried[wlabId]) {
                P.log('a-weblab returned wrong value for ' + wlabId + '. It returned ' + wlabQueried[wlabId] + '. it is set as ' + aLtreeStates[wlabId] + ' at a-ltree-states.');
              }
            });
          }
        );

        /**
         *  Return a weblab treatment from page state data.
         *
         *  @private
         *  @param {string} weblabId
         *
         *  @return {string}
         */
        function getTreatment(weblabId) {
          if (!aLtreeStates) {
            wlabQueried[weblabId] = aWlabStates[weblabId];
          }
          return (aLtreeStates && aLtreeStates[weblabId]) || aWlabStates[weblabId];
        }

        /**
         *  Return a weblab treatment without recording a client-side trigger.
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {string}
         */
        function noTrigger(weblabId) {
          return getTreatment(weblabId) || DEFAULT_TREATMENT;
        }

        /**
         *  Return a weblab treatment and also record a client-side trigger.
         *
         *  TODO: Once CSM supports weblab triggering, add that triggering.
         *  SEE: https://sim.amazon.com/issues/CSM-161
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {string}
         */
        function trigger(weblabId) {
          var treatment = getTreatment(weblabId);
          // Add CSM client-side triggering here
          if (AUI_JS_DEBUG) {
            P.log('AUI Weblab Triggering is not implemented.', 'WARN', 'a-weblab');
          }
          return treatment || DEFAULT_TREATMENT;
        }

        /**
         *  Test a weblab for a specific treatment, and optionally record a client-side trigger.
         *
         *  @public
         *  @param {string} weblabId
         *  @param {string} testTreatment
         *  @param {boolean} doTrigger
         *
         *  @return {boolean}
         */
        function is(weblabId, testTreatment, doTrigger) {
          return (doTrigger ? trigger : noTrigger)(weblabId) === testTreatment;
        }

        /**
         *  Return true iff a weblab is actually active in the current realm.
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {boolean}
         */
        function isActive(weblabId) {
          return !!getTreatment(weblabId);
        }

        return {
          is: is,
          isActive: isActive,
          noTrigger: noTrigger,
          trigger: trigger
        };
      });
  });
/////////////////////////
// END FILE a_weblab.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_post_atf.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Defer to execute function after ATF or DOM is ready
 */
'use strict';

P.declare('prv:a-post-atf-catchdomready', true); // TODO: create P.block at MockPageJS to complete the test
P.when('a-util', 'a-defer', 'prv:a-post-atf-catchdomready')
  .register("prv:a-post-atf", function (util, defer, catchDomReady) {
    var fnQueue = [],
      postAtf = false;

    /**
     * postAtf.execute: defer executing a function after ATF or DOM is ready
     * @param fn {Function} the function to be deferred executed
     */
    function execute(fn) {
      if (postAtf) {
        defer.defer(fn);
      } else {
        fnQueue.push(fn);
      }
    }

    function flush() {
      if (!postAtf) {
        postAtf = true;
        util.each(fnQueue, function (fn) {
          defer.defer(fn);
        });
        fnQueue = [];
      }
    }

    function flushAfterDomReady() {
      if (catchDomReady) {
        flush();
      }
    }

    P.when('af', 'cf').execute('flush_queued_functions_after_ATF', flush);

    P.when('a-domready').execute('flush_queued_functions_after_domready', function () {
      util.delay(flushAfterDomReady, 500);
    });

    return {
      execute: execute
    };
  });
/////////////////////////
// END FILE a_post_atf.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_tnr.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI TNR related functionalities.
 */
'use strict';

/** Invoke TNR event.acknowledge() for declarative action event when TNR tracking is enabled. */
P.register('prv:a-tnr', function() {

  /**
   * Find TNR data attribute for a declarative action event.
   *
   * When a delcarative action is triggered, event.target is the element the event originate from,
   * event.currentTarget is the element which the declarative action is attached to.
   *
   * Any `data-ux-{eventType}` attribute defined in DOM elements between event.target (inclusive) and
   * event.currentTarget (inclusive) are covered by the declarative action, if eventType matches.
   * The declarative should trigger the nativeEvent.acknowledge call from TNR library if defined.
   *
   * This method identify if a matching `data-ux-{eventType}` is found.
   *
   * If the data attribute is found, return immediately.
   * If no data attribute is found in all the nodes, returns null.
   *
   * @param  {string}      eventType      the event type triggering declarative action
   * @param  {HTMLElement} target         the event target
   * @param  {HTMLElement} currentTarget  the event currentTarget
   * @return {string}                     value of TNR data attribute if found, null otherwise
   */
  function findTnrAttribute(eventType, target, currentTarget) {
    return null;
  }

  /**
   * Invoke TNR acknowledge call when appropriate.
   *
   * TNR ack call is invoked when:
   * 1. TNR acknowledge API is available
   * 2. a corresponding TNR attribute is defined in an HTML element covered by the event handler
   *
   * @param {object}      event         event object
   * @param {string}      eventType     event type
   * @param {HTMLElement} target        element which the event originates from
   * @param {HTMLElement} currentTarget element which the event handle is attached to
   */
  function ack(nativeEvent, eventType, target, currentTarget) {}
  function ackDelegated(event) {}
  function ackDeclarative(event) {}

  /**
   * Find event handlers from jQuery bind arguments, replaces with wrapped version that calls ack.
   *
   * Usage: wrapJqBindArgs(currentTargetOverride, jQuery bind args)
   *
   * Example: wrapJqBindArgs(null, 'click', clickHandler);
   *
   * The first argument is currentTarget overide in wrapped handler, nul for no override.
   * The rest arguemtns are jQuery bind arguments, supports arguments of following formats:
   *
   * 1. bind(obj) where obj is { eventType: handler, ... }
   * 2. bind(eventType, [eventData], handler) where eventData is optional
   *
   * Returns wrapped jQuery bind arguments in an array. The currentTargetOverride is dropped in the returned array.
   */
  function wrapJqBindArgs() {
    // Convert arguments to Array in a way that does not prevent optimization.
    // Reference:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var length = arguments.length;
    if (length <= 1) {
      return [];
    }

    // The first argument is currentTargetOverride, which is not copied.
    var args = [];
    for (var i = 1; i < length; i++) {
      args.push(arguments[i]);
    }

    return args;
  }

  /**
   * Find event handlers from jQuery unbind arguments, replaces with wrapped verions that was previously binded.
   *
   * Supports parameters of following format:
   * unbind(eventType, handler)
   *
   * @param  {arguments} args arguments to jQuery.bind()
   * @return {arguments}      arguments with wrapped handlers
   */
  function wrapJqUnbindArgs() {
    // Convert arguments to Array in a way that does not prevent optimization.
    // Reference:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var args = new Array(arguments.length);
    for(var i = 0; i < args.length; ++i) {
        args[i] = arguments[i];
    }

    return args;
  }

  function wrapDeclarativeActionHandler(fn) {
    return fn;
  }

  return {
    findTnrAttribute: findTnrAttribute,
    ack: ack,
    ackDelegated: ackDelegated,
    ackDeclarative: ackDeclarative,

    // These are currently used by form components `on` and `off` API overrides,
    // the jQuery arguments wrapping logic is extracted here because
    // the same logic might be applied to AmazonUIjQuery.
    wrapJqBindArgs: wrapJqBindArgs,
    wrapJqUnbindArgs: wrapJqUnbindArgs,

    wrapDeclarativeActionHandler: wrapDeclarativeActionHandler
  };
});
/////////////////////////
// END FILE a_tnr.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_prv_collect_debug.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Purpose of this module is to expose the logDebug function, which will log
 * all data from p-debug ONLY on the first occasion it is called.
 * Originally added for TNR data logging, but may be useful for other cases as well
 */
//--------------------------------------------------------------------------
"use strict";

P.register('prv:a-collect-p-debug', function () {

    var alreadyLogged = false;

    function logDebug () {
        if (alreadyLogged) {
            return;
        }
        alreadyLogged = true;

        P.when('prv:p-debug', 'afterLoad').execute(function (debug) {
            var msg = (JSON && JSON.stringify) ? JSON.stringify(debug) : '{}';
            P.log(
                msg,
                'WARN',
                '[AUI] p-debug'
            );
        });
    }
    return logDebug;
});
/////////////////////////
// END FILE a_prv_collect_debug.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_component_mixins.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Component Mixins
 *  Common methods for AUI components
 */

'use strict';

P.when('A').register('a-component-mixins', function (A) {

    var count = 0;

    var declarativeList = A.constants.declarativeEvents.split(' ');

    /**
     * Creates a unique identifier to be associated with a declarative action
     * @returns {string} the unique id
     */
    function uuid () {
        return 'a-component-event-' + count++;
    }

    /**
     * Checks to make sure the A.declarative module supports all events in a list
     * @param searchKeys: The list of events to search for
     * @returns {boolean}: true if all events were found, false if any were not
     */
    function supportsAll (searchKeys) {
        for (var i = 0; i < searchKeys.length; i++) {
            if (A.indexOfArray(declarativeList, searchKeys[i]) < 0) {
                return false;
            }
        }
        return true;
    }

    return {

        /**
         * Show the component
         */
        show: function () {
            this._$element
                .removeClass('a-hidden aok-hidden')
                .show();
            return this;
        },

        /**
         * Hide the component
         */
        hide: function () {
            this._$element
                .addClass('aok-hidden');
            return this;
        },

        /**
         * Toggle the component's visibility
         * @return the toggled component
         */
        toggle: function () {
            return this._$element.hasClass('aok-hidden') ? this.show() : this.hide();
        },

        /**
         * Returns the number of elements wrapped by the component
         * @return {number}
         */
        size: function () {
            return this._$element.size();
        },

        /**
         * Return true if the component wraps no elements
         * @return {boolean}
         */
        isEmpty: function () {
            return this._$element.size() === 0;
        },

        /**
         * Creates a declarative action for the the event
         * @param events:  list of events
         * @param fn: the callback to execute when the event occurs
         */
        on: function (events, fn) {
            var fName = A.parseFunctionName(fn);
            if (!fName) {
                P.error.call({}, "Please name all asynchronous event callbacks");
            }
            var eventList = events ? events.split(' ') : undefined;
            if (!eventList) { return; }
            this.fnMap = this.fnMap || {};
            if (!supportsAll(eventList)) {
                P.error.call({}, 'That event is not supported!');
            }
            var context = this;

            A.each(eventList, function (event) {
                this.fnMap[event] = this.fnMap[event] || [];
                var actionID = this.fnMap[event][fn] = uuid();
                var guardedFunc = function () {
                    try {
                        fn.apply(context, context.callbackArgs || []);
                    } catch (e) {
                        P.logError.call({}, e, 'Error occurred in an asynchronous event callback', 'FATAL',
                            (fn.caller || "") + event + 'handler:' + (fName || 'anonymous'));
                    }
                };
                A.declarative(actionID, event, guardedFunc);
                A.declarative.create(context._$element, actionID);
            }, context);
        },

        /**
         * Removes any declarative action matching the events or callback passed
         * @param events: a list of events to remove actions for
         * @param fn: specific callback to remove
         */
        off: function (events, fn) {
            var eventList = events ? events.split(' ') : undefined;
            if (!this.fnMap) {
                P.error.call({}, "There are no callbacks assigned to this component");
            }
            if (eventList && fn) {
                //Remove a specific callback
                A.each(eventList, function (event) {
                    try {
                        A.declarative.remove(this._$element, this.fnMap[event][fn]);
                        delete this.fnMap[event][fn];
                    } catch (e) {
                        P.error.call({}, "The component is not bound to a callback with name " + A.parseFunctionName(fn) || 'anonymous' +
                            " for event " + event);
                    }
                }, this);
            }
            else if (!fn && !eventList) {
                //Remove all
                A.declarative.remove(this._$element);
                delete this.fnMap;
            }
            else if (!fn && eventList) {
                //Remove all callbacks for a set of events
                A.each(eventList, function (event) {
                    for (var callback in this.fnMap[event]) {
                        if (this.fnMap[event].hasOwnProperty(callback)) {
                            this.off(event, callback);
                        }
                    }
                    delete this.fnMap[event];
                }, this);
            }
            else {
                //Can't remove a callback without knowing the event that triggers it
                P.error.call({}, "Please provide an event associated with the callback");
            }
        },

        /**
         * Attaches the component as a trigger for declarative actions corresponding to the specified event, then triggers the event on the component
         * @param signal: the event to trigger
         * @param extraArgs: any extra arguments to be passed to the event callback
         */
        trigger: function (signal, extraArgs) {
            this.callbackArgs = extraArgs || [];
            A.$.fn.trigger.call(this._$element, signal);
        }
    };
});
/////////////////////////
// END FILE components/a_component_mixins.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_component.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Component Class/Factory
 *  Exposes functionality for creating AUI components from a common base.
 *  Handles mixing in methods from a-component-mixins
 */

'use strict';

P.when('A', 'jQuery', 'a-component-mixins', 'a-analytics', 'prv:a-sampler')
  .register('a-component', function (A, $, mixins, analytics, sampler) {

    /**
     * Base component from which new components will inherit;
     * common properties can be initialized here.
     */
    var BaseComponent = A.createClass({
        init: function(selector, context) {
            if (A.contains(selector, '.a-')) {
                P.error("{API} Cannot create components using 'a-' selectors. Apply your own CSS class or ID to select this element.", 'API', 'component');
            }

            this._$element = $(selector, context);

            this._trackApi();
        },

        /**
         * Analytics to measure usage of JavaScript component APIs
         */
        _trackApi: function() {
            // Check for invalid/missing component names (undefined, empty string, etc)
            if (this._componentName && sampler("AUI API Analytics")) {
                analytics.increment("api:" + this._componentName);
            }
        }
    });

    /**
     * Create a new component type
     *
     * @param {object} options - an object containing the properties/methods the
            new component should have
     * @return {object}
     */
    function createComponent(options) {
        var toMixin = options.mixin,
            newComponent;

        if(toMixin) {
            delete options.mixin;
        }

        newComponent = BaseComponent.extend(options);

        if(toMixin) {
            A.mixin(newComponent.prototype, mixins, toMixin);
        }

        return newComponent;
    }

    /**
     * Public factory function
     */
    return {
        create: createComponent
    };
});
/////////////////////////
// END FILE components/a_component.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_alert.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Alert API
 */

'use strict';


/**
 *  Alert API allows users to create and manage alerts
 */
P.when('A', 'jQuery', 'a-component').register('a-alert', function (A, $, component) {
    var TYPES = ['error', 'success', 'warning', 'info'];
    var INLINE_CLASS = 'a-alert-inline';
    var HEADING_CLASS = 'a-alert-heading';

    var normalClasses = A.map(TYPES, function (t) {
            return 'a-alert-' + t;
        }).join(' ');

    var inlineClasses = A.map(TYPES, function (t) {
            return INLINE_CLASS + '-' + t;
        }).join(' ');

    var header = document.createElement('h4');
    header.className = HEADING_CLASS;
    var $HEADER = $(header);


    /**
     * Constructor for Alert
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Alert = component.create({
        _componentName: 'alert',
        init: function (selector, context) {
            this._super(selector, context);

            this._$element = this._$element.filter('.a-alert, .' + INLINE_CLASS);
            this._$heading = this._$element.find('.' + HEADING_CLASS);
            this._$content = this._$element.find('.a-alert-content');
        },
        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Get/set the heading of the alert
         *
         * @param {string} content - the plaintext heading for the alert
         * @return {string|object}
         */
        heading: function (content) {
            if(typeof content === 'undefined') {
                return this._$heading.text();
            } else {
                if(!this._$heading.length) {
                    this._$heading = $HEADER.clone()
                        .text(content)
                        .insertBefore(this._$content);
                } else {
                    this._$heading.text(content);
                }
            }
            return this;
        },

        /**
         * Remove the alert's heading
         */
        removeHeading: function () {
            this._$heading.remove();
            this._$heading = $();
            return this;
        },

        /**
         * Get/set the plaintext content of the alert
         *
         * @param {string} content - the text content for the alert
         * @return {string|object}
         */
        text: function (content) {
            if(typeof content === 'undefined') {
                return this._$content.text();
            } else {
                this._$content.text(content);
            }
            return this;
        },

        /**
         * Get/set the html content of the alert
         *
         * @param {string} content - the html content for the alert
         * @return {string|object}
         */
        html: function (content) {
            if(typeof content === 'undefined') {
                return this._$content.html();
            } else {
                this._$content.html(content);
            }
            return this;
        },

        /**
         * Set the alert_type of the alert
         *
         * @param {string} alertType
         */
        type: function (alertType) {
            if (A.indexOfArray(TYPES, alertType) === -1) {
                P.error('{API} Alert type must be one of [error, success, warning, info].', 'API', 'alert');
            }

            this._$element.each(function (index, el) {
                var $el = $(el),
                    prefix = 'a-alert-';

                if($el.hasClass(INLINE_CLASS)) {
                    prefix += 'inline-';
                    $el.removeClass(inlineClasses);
                } else {
                    $el.removeClass(normalClasses);
                }

                $el.addClass(prefix + alertType);
            });

            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Alert(selector, context);
    };
});
/////////////////////////
// END FILE components/a_alert.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_checkbox.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Checkbox API
 */

'use strict';

/**
 *  Checkbox API allows users to manage the state of AUI checkboxes
 */
P.when('jQuery', 'a-component', 'a-form-controls-api').register('a-checkbox', function ($, component, controls) {
    var setState = controls.setCheckboxState;

    /**
     * Constructor for Checkbox
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Checkbox = component.create({
        _componentName: 'checkbox',
        init: function (selector, context) {
            this._super(selector, context);

            // Allow for passing in a selector that matches nested input elements
            this._$element = this._$element.closest('.a-checkbox');
            this._$input = this._$element.find('[type=checkbox]');
        },
        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Set the checked state of the checkbox
         *
         * @param {boolean} shouldCheck - optional, what checked state to toggle the checkbox into
         * @return {object}
         */
        check: function (shouldCheck) {
            shouldCheck = (shouldCheck === void 0) ? true : shouldCheck;
            this._$element.each(function() {
                setState(this, shouldCheck);
            });
            return this;
        },

        /**
         * Uncheck the checkbox
         *
         * @return {object}
         */
        uncheck: function () {
            return this.check(false);
        },

        /**
         * Toggle each checkbox's checked state
         *
         * @return {object}
         */
        toggleChecked: function () {
            this._$element.each(function() {
                controls.toggleCheckboxState(this);
            });
            return this;
        },

        /**
         * Returns true if all checkboxes are checked.
         *
         * @return {boolean}
         */
        isChecked: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(!this._$input[i].checked) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns true if all checkboxes are unchecked.
         *
         * @return {boolean}
         */
        isUnchecked: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(this._$input[i].checked) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Set the enabled state of the checkbox
         *
         * @param {boolean} shouldEnable - optional, what enabled state to toggle the checkbox into
         * @return {object}
         */
        enable: function (shouldEnable) {
            shouldEnable = (shouldEnable === void 0) ? true : shouldEnable;
            this._$element.each(function() {
                // setState is setting the disabled property, so invert `shouldEnable` here
                setState(this, void 0, !shouldEnable);
            });
            return this;
        },

        /**
         * Disable the checkbox
         *
         * @return {object}
         */
        disable: function () {
            return this.enable(false);
        },

        /**
         * Toggle each checkbox's disabled state
         *
         * @return {object}
         */
        toggleEnabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                setState(this._$element[i], void 0, !this._$input[i].disabled);
            }
            return this;
        },

        /**
         * Returns true if all checkboxes are enabled.
         *
         * @return {boolean}
         */
        isEnabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(this._$input[i].disabled) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns true if all checkboxes are disabled.
         *
         * @return {boolean}
         */
        isDisabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(!this._$input[i].disabled) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Toggle the checkbox visibility
         *
         * @param {boolean} shouldBeVisible - optional, should the element be visible?
         * @return {object}
         */
        toggle: function (shouldBeVisible) {
            if(typeof shouldBeVisible !== 'undefined') {
                shouldBeVisible = !!shouldBeVisible;
            }
            this._$element.each(function() {
                $(this).toggle(shouldBeVisible);
            });
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Checkbox(selector, context);
    };
});
/////////////////////////
// END FILE components/a_checkbox.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_meter.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Meter API
 */

'use strict';


/**
 *  Meter API allows users to update meter
 */
P.when('A', 'a-component').register('a-meter', function (A, component) {
    var METER_CLASS = '.a-meter, .a-meter-with-txt';
    var METER_BAR_CLASS = '.a-meter-bar';
    var METER_TEXT_CLASS = '.a-meter-progress-txt';
    var DISABLED_CLASS = 'a-inactive';
    /**
     * Constructor for Meter
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Meter = component.create({
        _componentName: 'meter',

        init: function (selector, context) {
            this._super(selector, context);

            this._$element = this._$element.filter(METER_CLASS);
            this._$bar = this._$element.find(METER_BAR_CLASS);
            this._$progressTxt = this._$element.find(METER_TEXT_CLASS);
        },

        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Get the percentage and text of meter
         *
         * @returns {{percent: *, txt: *}}
         */
        get: function () {
            return {
                percent: this.percent(),
                txt: this.text()
            };
        },

        /**
         * Enable the meter
         *
         * @returns {Meter}
         */
        enable: function () {
            this._$element.removeClass(DISABLED_CLASS);
            return this;
        },

        /**
         * Disable the meter
         *
         * @returns {Meter}
         */
        disable: function () {
            this._$element.addClass(DISABLED_CLASS);
            return this;
        },

        /**
         * Return whether the meter is enabled
         *
         * @return {boolean}
         */
        isEnabled: function () {
            return !this._$element.hasClass(DISABLED_CLASS);
        },

        /**
         * get/set the percent of meter
         *
         * @param {Number} [percent] - percentage to set
         * @returns {Meter or String}
         */
        percent: function (percent) {
            if (typeof percent === 'undefined') {
                percent = this._$bar.get(0).style.width;
                return parseInt(percent, 10);
            }

            if (!A.isFiniteNumber(percent)) {
                P.error('{API}  Meter percent should be a number between 0 and 100', 'a-meter', 'setProgress');
            }
            percent = Math.min(100, Math.max(0, percent));
            var percentStr = percent + '%';
            this._$bar.css({width: percentStr});
            this._$element.attr({
               'aria-label': percentStr,
               'aria-valuenow': percentStr
            });
            return this;
        },

        /**
         * get/set the status text of meter
         *
         * @param {String} [txt] - text to be set
         * @returns {Meter or String}
         */
        text: function (txt) {
            if (typeof txt === 'undefined') {
                return this._$progressTxt.text();
            }
            this._$progressTxt.text(txt);
            return this;
        },

        /**
         * Set progress and text
         *
         * @param {Number} percent
         * @param {String} txt
         * @returns {Meter}
         */
        set: function (percent, txt) {
            this.percent(percent);
            if (txt) {
                this.text(txt);
            }
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Meter(selector, context);
    };
});
/////////////////////////
// END FILE components/a_meter.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_spinner.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Spinner API
 */
P.when('a-component').register('a-spinner', function (component) {
    'use strict';

    /**
     * Constructor for Spinner
     *
     * @param {String} selector
     * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
     */
    var Spinner = component.create({
        _componentName: 'spinner',
        init: function (selector, context) {
            this._super(selector, context);

            // Grabbing a-spinner-wrapper (for block level)
            // and a-spinner (for inline).
            //
            // Will only grab the spinners matching the selector provided so this
            // is fine despite a-spinner being nested inside of a-spinner-wrapper
            // for block level spinner
            this._$element = this._$element.filter('.a-spinner-wrapper, .a-spinner');
        },

        mixin: ['show', 'hide', 'isEmpty', 'size'],

        remove: function() {
            this._$element.remove();
        }

        // TODO add create function
        // something like the below, but ideally generated from the spinner.yada file
        // w?User:Freitas/SpinnerCreateAPI
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Spinner(selector, context);
    };
});
/////////////////////////
// END FILE components/a_spinner.js
/////////////////////////
/////////////////////////
// BEGIN FILE extras/a_ua.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Amazon UI User Agent Helpers
'use strict';

P.register('a-ua', function () {
  /**
   *  Determines whether a given an arbitrarily delimited multi-part version number is greater than another
   *  for versions that are patterned as positive real numbers, including 0, separated by string delimiters
   *  (or no delimiter, explicitly)
   *
   *  @param {string} firstVersion The first version number to compare
   *  @param {string} secondVersion The second version number to compare
   *  @param {string} [delimiter="."] The string used to split the version number into comparable parts
   *
   *  @return {int} Either -1, 0, or 1.
   *                -1: firstVersion is lower
   *                 0: versions are equal
   *                 1: firstVersion is higher
   */
  function compareVersions(firstVersion, secondVersion, delimiter) {
    var incomparable = function(reason) {
      P.error("Versions are not comparable. " + reason, "A - extras", "compareVersions");
    };
    
    // guards against "" delimiter
    delimiter = delimiter || ".";

    if (typeof firstVersion !== "string" || typeof secondVersion !== "string" || typeof delimiter !== "string" || firstVersion === "" || secondVersion === "") {
      // Checking empty string is necessary when using Number as Number("") evaluates to 0, "funfortunately."
      incomparable("Input values are not valid.");
    }

    var firstPieces = firstVersion.split(delimiter);
    var secondPieces = secondVersion.split(delimiter);
    var comparisonLength = Math.max(firstPieces.length, secondPieces.length);

    for (var i = 0; i < comparisonLength; i++) {
      // Use Number instead of parseInt for better handling of "8b" which parseInt
      // cannot handle properly and should not evaluate as equivalent to "8".
      var partFromFirst = (i < firstPieces.length) ? Number(firstPieces[i]) : 0;
      var partFromSecond = (i < secondPieces.length) ? Number(secondPieces[i]) : 0;

      if (isNaN(partFromFirst) || !isFinite(partFromFirst) || isNaN(partFromSecond) || !isFinite(partFromSecond)) {
        incomparable("Piece of one version number evaluates to NaN or +/- Infinity.");
      }

      if (partFromFirst < partFromSecond) {
        return -1;
      }
      if (partFromFirst > partFromSecond) {
        return 1;
      }
    }
    
    return 0;
  }
  
  return {
    compareVersions: compareVersions
  };
});
/////////////////////////
// END FILE extras/a_ua.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_log_trigger.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Logs two CSM counters representing the number and duration of
 * scheduled callbacks executed via P prior to the passed event.
 * This relies on the debug data format defined in AmazonUIPageJS
 * and is called automatically from P.trigger.
 */
P.when('a-analytics', 'prv:p-debug', 'ready').execute(function(analytics, debug) {
    P.declare('prv:a-logTrigger', function reportCallbackBlocking(event) {
        var threshold = debug[event] && debug[event].registered || 0;
        var count = 0;
        var duration = 0;
        for (var key in debug) {
            if (debug.hasOwnProperty(key)) {
                var datum = debug[key];
                if (datum.end && datum.end <= threshold) {
                    count++;
                    duration += datum.end - datum.start;
                }
            }
        }
        analytics.count("blocking-count:"+event, count);
        analytics.count("blocking-time:"+event, Math.round(duration));
    });
});
/////////////////////////
// END FILE a_log_trigger.js
/////////////////////////
/////////////////////////
// BEGIN FILE extras/a_docsite_test.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('a-analytics', 'afterLoad').execute('a-doctype-test', function (analytics) {
    var DOCTYPE_ISSUE = 'a-doctype-issue';

    if (!document.doctype || !document.doctype.name || document.doctype.name.toLowerCase() !== 'html') {
            P.log('Missing or Invalid HTML doctype. Please refer to http://w?AUI/LogMessages#HDOCTYPE for more details.', 'WARN');
            analytics.increment(DOCTYPE_ISSUE);
    }
});
/////////////////////////
// END FILE extras/a_docsite_test.js
/////////////////////////
/////////////////////////
// BEGIN FILE extras/a_unicode_rupee_test.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('jQuery', 'a-analytics', 'load').register('a-unicode-rupee-test', function ($, analytics) {

    var UNICODE_RUPEE  = '&#8377;';
    var UNICODE_NOCHAR = '&#65534;';

    var METRIC_SUPPORTED   = 'aui-supported-rupee';
    var METRIC_UNSUPPORTED = 'aui-unsupported-rupee';

    /* Test Setup */
    function _setup() {

        // _jqElement returns a jQuery object
        var container = $('<div/>');
        var nochar    = $('<span/>').html(UNICODE_NOCHAR);
        var rupee     = $('<span/>').html(UNICODE_RUPEE);

        container.append(nochar, rupee);
        container.appendTo(document.body);

        // Return a NATIVE DOM reference to these created elements.
        return {
            container: container,
            nochar: nochar,
            rupee: rupee
        };
    }

    /* Test Running */
    function test() {

        // jQuery objects returned from setup.
        var refs = _setup();

        var WIDTH_RUPEE  = refs.rupee.width();
        var WIDTH_NOCHAR = refs.nochar.width();

        /*
            Compare the Rupee width with the width of a purposefully
            undefined character. If they're the same, Rupee is unsupported
        */
        if( WIDTH_RUPEE === WIDTH_NOCHAR ) {
            analytics.increment(METRIC_UNSUPPORTED, 1);
        }
        else {
            analytics.increment(METRIC_SUPPORTED, 1);
        }

        // Teardown and remove the nodes, test complete.
        refs.container.remove();
    }

    // Run the test immediately, set finished to true. Return nothing
    test();

});

/////////////////////////
// END FILE extras/a_unicode_rupee_test.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_sampler.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Provides a function which takes an experiment name,
 * and returns a boolean if the experiment is active.
 *
 * Example:
 * P.when('a-sampler').execute(function(sampler) {
 *   if (sampler('AUI API Analytics')) {
 *     // will execute for 5% of page loads
 *   }
 * });
 *
 */

"use strict";

// TODO: This should be set in page template (and generated server-side).
P.register("prv:a-sampler-inclusion", function () {
  return {
    "AUI API Analytics": (Math.random() < 0.01)
  };
});

P.when("prv:a-sampler-inclusion")
  .register("prv:a-sampler", function (inclusion) {
    return function (experimentName) {
      return inclusion.hasOwnProperty(experimentName) && inclusion[experimentName];
    };
  });
/////////////////////////
// END FILE a_sampler.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_pcv.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Helper module for getting Package Closure Version (PCV) from `window.pcv` object.
 */
P.when('A', '3p-promise', 'load').register('a-pcv', function (A, Promise) {
  var pcvPromise;
  
  /**
   * Obtains full pcv information from aui-pcv.corp.amazon.com if under debug mode;
   * otherwise, returns the plain pcv string.
   * 
   * @returns {Promise<Object>} A promise the resolve to { AmazonUI: pcv string } mapping
   */
  var getData = function () {
    if (!pcvPromise) {
      pcvPromise = new Promise(function (resolve, reject) {
        var auiPcv = window.pcv.AmazonUI;
        if (auiPcv) {
          // Inject AmazonUI's PCV into HTML tag
          document.documentElement.setAttribute('data-aui-version', auiPcv);
          
          // Return a more informative object under debug mode
          if (AUI_JS_DEBUG) {
            /**
             * Handles successful AJAX request
             *
             * @param {Object} data The POJO returned by the service
             */
            var successHandler = function (data) {
              auiPcv = (data && data.length > 0) ? data[0] : auiPcv;
              resolve(auiPcv);
            };
            
            /**
             * Handles failed AJAX request
             *
             * @param {Object} xhr The Xhr object
             * @param {string} status The status text 
             */
            var errorHandler = function (xhr, status, message) {
              reject(new Error('Cannot get PCV information; error: ' + message));
            };
            
            var ajaxOptions = {
              success: successHandler,
              error: errorHandler
            };
            
            // Make that request!
            A.get('https://aui-pcv.corp.amazon.com/pcv/' + auiPcv, ajaxOptions);
          } else {
            resolve(auiPcv);
          }
        } else {
          reject(new Error('Package closure version of AmazonUI is not found on the page'));
        }
      });
    }
    
    return pcvPromise;
  };
  
  return {
    getData: getData
  };
});
/////////////////////////
// END FILE a_pcv.js
/////////////////////////
/////////////////////////
// BEGIN FILE weblabs/a_perf.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('A').register('prv:a-timing-resource', function(A) {
    var PERF_SUPPORTED = window && 
            window.performance &&
            window.performance.getEntries &&
            typeof window.performance.getEntries === 'function';

    /**
     * Extract a list of resource timing entries. 
     * @param filter callback to filter resource entries (optional)
     * @return array resource timing entries. If resource timing api is not supported
     * an empty array will be returned.
     */
    function getResourceEntries (filter) {
        if (!PERF_SUPPORTED) {
            return []; // NOOP
        }
        var resourceEntries = window.performance.getEntries({ entryType: 'resource' }) || [];
        return typeof filter === 'function' ? A.filter(resourceEntries, filter) : resourceEntries;
    }

    return getResourceEntries;
});

// When 'A' is ready, JS and CSS should have been loaded
// performance entries should have been populated.
P.when('A', 'a-analytics', 'prv:a-timing-resource', 'ready').register('prv:a-asset-transfer', function(A, analytics, getTimingResources) {

    var RESOURCE_NAME_REGEX = /AUIClients\/(.*?(?=#|$|-[a-z0-9]{40}))/;

    /**
     * Extract the first substring encountered using a provided regex.
     * When default value is provided and no substring found, return the default value
     * otherwise return empty string.
     * @param regex the regex
     * @param source the string to extract the substring
     * @param defaultVal the default value.
     * Example: 
     *  extractByRegex(/foo([^\s]+)/, "this is a foobar string. How about foo bar?", "") => "bar"
     *  extractByRegex(/foo([^\s]+)/, "this is a foo bar string. How about foobar?", "") => "bar?"
     *  extractByRegex(/foo([^\s]+)/, "this is a foo bar string. How about foo bar?", "") => ""
     */
    function extractByRegex(regex, source, defaultVal) {
        var matches = regex.exec(source);
        return matches && matches.length >= 2 ? matches[1] : defaultVal || '';
    }

    function getResourceName(entry) {
        var resourceNameParts = [
            entry.initiatorType,
            extractByRegex(RESOURCE_NAME_REGEX, entry.name || '')
        ];
    
        return resourceNameParts.join(':');
    }

    function getAuiPerfEntries() {
        return getTimingResources(function(entry) {
            return entry &&
                (entry.initiatorType === 'link' || entry.initiatorType === 'script' || entry.initiatorType === 'css') &&
                entry.name && 
                entry.name.indexOf('AUIClients/AmazonUI') > 0; // this should cover AmazonUISkinSky
        });
    }

    return function() {
        A.each(getAuiPerfEntries(), function(entry) {
            var resourceName = getResourceName(entry);
            // this is to log a count for aui:script|link:AmazonUI*:dataPoint
            // we are logging directly to CSM counters so that we don't need
            // to do additional onboarding beside whitelisting
            var startTime = entry.startTime || 0,
                responseEnd = entry.responseEnd || 0,
                transferSize = entry.transferSize || 0,
                transferTime = entry.duration || responseEnd - startTime;

            if (transferSize === 0) {
                analytics.tag(resourceName + ':cachehit');
            } else {
                analytics.count(resourceName + ':transferSize', transferSize);
            }
            
            analytics.count(resourceName + ':startTime', startTime);
            analytics.count(resourceName + ':transferTime', transferTime >= 0 ? transferTime : 0);
        });
    };
});

/** 
 * To avoid latency noise and since we have this piece of code in production previously,
 * let's use `a-weblab` to gate the change.
 */
P.when('prv:a-asset-transfer', 'a-weblab').execute('a-asset-transfer-time', function(collectTransferTime, weblab) {
    var gatedWeblabId = 'AUI_PERF_130093';
    if (weblab.isActive(gatedWeblabId) && !weblab.is(gatedWeblabId, 'C')) {
        collectTransferTime();
    }
    
    if (AUI_JS_DEBUG) {
        P.register('prv:a-asset-transfer-time-done'); // for unit testing
    }
});
/////////////////////////
// END FILE weblabs/a_perf.js
/////////////////////////

// END ASSET AmazonUIBaseJS@base-3.2.15990.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS@declarative", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS@declarative-3.2.15990.0
/////////////////////////
// BEGIN FILE @js_debug_flag.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
var AUI_JS_DEBUG = true;
/////////////////////////
// END FILE @js_debug_flag.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_declarative.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Declarative Event Handler
 */
'use strict';

/**
 *  Allows users to register event handlers using only HTML and data attributes.
 */

P.when('jQuery', 'a-util', 'a-events', 'a-event-analytics', 'a-timing-analytics', 'a-constants', 'prv:a-declarative-analytics', 'p-recorder-stop', 'prv:a-tnr')
    .register('a-declarative', function ($, util, events, eventAnalytics, timingAnalytics, constants, declarativeAnalytics, pRecorderStop, tnr) { //jshint ignore:line
  var actionOptions = {};

  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  The selector used to find a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_SELECTOR = "." + DECLARATIVE_CLASS;

  /* Importing _prevent_default.js */
/**
 *  For backward compatibility, we want to prevent default when
 *  clicks are performed on declarative links.
 *
 *  @private
 *  @param {DOM node} $target  The event's target wrapping in a jQuery call
 *  @param {object} event  The event
 *  @param {object} options  The global options associated with this declarative action
 *  @param {object} data  The invocation/DOM node specific data for this declarative action
 *
 *  @return {boolean}
 */

function shouldPreventDefault($target, event, options, data) {
  var allowLinkDefault = false;
  if (data) {
    allowLinkDefault = !! data.allowLinkDefault;
  } else if (options) {
    allowLinkDefault = !! options.allowLinkDefault;
  }
  if (event.type === "click" && !allowLinkDefault) {
    var $link = $target.closest("a");
    return $link.length && ($link[0].href === "#" || event.currentTarget === $link[0] || $link.parent(DECLARATIVE_SELECTOR).length);
  }
  return false;
}
/* Done importing _prevent_default.js */


  /**
   *  Check the event and the DOM nodes associated with it to determine if we need to trigger
   *  an event based on the data attributes of the DOM nodes.
   *
   *  @private
   *  @param {object} $event  The jQuery event to examine
   */

  function handleEvent($event) {
    var $currentTarget = $($event.currentTarget);
    var $target = $($event.target);

    // In IE < 9 the $event.target for submit events is the submit button.  Everyone else has the form.  Normalize on the form.
    if ($event.type === "submit") {
      var $form = $target.closest("form");
      if ($form.length) {
        $target = $form;
      }
    }

    // If there aren't any actions in the data attribute, we have nothing to do
    var declAction = $currentTarget.data('action');
    if (!declAction) {
      return;
    }
    // Build up a normalized event object to pass into each declarative event callback
    var eventObj = {
      $target: $target,
      $currentTarget: $currentTarget,
      targetTag: $target.prop('tagName').toLowerCase(),
      type: $event.type,
      $event: $event,
      $declarativeParent: $currentTarget
    };
    handleNamedAction(declAction, eventObj);
  }

  /**
   *  Triggers an event based on the data attributes of the DOM nodes.
   *
   *  @private
   *  @param {String} declAction List of declarative actions
   *  @param {Object} eventObj Normalized event object to pass into each declarative event callback
   */
  function handleNamedAction (declAction, eventObj) {
    var $event = eventObj.$event;
    var $target = eventObj.$target;
    var $currentTarget = eventObj.$currentTarget;
    var type = eventObj.type;
    // Trigger the events associated with each declarative action listed on the current target
    var namedActions = declAction.split(' ');
    var eventPrefix = "a:declarative:";

    util.each(namedActions, function (action) {
      var options = actionOptions[action] || {};
      var data = $currentTarget.data(action);

      // Build up a normalized event object to pass into each declarative event callback
      var actionEventObj = util.extend({}, eventObj, {
        action: action,
        data: data
      });
      var eventGroupName = eventPrefix + action;
      var eventName = eventGroupName + ":" + type;

      events.trigger(eventGroupName, actionEventObj); // For backwards compatibility and to allow someone to just bind to all the events
      events.trigger(eventName, actionEventObj); // Allows someone to bind to a specific event

      if (!events.isListening(eventName)) {
        // WEBLAB: AUI_TNR_UNHANDLED_EVENTS_167823:T1
        // For declarative system, there have a chance that user handler is not
        // yet register on event bus through `A.declarative`, but the event is
        // already triggered on dom.
        eventAnalytics.handle($event); // check and log if we're interested in it.
      }

      if (shouldPreventDefault($target, $event, options, data)) {
        $event.preventDefault();
      }
    });
  }

  /**
   *  Delegate the declarative and gesture detection event handlers onto the document.
   */
  // WEBLAB: AUI_TNR_UNHANDLED_EVENTS_167823:T1
  pRecorderStop();
  $(document).delegate(DECLARATIVE_SELECTOR, constants.constants.declarativeEvents, handleEvent);
  $(document).delegate('.a-gesture', 'tap swipe swipe-horizontal swipe-vertical pan-horizontal pan-vertical doubleTap', handleEvent);

  /**
   *  Allow the user to register a new declarative event handler.  Example invocations:
   *
   *  declarative(actionNames, callback) -- Listen to all declarative events for the listed actions
   *  declarative(actionNames, events, callback) -- Listen to the enumerated declarative events for the listed actions
   *  declarative(actionNames, events, options, callback) -- Listen to the enumerated declarative events for the listed actions and configure the declarative response
   *
   *  @public
   *  @param {string} actionNames  A whitespace delimited list of action names to handle
   *  @param {string} events  A comma delimited list of browser events to handle
   *  @param {object} options  A hash of options which can be used to further refine when events are triggered or which default actions will be taken in response to the event
   *  @param {function} callback  The function executed in response to the event
   */
  var declarative = function declarative() {
    var actionNames, declEvents, options, fn;

    switch (arguments.length) {
    case 2:
      actionNames = arguments[0];
      fn = arguments[1];
      break;
    case 3:
      actionNames = arguments[0];
      declEvents = arguments[1];
      fn = arguments[2];

      break;
    case 4:
      actionNames = arguments[0];
      declEvents = arguments[1];
      options = arguments[2];
      fn = arguments[3];
    }

    if (!actionNames) {
      return;
    }

    if (typeof actionNames === 'string') {
      actionNames = util.trim(actionNames).split(" ");
    }

    // Store the current binding allows us to call `events.on` as if it were also bound to `A`. This
    // pipes through any error attribution settings on `A`.
    var self = this;

    // Add TNR handling to callback function.
    var tnrEnabledFn = tnr.wrapDeclarativeActionHandler(fn);

    util.each(actionNames, function (action) {
      var eventString = "a:declarative:" + action;
      actionOptions[action] = options || {};

      if (declEvents) {
        declEvents = typeof declEvents === 'string' ? util.trim(declEvents).split(" ") : declEvents;

        util.each(declEvents, function (declEvent) {
          events.on.call(self, eventString + ":" + declEvent, tnrEnabledFn);

          eventAnalytics.notifyDeclarativeAction(action, declEvent);
          declarativeAnalytics.notify(action, declEvent);
        });
      } else {
        events.on.call(self, eventString, tnrEnabledFn);
      }
    });
  };

  /**
   *  Add a declarative action to a DOM node.  Data attributes are not changed, but jQuery
   *  data cache is altered.
   *
   *  @public
   *  @param {object} dom  DOM object of the trigger
   *  @param {string} action  Name of the declarative action
   *  @param {object} data  (optional) The data associated with this declarative action
   *
   *  @return {object}  The possibly altered DOM node
   */

  function createDeclarative(dom, action, data) {
    var $dom = dom.jquery && dom.length ? dom : $(dom);

    if ($dom.length && action) {
      var existingAction = $dom.data("action");
      $dom.data("action", existingAction ? existingAction + " " + action : action)
        .data(action, data ? data : {});
      $dom.addClass(DECLARATIVE_CLASS);
    }
    return dom;
  }

  /**
   *  Remove the attributes necessary for a DOM node to trigger a declarative action.
   *  If an action name is supplied, only the data associated with that action will be remove.
   *  If no action is supplied, all action data will be removed.
   *
   *  @public
   *  @param {object} el  DOM element of the trigger
   *  @param {string} actionToRemove A whitespace delimited string of declarative actions to be removed. Defaults to removing all actions
   *  @return {object}  The possibly altered DOM node
   */

  function removeDeclarative(el, actionToRemove) {
      var $el = el.jquery && el.length ? el : $(el);
      if (!$el.length) {
          return el;
      }

      var dataActions = $el.data("action");
      if (!dataActions) {
          return el;
      }

      var remainingActions = dataActions.split(' ');

      // Case where user requests specific actions

      if (actionToRemove) {
          var actionsToRemove = actionToRemove.split(' ');
          util.each(actionsToRemove, function (action) {
              var ind = util.indexOfArray(remainingActions, action);
              if (ind >= 0) {
                  remainingActions.splice(ind, 1);
                  $el.data(action, null);
              }
          });
      }
      else {
          util.each(remainingActions, function (action) {
              $el.data(action, null);
          });
          // Removed all actions
          remainingActions = [];
      }

      if (remainingActions.length) {
          $el.data("action", remainingActions.join(" "));
      } else {
          $el.data("action", null).removeClass(DECLARATIVE_CLASS);
      }
      return el;
  }

  declarative.create = createDeclarative;
  declarative.remove = removeDeclarative;

  // WEBLAB: AUI_TNR_UNHANDLED_EVENTS_167823:T1
  timingAnalytics.stopWidgetLogging('declarative');

  return {
    declarative: declarative
  };
});
/////////////////////////
// END FILE a_declarative.js
/////////////////////////

// END ASSET AmazonUIBaseJS@declarative-3.2.15990.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS@preload", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS@preload-3.2.15990.0
/////////////////////////
// BEGIN FILE @js_debug_flag.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
var AUI_JS_DEBUG = true;
/////////////////////////
// END FILE @js_debug_flag.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_preload.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/* Importing flags/_is_dp_gw.js */
var isDpGw = false;
/* Done importing flags/_is_dp_gw.js */

/* Importing flags/_is_modernize_dp_gw_experiment.js */
var isModernizeDpGwExperiment = false;
/* Done importing flags/_is_modernize_dp_gw_experiment.js */


P.when(
  "3p-promise",
  "a-analytics",
  "a-util",
  "prv:a-preload-queue",
  "prv:a-preload-strategies"
).register("a-preload", function(Promise, analytics, util, waitForQueue, strategies) {
  var TIMEOUT = 2500; // milliseconds to wait before abandoning preload request

  /**
   * @return {Promise} Resolves after TIMEOUT milliseconds
   */
  function timeoutPromise() {
    return new Promise(function(resolve) {
      setTimeout(resolve, TIMEOUT);
    });
  }

  /**
   *
   * @param {String} url The asset url to load
   * @return {Promise}
   */
  function loadUrl(url, priority) {
    var startTime = Date.now();
    var strategy = strategies.getStrategy(url, priority);
    var runner = strategy(url, priority);

    var promise = Promise.race([runner.promise, timeoutPromise()]).then(
      function() {
        analytics.increment("preload_fulfilled");
        return {
          url: url,
          success: true,
          duration: Date.now() - startTime
        };
      },
      // ".catch"
      function(reason) {
        analytics.increment("preload_failed");
        return {
          url: url,
          success: false,
          reason: reason
        };
      }
    );
    if (runner.teardown) {
      promise.then(runner.teardown);
    }
    return promise;
  }

  /**
   * Process a list of Urls. Will recurse if the list contains other lists.
   * Return schema was carried over from the previous implementation.
   * @param {String|Array} urls URL or URLs to preload
   * @param {Boolean} priority True: load before page-load. False: load after.
   * @return {Promise} Resolves after all URLs have been processed.
   */
  function preload(urls, priority) {
    // It's a string! Ostensibly, it's also a URI.
    if (typeof urls === "string") {
      // Empty urls result in requesting of the hosting page is nonsensical,
      // and in the chance that the page is somehow executed, will cause a DDOS.
      if (!urls.trim()) {
        return Promise.resolve();
      }
      analytics.increment("preload_asks");
      return waitForQueue(priority).then(function(done) {
        // Wait for an available preloader
        return loadUrl(urls, priority).then(done); // Preload the asset, then free the preloader.
      });
    }

    // We only support Strings and Arrays.
    if (!util.isArray(urls)) {
      return Promise.reject("not an URL or URL list");
    }

    return Promise.all(
      urls.map(function(url) {
        return preload(url, priority);
      })
    );
  }

  return {
    preload: preload
  };
});

/**
 * Please take a number and we'll be with you shortly.
 * `waitForQueue` returns a Promise which represents
 * your place in the queue. When your number is called,
 * the promise resolves with a "done" callback. What
 * you do next is up to you, but you must call `done`
 * when you are finished.
 *
 * var myBusinessLogicPromise = waitForQueue().then(function (done) {
 *   return myBusinessLogicAsync().then(done).catch(done);
 * });
 * myBusinessLogicPromise.then(function (myBusinessLogicResult) {
 *   alert('My result is', myBusinessLogicResult);
 * });
 *
 * As a courtesy, the "done" callback returns the values
 * passed to it. In the example, `.then(done)` returns
 * the resolved output of `myBusinessLogicAsync`.
 */
P.when("3p-promise").register("prv:a-preload-queue", function(Promise) {
  // Allow the loadLimit to be overriden in testing, but in production the value is constant
  var loadLimit = AUI_JS_DEBUG && typeof window.plCount === "function" ? window.plCount() : 5;
  var primaryQueue = []; // Executes before page load
  var secondaryQueue = []; // Executes after page load
  var isAfterLoad = false;
  P.when("afterLoad").execute(function() {
    isAfterLoad = true;
    for (var i = loadLimit; i > 0; i--) {
      dequeue();
    }
  });

  // TODO: Update preload queue to not have a limit if we're using HTTP2?
  // TODO: Disable afterLoad if we have prefetch enabled?

  /**
   *
   * @param {Boolean} priority Run now, or after page load?
   * @return {Promise} Resolves when your turn is ready.
   */
  function waitForQueue(priority) {
    return new Promise(function(resolve) {
      randomInsert(priority ? primaryQueue : secondaryQueue, resolve);
      dequeue();
    }).then(function ready() {
      return function done(result) {
        free();
        return result;
      };
    });

    function free() {
      free = function() {}; // Run once.
      loadLimit++;
      dequeue();
    }
  }

  function dequeue() {
    if (!loadLimit) return;

    // prettier-ignore
    var queue = (
      primaryQueue.length ? primaryQueue
      : isAfterLoad ? secondaryQueue
      : []
    );

    var starter = queue.pop();
    if (!starter) return;
    loadLimit--;
    starter();
  }

  function randomInsert(list, item) {
    list.splice(Math.round(Math.random() * list.length), 0, item);
  }

  return waitForQueue;
});

P.when("3p-promise", "a-util").register("prv:a-preload-strategies", function(Promise, util) {
  // Technically, we should not rely on file extension to determine the type of content, since mime type is what's
  // supposed to govern that. However, in our usage scenarios, it's good enough.
  // If the detection is incorrect then CORB will error.
  function getExtension(url) {
    var matches = /^(?:[^?#]+)[.]([a-z2]+)(?:[?#].*)?$/.exec(url);
    return (matches && matches[1]) || "";
  }

  /**
   * Guess the correct type to preload "as".
   * Please investigate: https://i.amazon.com/issues/AUI-18055
   * @param {String} url Asset URL
   * @return {String} Best-guess for preload "as" value.
   */
  function getLinkAs(url) {
    var extension = getExtension(url);
    if (extension === "js") return "script";
    if (extension === "css") return "style";
    if (/^gif|jpe?g|png$/.test(extension)) return "image";
    if (/^woff2?$/.test(extension)) return "font";
    return "fetch";
  }

  function isCrossOriginLocation(url, location) {
    // This regex handles these cases:
    // https://same-hostname.com/path (same protocol, same hostname)
    // //same-hostname.com/path (protocol relative, same hostname)
    var sameOriginRegex = new RegExp("^(" + location.protocol + ")?//" + location.hostname + "/");
    // This regex matches all urls except for the path-relative cases:
    // /root-relative-path (path does not have a protocol or hostname)
    // relative-path (path does not have a protocol or hostname)
    var notPathRelativeRegex = /^(https?:|[/][/])/;
    // All other urls are considered cross origin.

    return !sameOriginRegex.test(url) && notPathRelativeRegex.test(url);
  }

  function isCrossOriginContentType(url, contentType) {
    // By spec, fonts are required to use the "cors" fetch method
    // https://drafts.csswg.org/css-fonts/#font-fetching-requirements
    // https://github.com/w3c/preload/issues/32
    if (contentType == "font") {
      return true;
    }

    // P.load.js() uses crossOrigin to get stack traces in JavaScript
    // https://code.amazon.com/packages/AmazonUIPageJS/blobs/37dbeea6ca1567f251c49b9f619211a4dc21a108/--/src/_load.js#L101-L103
    if (contentType == "script") {
      return isCrossOriginLocation(url, window.location);
    }

    return false;
  }

  var canFetch = !!window.fetch;
  var canPreload = false;
  var canPrefetch = false;
  (function() {
    try {
      var link = document.createElement("link");
      canPreload = link.relList.supports("preload");
      canPrefetch = link.relList.supports("prefetch");
    } catch (e) {
      // already defaulted to false
    }
  })();

  function removeElement(element) {
    if (element && element.parentElement) {
      element.parentElement.removeChild(element);
    }
  }

  function buildLinkStrategy(relationship) {
    return function (url) {
      var loader = document.createElement("link");
      return {
        promise: new Promise(function(resolve, reject) {
          try {
            var loadAs = getLinkAs(url);
            loader.rel = relationship;
            loader.as = loadAs;
            if (isCrossOriginContentType(url, loadAs)) {
              loader.crossOrigin = "anonymous";
            }

            loader.href = url;
            loader.onerror = loader.onload = resolve;
            document.head.appendChild(loader);
          } catch (e) {
            reject("failed to preload link loader");
          }
        }),
        teardown: function() {
          removeElement(loader);
        }
      };
    };
  }

  /**
   * There are separate strategies for prefetch and preload since browser
   * support varies by relationship type.
   */
  var linkPrefetchStrategy = canPrefetch ? buildLinkStrategy("prefetch") : function() {};
  var linkPreloadStrategy = canPreload ? buildLinkStrategy("preload") : function() {};

  function imageStrategy(url) {
    var loader = new Image();
    return {
      promise: new Promise(function(resolve, reject) {
        try {
          loader.style.display = "none";
          // This doesn't check isCors() as <img> effectively never use CORS
          loader.onerror = loader.onload = resolve;
          loader.src = url;
          document.documentElement.appendChild(loader);
        } catch (e) {
          reject("failed to preload image loader");
        }
      }),
      teardown: function() {
        removeElement(loader);
      }
    };
  }

  function xhrStrategy(url) {
    return {
      promise: new Promise(function(resolve, reject) {
        try {
          var request = new XMLHttpRequest();
          request.open("GET", url, true);
          request.onreadystatechange = function() {
            if (this.readyState == 4) resolve();
          };
          request.send();
        } catch (e) {
          reject("failed to preload ajax loader");
        }
      })
    };
  }

  function fetchStrategy(url) {
    return {
      promise: new Promise(function(resolve, reject) {
        try {
          var contentType = getLinkAs(url);
          var options = {
            // https://developer.mozilla.org/en-US/docs/Web/API/Request/mode
            mode: (isCrossOriginContentType(url, contentType)) ? "cors" : "no-cors"
          };
          window.fetch(url, options).finally(resolve);
        } catch (e) {
          reject("failed to preload fetch loader");
        }
      })
    };
  }

  function getStrategy(url, priority) {
    var fetchAs = getLinkAs(url);

    // Use <link rel="prefetch"> on supported browsers
    // NOTE: This will download with a "low" priority from the CDN
    // with the expectation that the object WILL NOT be used for this page load
    // https://caniuse.com/#feat=link-rel-prefetch
    if (
      (isModernizeDpGwExperiment && isDpGw)
      && canPrefetch && !priority
    ) {
      return linkPrefetchStrategy;
    }

    // Use <link rel="preload"> on supported browsers
    // NOTE: This will download with a "high" priority from the CDN
    // with the expectation that the object WILL be used for this page load
    // https://caniuse.com/#feat=link-rel-preload
    if (canPreload && priority) {
      return linkPreloadStrategy;
    }

    // Use image tags to send the right Accept headers
    if (fetchAs === "image") {
      return imageStrategy;
    }

    // Fetch is preferable to XHR as it provides finer control over requests
    if (canFetch) {
      return fetchStrategy;
    }

    // Fallback to XHR for legacy browsers
    return xhrStrategy;
  }

  // Publicly exported functions
  var api = {
    getStrategy: getStrategy
  };

  // Export helper functions for unit testing
  if (AUI_JS_DEBUG) {
    util.mixin(api, {
      getExtension: getExtension,
      getLinkAs: getLinkAs,
      isCrossOriginLocation: isCrossOriginLocation,
      isCrossOriginContentType: isCrossOriginContentType,
      removeElement: removeElement,

      fetchStrategy: fetchStrategy,
      imageStrategy: imageStrategy,
      linkPreloadStrategy: linkPreloadStrategy,
      linkPrefetchStrategy: linkPrefetchStrategy,
      xhrStrategy: xhrStrategy,
    });
  }

  return api;
});
/////////////////////////
// END FILE a_preload.js
/////////////////////////

// END ASSET AmazonUIBaseJS@preload-3.2.15990.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS@touch", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS@touch-3.2.15990.0
/////////////////////////
// BEGIN FILE @js_debug_flag.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
var AUI_JS_DEBUG = true;
/////////////////////////
// END FILE @js_debug_flag.js
/////////////////////////
/////////////////////////
// BEGIN FILE touchpress/a_touchpress.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Nothing to see here (no touchpress for desktop)
/////////////////////////
// END FILE touchpress/a_touchpress.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_touch_recognize.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE a_touch_recognize.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_touch.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE a_touch.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_touch_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE a_touch_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_immersive_image.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE a_immersive_image.js
/////////////////////////

// END ASSET AmazonUIBaseJS@touch-3.2.15990.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS@A", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS@A-3.2.15990.0
/////////////////////////
// BEGIN FILE @js_debug_flag.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
var AUI_JS_DEBUG = true;
/////////////////////////
// END FILE @js_debug_flag.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_ending.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Ending
 */

"use strict";

/**
 * Wait for all of the core libraries to register and collect them into the
 * standard A object that people will use when depending on "A".
 */
P.when("a-timing-analytics", "a-bodyBegin").execute('build-A', function (timingAnalytics) {
    // Make sure the 'decorate' function exists in case someone is running an old version of Page JS (sigh).
    var enableDecorator = P.execute().decorate;

    //Checks if the property key is a private capability, and if it is, log a CSM metric and a descriptive console error
    function checkAndLogBadCapabilitiesUsage(prop) {
      P.when("prv:a-capabilities", "a-analytics").execute(function(privateCapabilities, analytics) {
        function checkAndLog(prop) {
          if (privateCapabilities.hasOwnProperty(prop)) {
            P.log("WARNING: The property on A.capabilities you are accessing: '" + prop.toString() + "' is undocumented, and not guaranteed to be correct right now or to stick around in future versions of AUI. Use at your own risk.");
            analytics.tag("capabilitiesUnsafeAccess:" + prop.toString());
          }
        }
        checkAndLog(prop);
        checkAndLogBadCapabilitiesUsage = checkAndLog;
      });
    }

    //Function that, if in debug mode, sets up a Proxy to detect when clients use hidden/less-reliable parts of A.capabilities
    //these capabilities are stored in privateCapabilities for usage by other aui-internal components
    function attachBadCapabilitiesUsageTracker(A) {
      if (AUI_JS_DEBUG) {
        try {
          A.capabilities = new Proxy(A.capabilities, {
            get: function (target, prop) {
              checkAndLogBadCapabilitiesUsage(prop);
              return target[prop];
            }
          });
        } catch (e) {}
      }
    }

    var registered = P.when(
        "a-util", "a-defer", "a-base", "a-events", "a-declarative",
        "a-state", "a-ajax", "a-animate", "a-image", "a-constants", "a-detect",
        "a-browser-events", "a-preload", "a-prefix", "a-request-animation-frame",
        "a-class", "a-draggable"
    ).register("A", function (util) {

        // Hold injected modules that have constructors to extend the instance of A instead of A's prototype
        var hasConstructor = [];

        function A(guard, logError, callerName) {
            this._guard = guard;
            this._logError = logError;

            util.each(hasConstructor, function (component) {
                util.extend(this, new component.constructor(guard, logError));
            }, this);

            //if we are constructing A, track bad capabilities usage after all properties are set up
            if (enableDecorator) {
              attachBadCapabilitiesUsageTracker(this);
            }
        }

        A.prototype = {};

        util.each(arguments, function (component) {
            // If we don't have decorator support, or the component doesn't have a constructor, simply extend A's
            // prototype. Otherwise add them to a collection to be handled in A's constructor
            if (!enableDecorator || component.constructor === Object) {
                delete component.constructor;
                util.extend(A.prototype, component);
            } else {
                hasConstructor.push(component);
            }
        });

        //if we don't have a decorator, setup tracking of bad capabilities usage now
        if (!enableDecorator) {
            attachBadCapabilitiesUsageTracker(A.prototype);
        }

        // WEBLAB: AUI_TNR_UNHANDLED_EVENTS_167823:T1
        timingAnalytics.stopWidgetLogging('A');

        // Default to the old behavior, which is to access the object of methods directly
        return enableDecorator ? A : A.prototype;
    });

    if (enableDecorator) {
        registered.decorate(function (A, caller) {
            // This function is invoked every time someone has a dependency on 'A'.
            // The 'caller' argument you see above has information about who is
            // using 'A', which gives us the opportunity to add attribution
            // information whenever we invoke someone else's function.
            return new A(caller.guard, caller.logError);
        });
    }

});
/////////////////////////
// END FILE a_ending.js
/////////////////////////

// END ASSET AmazonUIBaseJS@A-3.2.15990.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIButton@buttonJS", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIButton@buttonJS-3.2.16914.0
/////////////////////////
// BEGIN FILE button.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Button API
 */

'use strict';


/**
 *  Button API which allows users to select buttons and act on them.
 */

P.when('A', 'a-component').register('a-button', function (A, component) {

    var DISABLED_CLASS = 'a-button-disabled';
    var FOCUS_CLASS = 'a-button-focus';
    function eventHandler (event) {
        event.preventDefault();
    }



    /**
     * Constructor for Button Input
     *
     * @param {String} selector
     * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
     */
    var Button = component.create({
        _componentName: 'button',
        init: function (selector, context) {
            this._super(selector, context);

            this._$element = this._$element.filter('.a-button');
            this._$coreFormElement = this._$element.children('.a-button-inner').children('button,input');
            this._$coreLinkElement = this._$element.children('.a-button-inner').children('a');
            this._$contentElement = this._$element.find('.a-button-text');
        },

        mixin: ['show', 'hide', 'toggle', 'isEmpty', 'size', 'on', 'off', 'trigger'],

        /**
         * Enable the button
         */
        enable: function () {
            this._$element.removeClass(DISABLED_CLASS);
            this._$coreFormElement.prop('disabled', false);
            this._$coreLinkElement.unbind('click', eventHandler);

            return this;
        },

        /**
         * Disable the button
         */
        disable: function () {
            this._$element.addClass(DISABLED_CLASS).removeClass(FOCUS_CLASS);
            this._$coreFormElement.prop('disabled', true);
            this._$coreLinkElement.click(eventHandler);

            return this;
        },

        /**
         * Return whether the button is enabled
         * @return {boolean}
         */
        isEnabled: function () {
            // We are assuming the core(Form/Link)Element piece of the button is in sync here.
            // If they are using our api the DISABLED_CLASS can be the source of truth.
            return !this._$element.hasClass(DISABLED_CLASS);
        },

        /**
         * Sets the button's status
         * @param newStatus - The new status value to set
         */
        setStatus: function (newStatus) {
            var $el = this._$element;
            var validStatuses = [null, "normal", "selected", "disabled", "error", "inactive"];
            var isStatusInvalid = A.indexOfArray(validStatuses, newStatus) < 0;
            var isInGroup = $el.attr('role') === 'radio';

            var removeOldStatus = function (status) {
                $el.removeClass('a-button-' + status);
            };
            var setAriaChecked = function (ind, currentAriaChecked) {
                return isInGroup ? newStatus === 'selected' : currentAriaChecked;
            };

            if (isStatusInvalid) {
                P.error(newStatus + " is not a valid status");
                return false;
            }

            A.each(validStatuses, removeOldStatus);

            this._$coreFormElement.prop('disabled', newStatus === 'disabled');
            $el.attr('aria-checked', setAriaChecked);

            if (newStatus !== null) {
                $el.addClass('a-button-' + newStatus);
            }
            return this;
        },

        /**
        * Return the button text
        * @return {string|object}
        */
        text: function (text) {
            if (this._$contentElement.length < 1 ) {
                return;
            }
            if (typeof text === 'undefined') {
                return this._$contentElement.text();
            } else {
                this._$contentElement.text(text);
            }
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Button(selector, context);
    };
});
/////////////////////////
// END FILE button.js
/////////////////////////
/////////////////////////
// BEGIN FILE toggle_button.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Toggle Button API
 */

'use strict';


/**
 *  Button API which allows users to select buttons and act on them.
 */

P.when('A', 'a-component').register('a-toggle-button', function (A, component) {

  var DISABLED_CLASS = 'a-button-disabled';
  var UNAVAILABLE_CLASS = 'a-button-unavailable';
  var SELECTED_CLASS = 'a-button-selected';
  var FOCUS_CLASS = 'a-button-focus';
  var validStatusClasses = [SELECTED_CLASS, FOCUS_CLASS];

  /**
   * prevents default behaviour of link
   * @param  {Object} event - An event object passed into link click handler callback
   */
  function preventDefault (event) {
    event.preventDefault();
  }

  /**
   * Remove valid status classes for toggle button
   * @param {Object} Button
   */
  function removeValidStatusClass(button) {
    A.each(validStatusClasses, function(statusClass) {
      button._$element.removeClass(statusClass);
    }, button);
  }

  /**
   * Checks whether button is empty or not
   *
   * @param {Object} Button
   * @param {boolean} returns true if button is empty
   */
  function isEmpty(button) {
    return (button._$element.length === 0 || button._$coreFormElement.length === 0);
  }

  /**
   * Constructor for Button Input
   *
   * @param {String} selector
   * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
   */
  var ToggleButton = component.create({
    _componentName: 'toggleButton',
    init: function (selector, context) {
      this._super(selector, context);
      this._$element = this._$element.filter('.a-button');
      this._$coreFormElement = this._$element.find('.a-button-inner').find('button,input');
      this._$coreLinkElement = this._$element.find('.a-button-inner a');
    },

    /**
     * get name of the toggle button
     * @return {String} toggle button name
     */
    name: function() {
      return this._$coreFormElement.attr('name');
    },

    /**
     * Enable the Toggle Button
     */
    enable: function () {
      this._$element.removeClass(DISABLED_CLASS);
      this._$coreFormElement.prop('disabled', false);
      // Links can not be disabled using disabled property.
      // To disable the link , default clickable behaviour is prevented when buttons are disabled.
      // For resuming the default clickable behaviour, unbind click event from link
      this._$coreLinkElement.unbind('click', preventDefault);
      return this;
    },

    /**
     * Disable the toggle button
     */
    disable: function () {
      removeValidStatusClass(this);
      this._$element.addClass(DISABLED_CLASS);
      this._$coreFormElement.prop('disabled', true);
      // Links can not be disabled using disabled property.
      // To disable the link , default clickable behaviour is prevented in click handler when buttons are disabled.
      this._$coreLinkElement.click(preventDefault);
      return this;
    },

    /**
     * Set available toggle button
     */
    setAvailable: function() {
      this._$element.removeClass(UNAVAILABLE_CLASS);
      return this;
    },

    /**
     * Set unavailable toggle button
     * @return {Object} Button object
     */
    setUnavailable: function() {
      this._$element.addClass(UNAVAILABLE_CLASS);
      return this;
    },

    /**
     * Checks whether the button is enabled
     * @return {boolean}
     */
    isEnabled: function () {
      return !isEmpty(this) && !this._$element.hasClass(DISABLED_CLASS);
    },

    /**
     * set toggle button as selected
     * @return {Object} button
     */
    setSelected: function() {
      if(!isEmpty(this) && this.isEnabled()) {
        this._$element.addClass(SELECTED_CLASS + ' ' + FOCUS_CLASS).attr("aria-checked", "true");
      }
      return this;
    },

    /**
     * set toggle button unselected
     * @return {Object} Button object
     */
    setUnselected: function () {
      removeValidStatusClass(this);
      this._$element.attr("aria-checked", "false");
      return this;
    },

    /**
     * Checks whether the button is selected
     * @return {boolean}
     */
    isSelected: function() {
      return !isEmpty(this) && this._$element.hasClass(SELECTED_CLASS);
    },

    /**
     * Checks whether the button is available
     * @return {boolean}
     */
    isAvailable: function() {
      return !isEmpty(this) && !this._$element.hasClass(UNAVAILABLE_CLASS);
    }
  });

  /**
   * Public factory function
   */
  return function (selector, context) {
    return new ToggleButton(selector, context);
  };
});
/////////////////////////
// END FILE toggle_button.js
/////////////////////////
/////////////////////////
// BEGIN FILE toggle_button_group.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AUI Toggle buttons API
 */

'use strict';

/**
 *  Toggle Buttons API which allows users to select button and act on them.
 */

 P.when('A', 'a-component', 'a-toggle-button').register('a-toggle-button-group', function(A, component, getToggleButton) {

  /**
   * Constructor for Toggle button group
   *
   * @param {String} selector
   * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
   */
  var ToggleButtonGroup = component.create({

    _componentName: 'toggleButtonGroup',

    init: function(selector, context) {
      var buttonGroupData;
      this._super(selector, context);
      this._$toggleGroupElement = this._$element.filter('.a-button-group, .a-button-toggle-group').eq(0);
      buttonGroupData = this._$toggleGroupElement.data('a-button-group');
      this._$toggleGroupName = buttonGroupData ? buttonGroupData.name : undefined;
    },

    /**
     * get name of the toggle button group
     * @return {String} toggle button
     */
    name: function() {
      return this._$toggleGroupName;
    },

    /**
     * Returns button object based on button name
     * @param  {String} buttonName
     * @return {Object} toggle button object created using buttonName
     */
    getToggleButtonByName: function(buttonName) {
      return this.getToggleButtonBySelector('.a-button:has([name=' + buttonName +'])');
    },

    /**
     * set selected Button
     * @param  {String} buttonSelector
     */
    setSelected: function(buttonSelector) {
      var toggleButton = this.getToggleButtonBySelector(buttonSelector);
      if(toggleButton.isEnabled()) {
        this.getSelected().setUnselected();
        toggleButton.setSelected();
      }
      return this;
    },

    /**
     * returns the selected toggle button object
     * @return {Object} toggle button
     */
    getSelected: function() {
      return this.getToggleButtonBySelector('.a-button.a-button-selected');
    },

    /**
     * get Toggle button object using selector
     * @param  {string} selector
     * @return {Object} Toggle button object
     */
    getToggleButtonBySelector: function(selector) {
      return getToggleButton(this._$toggleGroupElement.find(selector));
    }
  });

  /**
   * Public factory function
   */
  return function (selector, context) {
    return new ToggleButtonGroup(selector, context);
  };
});
/////////////////////////
// END FILE toggle_button_group.js
/////////////////////////

// END ASSET AmazonUIButton@buttonJS-3.2.16914.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIFont", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIFont-3.2.9428.0
/////////////////////////
// BEGIN FILE js/fonts/a_fonts.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Very simple polyfill for CSS Font Loading API [1]. This module will use
 * browser's built-in font loading API if available. The polyfilled version
 * can only load fonts - it does not pass FontFace array to the promise as
 * specified in the draft.
 *
 * The CSS Font Loading API is still in draft and so far only Chrome, Opera,
 * and Firefox support it.
 *
 * TODO:
 *   1. We should look back here when the API is finalised and modify the
 *      behaviour accordingly, though most of the features should
 *      have been stable.
 *   2. We should implement a polyfill for FontFace
 *   3. Implement rejects properly
 *
 * Current API:
 *   - a-fonts.load (polyfills document.fonts.load)
 *       Loads the supplied font strings (e.g. '1em Amazon Ember' or
 *       'italic lighter 1em Amazon Ember') and returns a promise.
 *       The polyfill part will not reject
 *   - a-fonts.check (polyfills document.fonts.check)
 *       Checks whether the font variant is available and returns true if so
 *   - a-fonts.ready (polyfills document.fonts.ready)
 *       Checks whether ALL fonts loaded with a-fonts.load is available and
 *       returns a promise. Never rejects
 *
 * This module does not replace the browser built-in font loading API if available.
 * It also makes uses of the Promise polyfill by jasjon@.
 *
 * Related: MDN CSS Font Loading API [2]
 *
 * [1] https://drafts.csswg.org/css-font-loading/
 * [2] https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API
 */
P.when('jQuery', 'A', '3p-promise').register('a-fonts', function ($, A, Promise) {
  // CSS Font Loading API statuses
  var STATUS_UNLOADED = 'unloaded';
  var STATUS_LOADING = 'loading';
  var STATUS_LOADED = 'loaded';

  // Stack for monospace fonts for font width comparison
  var MONOSPACE_FONT_STACK = 'Consolas, "Courier New", Courier, monospace';
  var FONT_CHECK_INTERVAL = 50;

  var _fontSet = [];
  var _$body = $('body');

  /**
   * Attempts to load font string. Returns a promise.
   * The polyfill version will not reject. This will be look Into
   * soon.
   *
   * @param variant Font string to load. It should be in the format of
   *                "[style] [variant] [weight] [size] [family]". For
   *                example, "italic 1em Amazon Ember"
   * @return Promise. Polyfill version will not reject at this time.
   */
  var loadFont = function (variant) {
    return new Promise(function (fulfill, reject) {
      // Push new font variant set
      var newFont = {
        variant: variant,
        status: STATUS_UNLOADED
      };

      _fontSet.push(newFont);

      // Create an invisible DOM element to load the font
      newFont.$loader = $('<span>.</span>', { 'class': 'aok-hidden' })
          .css('font', newFont.variant)
          .appendTo(_$body);
          
      newFont.status = STATUS_LOADING;

      // Initialise a checker DOM. This is used for width comparison to
      // determine whether the font has been loaded.
      newFont.$checker = $('<span>.</span>', { 'class': 'aok-hidden' })
          .appendTo(_$body);

      // Periodically check the load status
      newFont.intervalId = window.setInterval(function () {
        newFont.$checker.css('font', newFont.variant + ', ' + MONOSPACE_FONT_STACK);
        
        var width = newFont.$checker.width(),
            height = newFont.$checker.height();

        newFont.$checker.css('fontFamily', MONOSPACE_FONT_STACK);

        if (newFont.$checker.width() !== width || newFont.$checker.height() !== height) {
          fulfill(newFont.variant);

          newFont.status = STATUS_LOADED;

          // Clean up
          newFont.$loader.remove();
          newFont.$checker.remove();
          clearInterval(newFont.intervalId);
        }
      }, FONT_CHECK_INTERVAL);
    });
  };

  /**
   * Check if the specified font string is available.
   *
   * @param variant Font string to load. It should be in the format of
   *                "[style] [variant] [weight] [size] [family]". For
   *                example, "italic 1em Amazon Ember"
   * @return True if available; false if otherwise.
   */
  var checkFont = function (variant) {
    A.each(_fontSet, function (font) {
      if (font.variant === variant) {
        return font.status === STATUS_LOADED;
      }
    });

    return false;
  };

  /**
   * Check if all fonts loaded with load() has been loaded.
   * Note that this is a property, not a function. This property
   * itself is a promise. It resolves when all fonts are loaded,
   * and will never reject.
   */
  var onFontsReady = (function () {
    return new Promise(function (fulfill, reject) {
      var readyIntervalId = window.setInterval(function () {
        var loadStatus = A.reduce(_fontSet, function (prev, cur) {
          return prev && cur.status === STATUS_LOADED;
        }, true);
        
        if (loadStatus) {
          fulfill();
          clearInterval(readyIntervalId);
        }
      }, FONT_CHECK_INTERVAL);
    });
  }());
  
  
  // Factory function for determining whether to use native or polyfills
  var polyfillFunctions = {
    load: loadFont,
    check: checkFont,
    ready: onFontsReady
  };
  
  var native = document.fonts;
  function getPolyfill(fontFunction, polyfill) {
    var fonts = (native && native[fontFunction]) ? native : polyfill;
    
    return function () {
      return fonts[fontFunction].apply(fonts, arguments);
    };
  }

  var polyfillReady = onFontsReady;
  if (native && native.ready) {
    // New CSS font loading API's `document.fonts.ready` is a Promise object,
    // but older Chrome implemented it as `.ready()` that returns a Promise object
    polyfillReady = native.ready.then ? native.ready : native.ready.apply(native);
  }
    
  return {
    load: getPolyfill('load', polyfillFunctions),
    check: getPolyfill('check', polyfillFunctions),
    ready: polyfillReady
  };
});
/////////////////////////
// END FILE js/fonts/a_fonts.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/fonts/a_font_loader.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * See also: a-fonts module for the font loading mechanism.
 */
P.when('A', 'a-fonts', 'prv:a-capabilities', 'load').register('prv:a-custom-font-loader', function (A, fonts, privateCapabilities) {
  var LOCAL_STORAGE_KEY = 'a-font-class';

  // get the currently loaded fonts from localStorage
  function getFontsLoaded() {
    return A.localStorage.getItem(LOCAL_STORAGE_KEY) || '';
  }

  return function fontLoader(fontClass, fontVariantList) {
    // We block UC Browser for now, it's triggering too many script errors
    if (privateCapabilities.isUCBrowser) {
      return;
    }

    // No need to do anything else if localStorage is not available
    if (!A.localStorage) {
      return;
    }

    // if the font is already loaded dont do anything
    if (A.indexOfArray(getFontsLoaded().split(' '), fontClass) !== -1) {
      return;
    }

    fonts.ready.then(function(font) {
      // add the font to localStorage once the font is ready
      var loaded = getFontsLoaded();
      loaded += (loaded.length ? ' ' : '') + fontClass;
      A.localStorage.setItem(LOCAL_STORAGE_KEY, loaded);
    });

    // kick off font loading process
    A.each(fontVariantList, function(fontVariant) {
      fonts.load(fontVariant);
    });
  };
});
/////////////////////////
// END FILE js/fonts/a_font_loader.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/fonts/a_font_stack.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('prv:a-custom-font-loader').execute('a-ember-loader', function (fontLoader) {
  fontLoader('a-ember', [
    '1em Amazon Ember',
    'bold 1em Amazon Ember',
    'italic 1em Amazon Ember',
    'italic bold 1em Amazon Ember'
  ]);
});
/////////////////////////
// END FILE js/fonts/a_font_stack.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/font.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Intentionally empty
/////////////////////////
// END FILE js/font.js
/////////////////////////

// END ASSET AmazonUIFont-3.2.9428.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICarousel", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUICarousel-3.2.16640.0
/////////////////////////
// BEGIN FILE js/carousel_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Constants
 *
 */

"use strict";

P.declare("a-carousel-constants", {
  ANIMATING: "animating", // Transition strategy actually animating
  ANIMATION_SPEED: "animation_speed",
  AUTO_ADJUST_HEIGHT: "auto_adjust_height",
  CIRCULAR: "circular",
  CURRENT_PIXEL: "px",
  CURRENTLY_WRAPPING: "currentlyWrapping",
  DELAY_TIME: "delay_time",
  ELEMENT_CSS_CLASS: "elementCssClass", // Adds element CSS class to client side empty cards
  FETCHED_ITEMS: "fetchedItems",
  FIRST_VISIBLE_ITEM: "firstVisibleItem",
  HIDE_OFF_SCREEN: "hide_off_screen",
  INIT_EVENTS: 'a:pageUpdate beforeReady',
  LOADING: "loading", // Transition strategy replacing loading placeholder with actual cards
  MIN_GUTTER: "minimum_gutter_width",
  NAME: "name",
  NO_TRANSITION: "no_transition",
  PAGE_NUMBER: "pageNumber",
  PAGE_SIZE: "pageSize",
  PEEK_GRADIENT: "peek_gradient",
  PEEK_PERCENTAGE: "peek_percentage",
  PEEK_WIDTH: "peek_width",
  SET_SIZE: "set_size",
  SPRINGINESS: "springiness",
  STATIC_LOADER_CSS_CLASS: "staticLoaderCssClass", // Provides div with CSS class for client side empty cards (currently not compatible with empty server side cards)
  TOTAL_PAGES: "totalPages",
  TOUCH_EASING: "touch_easing",
  TRANSITION_STRATEGY: "transitionStrategy",
  DISPLAY_STRATEGY: "displayStrategy",
  WRAP_EASING: "wrap_easing",
  TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX: "transitionSlideCircularFirstCardIndex"
});
/////////////////////////
// END FILE js/carousel_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('jQuery').register("a-carousel-utils", function ($) {
  /**
   *  Convenience function for determining if something's a string
   *
   *  @public
   *  @param {Object} a
   *
   *  @returns {Boolean}
   */

  function isString(a) {
    return typeof a === "string";
  }

  /**
   *  Convenience function to test if an object is an HTMLElement or a DocumentFragment in a way
   *  that won't cause IE 6 to have a seizure.
   *
   *  @public
   *  @param {Object} a
   *
   *  @returns {Boolean}
   */

  function isElement(a) {
    return a && a.nodeType !== undefined;
  }

  /**
   *  There are several different acceptable formats for carousel card content to come back from the AJAX strategy.
   *  This abstracts fetching that data from the fetchedItems array elements.
   *
   *  @public
   *  @param {Object} item - The fetchedItems element to pull content from
   *
   *  @returns {String|Element|DocumentFragment}
   */

  function getElementFromItem(item) {
    // We are sanitizing input and if we get all whitespace and trim it, we trim down to ""
    // Type conversion in JS (!!"") results in false, which has us return null, which means
    // we dont insert anything and leave the previous slot as it was before in swap carousels.
    // Previous/desired behavior was to output an empty slot, so this if restores that.
    if (item === "") {
      return "<div></div>";
    }
    if (!item) {
      return null;
    }
    if (isString(item) || isElement(item)) {
      return item;
    }
    return getElementFromItem(item.content);
  }

  /**
   *  After we add the content to the DOM nodes, we don't need to keep that content in memory for this
   *  transition strategy.  So, set the content to the boolean true
   *
   *  @public
   *  @param {Obejct} item - The fetchedItems element to pull content from
   *
   *  @returns {Object}
   */

  function clearElementFromItem(item) {
    if (item) {
      if (isString(item) || isElement(item)) {
        item = true;
      } else {
        item.content = clearElementFromItem(item.content);
      }
    }
    return item;
  }

  /**
   *  Different actions need to be taken to add content to the DOM depending on the type of the content generated.
   *
   *  @public
   *  @param {object} $dom - The jQuery wrapped DOM node we'll be dumping content in to
   *  @param {string|HTMLElement|DocumentFragment} element  The content to be added
   */

  function addElementToDom($dom, element) {
    if (element) {
      if (isString(element)) {
        $dom.html(element);
      } else if (isElement(element)) {
        if ($(element).hasClass("a-carousel-card-fragment")) {
          // .append() moves the original element, and doesn't clone it
          // We want to make sure that the element remains part of the fetchedItems for subsequent swaps
          // https://issues.amazon.com/issues/AUI-24545
          var $elementClone = $(element).clone();
          $dom.empty().append($elementClone.contents());
        } else {
          $dom.empty().append(element);
        }
      }
      if (element !== true) {
        $dom.removeClass("a-carousel-card-empty");
      }
    }
  }


  return {
    addElementToDom: addElementToDom,
    clearElementFromItem: clearElementFromItem,
    getElementFromItem: getElementFromItem,
    isElement: isElement,
    isString: isString
  };
});
/////////////////////////
// END FILE js/carousel_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_circular_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.register('a-carousel-circular-utils', function () {
    /**
     *  Makes a rotation function. 1 for clockwise and -1 for counter-clockwise
     *
     *  @param {number} direction
     */
    function makeRotate(direciton) {
        var clockwise = direciton > 0;

        return function rotate($parent, $elements, quantity) {
            quantity = quantity || 1;
            var length = $elements.length;
            var rotations = quantity % length;

            var parentElement = $parent.get(0);
            var moveElement;

            for (var i = 0; i < rotations; i++) {
                // Move first element to the end
                if (clockwise) {
                    moveElement = $elements.get(i);
                    parentElement.appendChild(moveElement);

                // Move last element to the front
                } else {
                    moveElement = $elements.get(length - 1 - i);
                    parentElement.insertBefore(moveElement, parentElement.children[0]);
                }
            }
        };
    }

    /**
     * Makes an array rotation function. 1 for clockwise and -1 for counter-clockwise
     *
     * @param {number} direction
     */

    function makeRotateArray(direction) {
        var clockwise = direction > 0;

        return function rotateArray(arr, quantity) {
            quantity = quantity ? quantity % arr.length : 1;

            if (clockwise) {
                arr = arr.concat(arr.splice(0, quantity));
            } else {
                arr.unshift.apply(arr, arr.splice(arr.length - quantity, quantity));
            }

            return arr;
        };
    }

    /**
     *  Calculates relative index of first card after rotation of the card by a given offset
     *
     *  @param {number} offset - number of cards rotated. Positive value for clockwise and negative for counter clockwise rotation
     *  @param {number} idxOfFirstCard - relative index of first card in the carousel
     *  @param {number} setSize - number of cards in the carousel
     *
     */
    function firstCardIndexAfterRotate(offset, idxOfFirstCard, setSize) {
        var idx = (idxOfFirstCard + offset) % setSize;
        if (idx === 0) {
            idx = setSize;
        }
        else if (idx < 0) {
            idx = setSize + idx;
        }
        return idx;
    }

    /**
     *  Returns relative index of a card given with respect to the current state of carousel
     *
     *  @param {number} idx - index of the card of which relative index is needed
     *  @param {number} indexOfFirstCard - index of first card in the carousel
     *  @param {number} setSize - number of cards in the carousel
     *
     */
    function relativeIndexFromIndex(idx, idxOfFirstCard, setSize) {
        var relativeIdx = 1;
        if (idx > 0 && idx <= setSize) {
            if (idx > idxOfFirstCard) {
                relativeIdx = idx - idxOfFirstCard + 1;
            }
            else if (idx < idxOfFirstCard) {
                relativeIdx = setSize - idxOfFirstCard + idx + 1;
            }
            return relativeIdx;
        }
        P.error("idx should be between 1 and " + setSize, "a-carousel-circular-utils", "relativeIndexFromIndex");
    }

    return {
        rotateCW: makeRotate(1),
        rotateCCW: makeRotate(-1),
        rotateArrayCW: makeRotateArray(1),
        rotateArrayCCW: makeRotateArray(-1),
        firstCardIndexAfterRotate: firstCardIndexAfterRotate,
        relativeIndexFromIndex: relativeIndexFromIndex
    };
});
/////////////////////////
// END FILE js/carousel_circular_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/carousel_measure.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Measurement Mixin
 */

"use strict";

/**
 *  A mixin which creates a set of functionality designed to allow a Carousel to measure itself.
 *  All measurement data is private, so use the get and measure functions.
 */
P.when("A", "jQuery").register("a-carousel-measure", function (A, $) {
  var undefined;

  /**
   *  Mixin which instantiate new private variables and adds measurement
   *  functionality to the carousel.
   *
   *  @param {Carousel} carousel
   */
  function asMeasurable(carousel) {
    /** @private */
    var dimensions = {
      carousel: {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      },
      viewport: {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      },
      items: [],
      getFirstCardWidth: function () {
        return this.items[0] === undefined || !A.isFiniteNumber(this.items[0].width) || this.items[0].width <= 0 ? 160 : this.items[0].width;
      }
    };

    /**
     *  Measure all listed properties of a given DOM node and place them on the
     *  dimension object provided.  Keeps track of values which change, and returns
     *  those on a seperate object.
     *
     *  @private
     *  @param {Object} dimension - Place measurements here
     *  @param {HTMLElement} $dom - The DOM node to measure. Can be a jQuery wrapped DOM node
     *  @param {Array} properties - A list of properties to measure
     *
     *  @returns {Object} changes - A hash of properties which changed and their new value
     */
    function getChanges(dimension, $dom, properties) {
      var property, offset, tmp, changed;

      // Make sure we have a jQuery wrapped DOM node
      if (!$dom.jquery) {
        $dom = $($dom);
      }

      // We need to calculate the offset if the top or left is required
      A.each(properties, function (property) {
        if (property === "top" || property === "left") {
          offset = $dom.offset();
          return false;
        }
      });

      while ((property = properties.pop()) !== undefined) {
        tmp = dimension[property];
        if (property === "left" || property === "top") {
          dimension[property] = offset[property];
        } else if (property.indexOf("outer") > -1) {
          dimension[property] = $dom[property](true);
        } else {
          dimension[property] = $dom["outer" + property.charAt(0).toUpperCase() + property.substr(1)]();
        }

        if (dimension[property] !== tmp) {
          if (changed === undefined) {
            changed = {};
          }
          changed[property] = tmp;
        }
      }

      return changed;
    }

    /**
     *  Remeasures the carousel, keeps track of which dimensions changed, records the new measurements, then returns the changes.
     *
     *  @public
     *  @param {String} elements (Optional) - A space delimited list of the items you'd like to measure. Not passing this results in everything being measured.
     *  @returns {Object} changes - A hash of which dimensions changed and their associated new value
     */
    carousel.measure = function (elements) {
      var $carousel = this.dom.$carousel;
      var $viewport = this.dom.$viewport;
      var changes = {};

      if (elements) {
        elements = elements.split(" ");
      }

      if (!elements || A.indexOfArray(elements, "carousel") > -1) {
        changes.carousel = getChanges(dimensions.carousel, $carousel, ["top", "left", "height", "width", "outerHeight", "outerWidth"]);
      }

      if (!elements || A.indexOfArray(elements, "viewport") > -1) {
        changes.viewport = getChanges(dimensions.viewport, $viewport, ["height", "width", "outerHeight", "outerWidth"]);
      }

      if (!elements || A.indexOfArray(elements, "items") > -1) {
        dimensions.items = [];
        changes.items = {};

        $carousel.children("li").each(function (idx, item) {
          dimensions.items[idx] = {};
          var itemChanges = getChanges(dimensions.items[idx], item, ["top", "left", "height", "width", "outerHeight", "outerWidth"]);
          if (itemChanges !== undefined) {
            changes.items[idx] = itemChanges;
          }
        });
      }

      return changes;
    };

    /**
     *  Get the left offset of the card at the given index.
     *
     *  @public
     *  @param {Number} idx
     *
     *  @returns {Number}
     */
    carousel.getItemOffset = function (idx) {
      var items = dimensions.items;
      idx--;
      if (items && items.length) {
        if (idx < items.length) {
          var offset = 0;
          var firstItemWidth = items[0].outerWidth;

          for (var i = 0; i < idx; i++) {
            offset += items[i] ? items[i].outerWidth : firstItemWidth;
          }

          if (idx > 0 && this.getAttr("first_item_flush_left")) {
            offset += carousel.getAttr("currentGutter");
          }

          return offset;
        }
      } else {
        return 0;
      }
    };

    /**
     *  Dumb getter for private dimensions hash.  Does not re-measure the carousel.
     *
     *  @public
     *
     *  @returns {Object} dimensions - A copy of the current dimensions hash.
     */
    carousel.getDimensions = function () {
      return A.copy(dimensions);
    };

    /**
     *  Setter for dimension values.  If you change a dimension, know what the new value is, and want to update
     *  the private dimensions cache, use this.
     *
     *  @public
     *  @param {Object} newDimensions - A hash of dimension names and associated new values to cache.
     */
    carousel.updateDimensionsCache = function (newDimensions) {
      A.extend(dimensions, newDimensions);
    };

    /**
     *  Get the cached width of the carousel viewport.
     *
     *  @public
     *
     *  @returns {Number|undefined}
     */
    carousel.getViewportWidth = function () {
      try {
        return dimensions.viewport.width;
      } catch (e) {}
    };
  }

  return asMeasurable;
});
/////////////////////////
// END FILE js/mixins/carousel_measure.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/carousel_attributes.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Attribute Management
 *
 */

"use strict";

/**
 *  A pseudo event system for attribute changes.  Allows pieces of the carousel to communicate without
 *  tight coupling.  A global event is triggered when attributes are changed, but locally defined callbacks
 *  will always fire first.
 */
P.when("A", "jQuery").register("a-carousel-attributes", function (A, $) {

  /**
   *  Allows the passed object to have private attributes which are managed through
   *  getters, setters, and change callbacks.
   *
   *  @param {Object} carousel - The object to which callbacks are bound.
   */
  var asAttributeManager = function (carousel, defaults) {
    /**
     *  Attribute hash.
     *
     *  @private
     *  @type {Object}
     */
    var attributes = {};

    /**
     *  A hash of named attributes to an array of event handlers.
     *
     *  @private
     *  @type {Object}
     */
    var handlers = {};

    /**
     *  When executing callbacks for an attribute, we don't want another call to setAttr
     *  to cause callbacks to fire again.  This keeps track of which attributes are
     *  frozen.
     *
     *  @private
     *  @type {Object}
     */
    var frozenAttrs = {};

    // Copy the defaults onto the private attributes hash
    A.extend(attributes, defaults);

    /**
     *  Register a callback function which executes when the named attribute changes.
     *
     *  @param {String} attributes - A space delimited string of attribute names to listen to
     *  @param {Function} fn - A callback function
     *
     *  @returns {Carousel} this
     */
    carousel.onChange = function (attributes, fn) {
      var names = attributes.split(" ");
      var i = names.length;
      var name;
      while (i--) {
        name = names[i];
        if (!handlers[name]) {
          handlers[name] = [];
        }
        if ($.isFunction(fn) && A.indexOfArray(handlers[name], fn) === -1) {
          handlers[name].push(fn);
        }
      }
      return this;
    };

    /**
     *  Get rid of a callback function so that it no longer executes when the named
     *  attribute changes.
     *
     *  @param {String} name - The name of the attribute the function was watching
     *  @param {Function} fn - The function which should no longer be executed
     *
     *  @returns {Carousel} this
     */
    carousel.unbind = function (name, fn) {
      if (handlers[name] && fn) {
        var i = A.indexOfArray(handlers[name], fn);
        if (i > -1) {
          handlers[name].splice(i, 1);
        }
      }
      return this;
    };

    /**
     *  Shortcut for binding a change handler which only executes once.
     *
     *  @public
     *  @param {String} attributes - A space delimited string of attribute names to listen to
     *  @param {Function} fn - A callback function
     *
     *  @returns {Carousel} this
     */
    carousel.once = function (name, fn) {
      var callback = function () {
        fn.apply(null, arguments);
        carousel.unbind(name, callback);
      };
      return carousel.onChange(name, callback);
    };

    /**
     *  Set the value of the named attribute.  If the value has changed, change handlers
     *  registered with registerAttrChangeHandler will then fire a global A.trigger event
     *  is fired.
     *
     *  @param {String} name - The name of the attribute
     *  @param {Object}  value - The new value of the attribute
     *  @param {Boolean} silent - If set to true, events will not be fired. USE WITH CAUTION.
     *
     *  triggers a:carousel:[name]:change:[attribute_name]
     *
     *  @returns {Carousel} this
     */
    carousel.setAttr = function (name, value, silent) {
      var old = attributes[name];
      attributes[name] = value;
      if (!(silent || frozenAttrs[name] || A.equals(value, old))) {
        frozenAttrs[name] = true;
        var copyOfValue = A.copy(value);
        var copyOfOld = A.copy(old);
        if (handlers[name]) {
          var immutableHandlers = A.copy(handlers[name]);
          for (var i = 0, l = immutableHandlers.length; i < l; i++) {
            immutableHandlers[i](copyOfValue, copyOfOld, carousel, name);
          }
        }
        var eventData = {
          newValue: copyOfValue,
          oldValue: copyOfOld,
          carousel: carousel
        };
        A.trigger("a:carousel:change:" + name, eventData);
        if (attributes.name) {
          A.trigger("a:carousel:" + attributes.name + ":change:" + name, eventData);
        }
        frozenAttrs[name] = false;
      }
      return this;
    };

    /**
     *  A dumb getter for attributes.  Returns a copy of arrays and objects.
     *
     *  @returns {Object}  The value of the attribute or undefined if that attribute hasn't been set yet.
     */
    carousel.getAttr = function (name) {
      return A.copy(attributes[name]);
    };
  };

  return asAttributeManager;

});
/////////////////////////
// END FILE js/mixins/carousel_attributes.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Base Carousel (abstract)
 */

"use strict";

/**
 *  Base Carousel class which all carousels are meant to inherit from.  Should not be instantiated directly since no event handlers are bound.
 */
P.when("A", "jQuery", "a-carousel-measure", "a-carousel-attributes", "a-carousel-strategies", "a-carousel-constants", "a-analytics", "prv:a-capabilities", "prv:a-tnr")
.register("a-carousel-base", function (A, $, asMeasurable, asAttributeManager, strategies, ATTR, analytics, privateCapabilities, tnr) {

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_MAINTAIN_STATE = "maintain_state";
  var ATTR_MAX_HEIGHT = "max_height";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PAUSED = "transitionPaused";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_IN_TAB = "isInTab";

  /**
   *  In certain cases, we need to switch between the UI to allow pagination and the UI for only one page of items.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function paginationButtonDisplay(carousel) {
    var singlePage = carousel.getAttr("set_size") <= carousel.getAttr("pageSize");
    var noTransition = carousel.getAttr(ATTR.NO_TRANSITION);
    if (carousel.getAttr(ATTR_TOTAL_PAGES) === 1 && carousel.getAttr(ATTR_PAGE_NUMBER) > 1) {
      carousel.gotoPage(1, {
        startover: true,
        animationDuration: 0
      });
    }
    carousel.dom.$container.find(".a-carousel-left, .a-carousel-right").css("visibility", singlePage || noTransition ? "hidden" : "visible");
  }

  /**
   *  This is the selector used to get the input element which stores the firstVisibleItem attribute.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var FIRST_VISIBLE_ITEM_SELECTOR = "input.a-carousel-firstvisibleitem";

  /**
   *  Make sure the provided set_size is numeric.
   *  {@see https://issues.amazon.com/issues/AUI-11263}
   */
  function asSetSize(value, defaultSize) {
    if (isNaN(value)) {
      // log a warning message
      P.log("`set_size` should be an integer: " + value, "WARN", "aui:carousel:base");
      return defaultSize;
    }
    // `set_size` should be an integer
    // {@link https://aui.amazon.com/development/interactive_components/carousel/quick_start_guide}
    return parseInt(value, 10);
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function bindAttrChangeHandlers(carousel) {
    // Pagination functionality.  Update pageNumber and totalPages when the pageSize changes.
    carousel.onChange(ATTR_PAGE_SIZE, function (newPageSize, oldPageSize) {
      // When the page size changes due to resize or whatever, we need to check to see what page we're
      // on as it may change as well
      var currentIdx = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
      var newPageNumber = Math.ceil(currentIdx / newPageSize);
      if (newPageNumber === 1 && currentIdx > 1) {
        newPageNumber = 2;
      } else if (newPageNumber < 1) {
        newPageNumber = 1;
      }
      carousel.setAttr(ATTR_PAGE_NUMBER, newPageNumber);
      carousel.setAttr(ATTR_TOTAL_PAGES, Math.ceil(carousel.getAttr(ATTR_SET_SIZE) / newPageSize));

      // When the page size changes, we may need to fetch more items to ensure that the next/prev page
      // has been fetched
      var ajax = carousel.getAttr("ajax");
      if (newPageSize > oldPageSize) {
        if (ajax && ajax.prefetch_next_page) {
          carousel.strategies.ajax.wantNextPage(carousel);
        } else {
          carousel.strategies.ajax.wantCurrentPage(carousel);
        }
      }
    });

    // If the set size increases, the total number of pages may need to increase and the fetched items array will need to be altered
    carousel.onChange(ATTR_SET_SIZE, function (current, old) {
      // Set the new total number of pages
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
      carousel.setAttr(ATTR_TOTAL_PAGES, Math.ceil(current / pageSize));

      // Alter the fetchedItems array to reflect the change in set size
      if (current < old) {
        fetchedItems.splice(current, Number.MAX_VALUE);
        carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems);
      } else {
        if (carousel.strategies.ajax.wantCurrentPage) {
          carousel.strategies.ajax.wantCurrentPage(carousel);
        }
      }

    });

    // Keep track of the first visible item
    carousel.onChange(ATTR_FIRST_VISIBLE_ITEM, function (current) {
      carousel.dom.$container.find(FIRST_VISIBLE_ITEM_SELECTOR).val(current);
    });

    // Reset some state variables on page change to prevent the carousel from getting stuck
    carousel.onChange(ATTR_PAGE_NUMBER, function (current) {
      if (current > 0 && current <= carousel.getAttr(ATTR_TOTAL_PAGES)) {
        carousel.setAttr("currentlyWrapping", false);
      }
    });
  }

  /**
   *  Base Carousel class which all carousels are meant to inherit from.  Should not be instantiated directly since no event handlers are bound.
   *
   *  @constructor
   *  @this {Carousel}
   *
   *  @param {HTMLElement} $dom  The optionally jQuery wrapped DOM node for the DIV conatining the carousel components
   *  @param {Object} strategies  A hash of strategies which will be used by this carousel
   *  @param {Object} options  A hash of options to configure the carousel
   *
   *  @returns {Carousel}
   */
  function Carousel($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  CarouselDesktop.prototype = new Carousel();
    if (arguments.length === 0) {
      return;
    }

    // Alias the "this" variable for better minification
    var carousel = this;

    // Make sure we're dealing with a jQuery object, then cache the requisite dom nodes
    if (!$dom.jquery) {
      $dom = $($dom);
    }

    carousel.dom = {
      $container: $dom,
      $viewport: $dom.hasClass("a-carousel-viewport") ? $dom : $dom.find(".a-carousel-viewport"),
      $carousel: $dom.find(".a-carousel")
    };

    if ($dom.length && (!carousel.dom.$viewport.length || !carousel.dom.$carousel.length)) {
      analytics.logError(
        "[AUI] CarouselContainer does not have CarouselContent.",
        'ERROR',
        JSON.stringify({
          xpath: A.xpath($dom.get(0)),
          cssSelector: A.cssSelector($dom.get(0)),
          custody: A.attributionChain($dom.get(0))
        })
      );
    }

    // Extend the default attributes with the options.  Don't care what they are.
    var defaults = {
      totalPages: 1000,
      pageNumber: 1,
      pageSize: 0,
      firstVisibleItem: 1,
      maintain_state: true,
      px: 0,
      auto_adjust_height: true,
      ajax: {}
    };
    A.extend(defaults, options);

    defaults.maintain_state = !!defaults.maintain_state;

    // BEGIN total set size detection

    // If a set of IDs (aka ASINs) is passed in as an option, use its size as the set size
    if (defaults.id_list) {
      if (!defaults.set_size) {
        defaults.set_size = defaults.id_list.length;
      }
    } else {
      defaults.id_list = [];
    }

    // If there's no set of ASINs, but they did put an aria-setsize on the carousel items, use that
    var $items = this.dom.$carousel.children("li");
    if (!defaults.set_size) {
      var setSize = parseInt($items.first().attr("aria-setsize"), 10);
      if (A.isFiniteNumber(setSize) && setSize > 0) {
        defaults.set_size = setSize;
      } else {
        defaults.set_size = $items.length;
      }
    } else {
      // https://issues.amazon.com/issues/AUI-11263
      // if we have an invalid value, take the $items.length as the default value
      // that is a good enough indication of how many carousel items
      defaults.set_size = asSetSize(defaults.set_size, $items.length);
    }

    // END total set size detection

    // Set up the fetchedItems array
    var fetchedItems = [];
    carousel.dom.$carousel.children("li").each(function (idx, item) {
      fetchedItems.push(
        $(item).hasClass("a-carousel-card-empty")
          ? ""
          : A.trim(item.innerHTML)
      );
    });
    defaults.fetchedItems = fetchedItems;

    // Add measurement and attribute management functionality and bind the mixins
    asMeasurable(carousel);
    asAttributeManager(carousel, defaults);
    carousel.strategies = strategies;

    return carousel;
  }

  // Functionality for setting and initializing new strategies after the carousel has been created.
  A.each(strategies, function (ignored, type) {
    Carousel.prototype["set" + type.charAt(0).toUpperCase() + type.slice(1) + "Strategy"] = function (strategy) {
      this.strategies[name] = strategy;
      if (typeof strategy.init === "function") {
        strategy.init(this);
      }
    };
  });


  // Setup the rest of the public interface.  Usually just delegates to the appropriate strategy.
  var prototype = Carousel.prototype; // Aliased for compression
  prototype.gotoNextPage = function (options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoNextPage(this, options);
      // accessibleSafe is only set to true by us when responding to a customer user interaction
      // this will stop autorotating carousels that call directly to the prototype to change pages
      // from stealing focus on every page shift
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.nextPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoPrevPage = function (options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPrevPage(this, options);
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.prevPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoPage = function (pageNumber, options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPage(this, pageNumber, options);
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.gotoPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoIndex = function (idx, options) {
    if (!this.getAttr(ATTR_PAUSED) || options && options.ignorePause) {
      this.strategies.transition.gotoIndex(this, idx, options);
    }
  };
  prototype.gotoPixel = function (px, options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPixel(this, px, options);
    }
  };
  prototype.resize = function () {
    if(!this.dom.$container.is(":visible")) {
      return;
    }
    var changes = this.measure("carousel viewport");
    this.strategies.display.resize(this, changes);
  };

  /**
   *  Temporarily prevent the goto functions from doing anything.  Restart goto functions by calling .resume().
   *
   *  @public
   */
  prototype.pause = function () {
    this.setAttr(ATTR_PAUSED, true);
  };

  /**
   *  Will resume allowing goto functions to do what they're supposed to do.
   *
   *  @public.
   */
  prototype.resume = function () {
    this.setAttr(ATTR_PAUSED, false);
  };

  /**
   *  Function which allows triggering events with consistent names and APIs for all carousels.
   *
   *  @public
   *  @param {string} eventName
   *  @param {object} data  (optional) A hash of data to pass to callbacks.  The carousel will automatically be added to this hash.
   *
   *  triggers a:carousel:[eventName]
   *  triggers a:carousel:[name]:[eventName]
   */
  prototype.triggerEvent = function (eventName, data) {
    var carousel = this;
    data = data || {};
    data.carousel = carousel;

    A.trigger("a:carousel:" + eventName, data);
    var name = carousel.getAttr("name");
    if (name) {
      A.trigger("a:carousel:" + name + ":" + eventName, data);
    }
  };

  /**
   *  Returns the HTML for the static loading image, which is usually empty.  Mobile Carousel has some HTML which gets output.
   *
   *  @public
   *
   *  @return {string}
   */

  prototype.getStaticLoader = function () {
    if (this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
      return '<div class="' + this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS) + '"></div>';
    }
    return "";
  };

  /**
   *  Return the HTML for an empty carousel card complete with standard loading HTML.
   *
   *  @public
   *  @param {number} index  The 1-based index of this particular card
   *  @param {number} setSize  The total number of cards in the carousel
   *
   *  @return {string}
   */

  prototype.getEmptyCard = function (index, setSize) {
    var elementCssClasses = 'a-carousel-card a-carousel-card-empty';
    if (this.getAttr(ATTR.ELEMENT_CSS_CLASS)) {
      elementCssClasses = elementCssClasses + ' ' + this.getAttr(ATTR.ELEMENT_CSS_CLASS);
    }
    return ['<li class="', elementCssClasses, '" role="listitem" aria-setsize="', setSize, '" aria-posinset="', index, '">', this.getStaticLoader(), '</li>'].join('');
  };


  /**
   *  Setup swipe and pan gesture support.
   *
   *  @public
   */
  prototype.initTouchHandling = function() {
    var carousel = this;
    var $viewport = carousel.dom.$viewport;
    if (!$viewport.length) {
      return;
    }

    // If the user can swipe, let 'em
    if (A.capabilities.touch || A.capabilities.pointerPrefix) {
      P.when("a-touch").execute(function (touch) {
        $viewport.addClass("a-gesture a-gesture-horizontal").bind("pan-horizontal swipe-horizontal", function () {
          return false;
        });
        A.on("a:swipe-horizontal:" + $viewport[0].id, function (touch) {
          if (!carousel.getAttr("transitionPaused") && carousel.strategies.transition.onSwipe) {
            carousel.strategies.transition.onSwipe(carousel, touch);
          }
        });
        if (!carousel.getAttr("disable_panning")) {
          A.on("a:pan-horizontal:" + $viewport[0].id, function (touch) {
            if (!carousel.getAttr("transitionPaused") && carousel.strategies.transition.onPan) {
              carousel.strategies.transition.onPan(carousel, touch);
            }
          });
        }
      });
    }

    // IE dispatches clicks even if we've panned or swiped. My guess is that the browser checks a delta on movement within the element
    // and since we're moving the element along with the finger, the down and up occur in the same place on a given element?
    // Whether my guess is right or not, on each pointerdown, look for swipes/pans, if one happens, aggressively murder the next click event.
    // This does not manifest on a free scroll carousel.
    // "ssiec" = Stop Stray Internet Explorer Click
    if (privateCapabilities.isIE10 || privateCapabilities.isIE11Plus) {
      var stopStrayIEClick = function (event) {
        event.stopPropagation();
        event.preventDefault();
        document.body.removeEventListener("click", stopStrayIEClick, true);
      };

      $viewport.bind(A.action.start, function (event) {
        $viewport.bind("swipe-horizontal.a-ssiec pan-horizontal.a-ssiec", function (event) {
          $viewport.unbind(".a-ssiec");
          // Was occasionally killing a valid click. Clicks are only errantly triggered if we get a pointerup here
          // and if we do get a pointerup, it appears that it triggers a click *every* time in my testing
          $viewport.bind(A.action.end + ".a-ssiec", function (event) {
            $viewport.unbind(".a-ssiec");
            if (document.body) {
              document.body.addEventListener("click", stopStrayIEClick, true);
            }
          });

        });

      });
      if (A.action.start === 'touchstart') {
          P.when('a-event-analytics').execute (function (ea) {
              ea.notifyJquery($viewport, A.action.start);
          });
      }

    }
  };

  /**
   *  Seperate initialization function for binding event handlers and whatever else is needed.
   *  Meant to be called when the carousel is almost visible on the screen.  Should be extended
   *  in inheriting classes.
   *
   *  @this {Carousel}
   *
   *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
   */
  prototype.init = function () {
    var carousel = this;
    var strategies = carousel.strategies;

    // If the carousel viewport DOM node doesn't have an ID, give it one so that we can listen to some extra events
    var viewport = carousel.dom.$viewport[0];
    if (viewport && !viewport.id) {
      viewport.id = "anonCarousel" + carousel.__id;
    }

    // Kill all the non-li nodes in the carousel list to prevent extra whitespace from screwing up the carousel
    // card display.  They need to stack right next to each other.
    carousel.dom.$carousel.contents().not(function() {
      return this.tagName && this.tagName.toLowerCase() === "li";
    }).remove();

    A.each(carousel.strategies, function (strategy) {
      if (strategy.initAttrs) {
        A.each(strategy.initAttrs, function (value, name) {
          var initValue = value;
          if (typeof value === 'function') {
            initValue = value(carousel.getAttr(name));
          }
          carousel.setAttr(name, initValue);
        });
      }
    });

    if (carousel.getAttr(ATTR_SET_SIZE) < 1) {
      strategies.ajax.init(carousel);
      return false;
    }

    // Run init for all the strategies
    carousel.measure();
    A.each(carousel.strategies, function (strategy) {
      strategy.init(carousel);
    });

    // Get the total number of pages
    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var set_size = carousel.getAttr(ATTR_SET_SIZE);
    var totalPages = Math.ceil(set_size / pageSize);
    carousel.setAttr(ATTR_TOTAL_PAGES, totalPages);

    bindAttrChangeHandlers(carousel);

    carousel.setAttr(ATTR_IN_TAB, carousel.dom.$container.closest('.a-tab-content').length > 0, true);

    // Make sure you tweet your initialization
    carousel.triggerEvent("init");

    // If any code needs to be run after all other initialization code, take care of it now
    A.each(carousel.strategies, function (strategy) {
      if (strategy.afterInit) {
        strategy.afterInit(carousel);
      }
    });

    carousel.triggerEvent("afterInit");

    // If the carousel should start on a different page, go there now
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem === 1 && carousel.getAttr(ATTR_MAINTAIN_STATE)) {
      // If the user has navigated back to this page, see if we need to start on a different page
      firstVisibleItem = parseInt(carousel.dom.$container.find(FIRST_VISIBLE_ITEM_SELECTOR).val(), 10);
      if (!(A.isFiniteNumber(firstVisibleItem) && firstVisibleItem > 0 && firstVisibleItem <= set_size)) {
        firstVisibleItem = 1;
      }
    }

    if (firstVisibleItem > 1) {
      var initialDuration = 700;
      var duration = initialDuration;
      var pagesToMove = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      for (var j = 2; j < pagesToMove; j++) {
        duration = duration + (initialDuration / j);
      }

      //var duration = distance / A.viewport().width * 1000 * 0.7 * ((firstVisibleItem - 1) * 0.6);
      carousel.gotoIndex(firstVisibleItem, {
        animationDuration: duration,
        easingFunction: "ease"
      });
    }

    // If there is only one page worth of cards, hide the pagination buttons
    paginationButtonDisplay(this);
    carousel.onChange("pageSize set_size", function () {
      paginationButtonDisplay(carousel);
    });

    // Fix the positions of the pagination buttons
    var $buttons = carousel.dom.$container.find(".a-carousel-button");
    if ($buttons.length) {
      var top = $buttons.eq(0).position().top + "px";
      $buttons.css("top", top);
    }

    /**
     * IE 9+ and IE < 9 handle double clicks differently.  IE 8 will only trigger one click event before triggering
     * the double click event.  IE 9+ will trigger two.  So, in order to allow the user to spam the next and prev
     * page buttons, I need to bind to both click and dblclick.  If two click events are fired before dblclick,
     * don't fire the handler on dblclick.  This boolean state var is used to do that.  When the event handler
     * fires, check this var, set it to true if it's false, then set it back to false after a short delay.
     *
     *  @private
     *  @type {boolean}
     */
    var clickHandled = false;
    var restartCarousel = function(event) {
      event.preventDefault();
      var options = {
        startover: true,
        accessibleSafe: (event.type === "keydown") ? true : false
      };
      if (carousel.getAttr(ATTR_PAGE_NUMBER) > 5) {
        options.animationDuration = 1250;
      } else {
        options.animationSpeed = carousel.getDimensions().viewport.width * 5;
      }
      carousel.gotoPage(1, options);
    }

    // Bind event handlers
    carousel.dom.$container.delegate(".a-carousel-goto-nextpage", "click dblclick", function (event) {
      if (!clickHandled) {
        clickHandled = true;
        event.preventDefault();
        carousel.gotoNextPage();

        A.delay(function () {
          clickHandled = false;
        }, 5);
      }
      tnr.ackDelegated(event);

    }).delegate(".a-carousel-goto-prevpage", "click dblclick", function (event) {
      if (!clickHandled) {
        clickHandled = true;

        event.preventDefault();
        carousel.gotoPrevPage();

        A.delay(function () {
          clickHandled = false;
        }, 5);
      }
      tnr.ackDelegated(event);

    }).delegate(".a-carousel-goto-nextpage", "keydown", function (event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        event.preventDefault();
        carousel.gotoNextPage({accessibleSafe: true});
      }
      tnr.ackDelegated(event);

    }).delegate(".a-carousel-goto-prevpage", "keydown", function (event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        event.preventDefault();
        carousel.gotoPrevPage({accessibleSafe: true});
      }
      tnr.ackDelegated(event);

    }).delegate(".a-carousel-restart", "keydown", function(event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        restartCarousel(event);
      }
      tnr.ackDelegated(event);

    }).delegate(".a-carousel-restart", "click", function(event) {
      restartCarousel(event);
      tnr.ackDelegated(event);
    });
      P.when('a-event-analytics').execute (function (ea) {
          ea.notifyJquery(carousel.dom.$container.find('.a-carousel-goto-nextpage'), 'click dblclick keydown');
          ea.notifyJquery(carousel.dom.$container.find('.a-carousel-goto-prevpage'), 'click dblclick keydown');
          ea.notifyJquery(carousel.dom.$container.find('.a-carousel-goto-restart'), 'keydown click');
      });
    // Get the total number of pages and update that on the UI
    carousel.dom.$container.find(".a-carousel-page-max").html(this.getAttr(ATTR_TOTAL_PAGES));
    return true;

  };

  return Carousel;
});
/////////////////////////
// END FILE js/classes/carousel_class_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_mobile.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Carousel Default Mobile Class
 *
 */

"use strict";

/**
 *  A sub-class of Carousel which has mobile specific event handlers for user interaction and DOM updates.
 */
P.when("A", "jQuery", "a-carousel-base", "a-carousel-constants").register("a-carousel-mobile", function (A, $, Carousel, ATTR) {
  var undefined;

  /**
   *  The static loading needs to have its height specificed in pixels.  We determine that here.
   *
   *  @private
   *  @param {Carousel} carousel
   *
   *  @returns {Number} height
   */
  function determineStaticLoaderHeight(carousel) {
    var height = carousel.getAttr("loaderHeight");
    if (height) {
      return height;
    } else {
      height = carousel.getAttr("maxHeight");
      if (height) {
        height *= 0.9;
        height = Math.min(height, 90);
        height = Math.max(height, 120);
      } else {
        height = 90;
      }
      carousel.setAttr("loaderHeight", height);
    }
    return height;
  }

  /**
   *  The mobile specific Carousel class.  This has additional event handlers and attribute change callbacks
   *  to update the mobile UI.
   *
   *  @constructor
   *  @augments Carousel
   *  @this {CarouselMobile}
   *
   *  @param {HTMLElement} $dom  The optionally jQuery wrapped DOM node for the DIV conatining the carousel components
   *  @param {Object} strategies  A hash of strategies which will be used by this carousel
   *  @param {Object} options  A hash of options to configure the carousel
   *
   *  @returns {CarouselMobile}
   */
  function CarouselMobile($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  AwesomeCarousel.prototype = new CarouselMobile();
    Carousel.call(this, $dom, strategies, options);
    if (arguments.length === 0) {
      return;
    }

    var carousel = this;

    // Set mobil specific defaults
    if (carousel.getAttr("circular") === undefined) {
      carousel.setAttr("circular", false);
    }
    if (carousel.getAttr("show_partial_next") === undefined) {
      carousel.setAttr("show_partial_next", true);
    }
    if (carousel.getAttr("hide_off_screen") === undefined) {
      carousel.setAttr("hide_off_screen", false);
    }
    if (carousel.getAttr("springiness") === undefined) {
      carousel.setAttr("springiness", 0.8);
    }
    if (carousel.getAttr("touch_easing") === undefined) {
      carousel.setAttr("touch_easing", "cubic-bezier(0.215, 0.610, 0.355, 1.000)");
    }

    /**
     *  Creates mobile specific event handlers.
     *
     *  @this {CarouselMobile}
     *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
     */
    carousel.init = function () {
      var carousel = this;
      if (Carousel.prototype.init.call(carousel)) {
        if (!this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
          // Determine the height of any existing static loaders
          carousel.dom.$carousel.children("li").children(".a-loading-static").css("height", determineStaticLoaderHeight(carousel) + "px");
        }

        if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
          carousel.initTouchHandling();
        }
        return true;
      } else {
        return false;
      }
    };

    return this;
  }

  // Inherit from the base paginated carousel and reset the constructor
  CarouselMobile.prototype = new Carousel();
  CarouselMobile.prototype.constructor = CarouselMobile;

  /**
   *  Returns the HTML for the static loading image.  The height of the static loader is dependent on the height of the
   *  carousel right after initialization with a minimum and maximum bound on that height.
   *
   *  @this {CarouselMobile}
   *  @public
   *
   *  @returns {String}
   */
  CarouselMobile.prototype.getStaticLoader = function () {
    if (this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
      return '<div class="' + this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS) + '"></div>';
    }
    var height = determineStaticLoaderHeight(this);
    return '<div class="a-loading-static" style="height:' + height + 'px"><div class="a-loading-static-inner"></div></div>';
  };

  return CarouselMobile;
});
/////////////////////////
// END FILE js/classes/carousel_class_mobile.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_desktop.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Default class for the Desktop Carousel
 *
 */

"use strict";

/**
 *  A sub-class of Carousel which has desktop specific event handlers for user interaction and DOM updates.
 */
P.when("A", "jQuery", "a-carousel-base", "a-carousel-constants").register("a-carousel-desktop", function (A, $, Carousel, ATTR) {
  var undefined;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_PAGE_NUMBER = "pageNumber";

    /**
   *  In certain cases, we need to switch between the UI to allow pagination and the UI for only one page of items.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function paginationButtonDisplay(carousel) {
    var singlePage = carousel.getAttr("set_size") <= carousel.getAttr("pageSize");
    var noTransition = carousel.getAttr(ATTR.NO_TRANSITION);
    carousel.dom.$container.find(".a-carousel-pagination").css("visibility", singlePage || noTransition ? "hidden" : "visible");
  }

  /**
   *  The desktop specific Carousel class.  This has additional event handlers and attribute change callbacks
   *  to update the desktop UI.
   *
   *  @constructor
   *  @augments Carousel
   *  @this {CarouselDesktop}
   */
  function CarouselDesktop($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  AwesomeCarousel.prototype = new CarouselDesktop();
    Carousel.call(this, $dom, strategies, options);
    if (arguments.length === 0) {
      return;
    }

    // Alias "this" to provide better minification
    var carousel = this;

    // Set desktop specific defaults
    if (carousel.getAttr("circular") === undefined) {
      this.setAttr("circular", true);
    }
    if (carousel.getAttr("hide_off_screen") === undefined) {
      this.setAttr("hide_off_screen", true);
    }

    // Make sure the total number of pages is kept up to date
    carousel.onChange(ATTR_TOTAL_PAGES, function (totalPages) {
      carousel.dom.$container.find(".a-carousel-page-max").html(totalPages);
      if (totalPages < carousel.getAttr(ATTR_PAGE_NUMBER)) {
        carousel.gotoPage(totalPages);
      }
    });

    // The "start over" link needs to be hidden on the first page and shown everywhere else
    carousel.onChange(ATTR_PAGE_NUMBER, function (newValue, oldValue) {
      var $container = carousel.dom.$container;
      var $restart = $container.find(".a-carousel-restart-container");
      if (newValue > 1) {
        $restart.show();
      } else {
        $restart.hide();
      }
      $container.find(".a-carousel-page-current").html(newValue);
    });

    /**
     *  Creates desktop specific event handlers.
     *
     *  @this {CarouselDesktop}
     *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
     */
    carousel.init = function () {
      // Alias "this" to provide better minification
      var carousel = this;

      if (Carousel.prototype.init.call(carousel)) {
        // If there is only one page worth of cards, hide the pagination buttons
        paginationButtonDisplay(this);
        carousel.onChange("pageSize set_size", function () {
          paginationButtonDisplay(carousel);
        });

        // Hide the "start over" link
        if (carousel.getAttr(ATTR_PAGE_NUMBER) < 2) {
          carousel.dom.$container.find(".a-carousel-restart-container").hide();
        }

        if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
          carousel.initTouchHandling();
        }
        return true;
      } else {
        return false;
      }
    };

    return carousel;
  }

  // Inherit from the base paginated carousel and reset the constructor
  CarouselDesktop.prototype = new Carousel();
  CarouselDesktop.prototype.constructor = CarouselDesktop;

  return CarouselDesktop;
});
/////////////////////////
// END FILE js/classes/carousel_class_desktop.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_classes.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Class Aggregator
 */

"use strict";

P.when("A", "a-carousel-desktop", "a-carousel-mobile").register("a-carousel-classes", function (A, CarouselDesktop, CarouselMobile) {
  return {
    desktop: CarouselDesktop,
    mobile: CarouselMobile,
    "default": A.capabilities.mobile || A.capabilities.tablet ? "mobile" : "desktop"
  };
});
/////////////////////////
// END FILE js/classes/carousel_classes.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_stretchygoodness.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel "Stretchy Goodness" Display Strategy
 *
 */

"use strict";

/**
 *  A display strategy wherein the margin between elements is adjusted to ensure that cards are equally spaced inside the viewport.
 */
P.when("A", "jQuery", "p-detect", "a-carousel-constants").register("a-carousel-stretchygoodness", function (A, $, detect, ATTR) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 15;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_CURRENT_GUTTER = "currentGutter";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_ITEM_FLUSH_LEFT = "first_item_flush_left";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_HEIGHT_ANIMATION_SPEED = "height_animation_speed";
  var ATTR_HIDE_OFFSCREEN = "hide_off_screen";
  var ATTR_MAX_HEIGHT = "maxHeight";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_SHOW_PARTIAL = "show_partial_next";
  var ATTR_SINGLE_PAGE_ALIGN = "single_page_align";
  var ATTR_TOTAL_PAGES = "totalPages";

  /**
   *  Determines the maximum number of items which can fit in the viewport given the item width,
   *  the minimum possible gutter, and the total set size.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth  The width of the visible area of the carousel container
   *  @param {Number} itemWidth  How wide is each element
   *
   *  @returns {Number} pageSize
   */
  function determinePageSize(carousel, viewportWidth, itemWidth, flushLeft) {
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      viewportWidth -= itemWidth / 10;
    }
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var pageSize = 0;
    var first = true;
    while (viewportWidth > 0) {
      pageSize++;
      if (flushLeft && first) {
        viewportWidth -= itemWidth;
      } else {
        viewportWidth -= (itemWidth + minGutter);
      }
      first = false;
    }
    if (viewportWidth < 0) {
      pageSize--;
    }

    return A.isFiniteNumber(pageSize) && pageSize > 0 ? pageSize : 1;
  }

  /**
   *  Calculate the new gutter width.  Relatively simple calculation, but it needs quite a bit of
   *  information about the state/dimensions of the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth
   *  @param {Number} itemWidth
   *  @param {Number} pageSize
   *  @param {Number} minGutter
   *  @param {Number} setSize
   *  @param {boolean} flushLeft
   *
   *  @returns {Number}  The new minimum gutter for the carousel
   */
  function determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize, flushLeft) {
    if (carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN) === "stretch" && pageSize > setSize) {
      pageSize = setSize;
    }
    // Calculate the new gutter based on the new page size
    var whiteSpace = viewportWidth - (itemWidth * pageSize);
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      var remainder = whiteSpace - (minGutter * (pageSize + 1));
      if (flushLeft) {
        remainder += minGutter;
      }
      var percentWidthAvailable = remainder / itemWidth;
      whiteSpace -= itemWidth * (percentWidthAvailable > 0.5 ? 0.5 : percentWidthAvailable);
    } else if (flushLeft) {
      whiteSpace += minGutter;
    }
    var newGutter = Math.ceil(whiteSpace / (pageSize + 1));
    if (!A.isFiniteNumber(newGutter) || newGutter < minGutter) {
      newGutter = minGutter;
    }
    return newGutter;
  }

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      if (carousel.getAttr(ATTR_ANIMATING)) {
        carousel.once(ATTR_ANIMATING, function () {
          adjustHeight(carousel);
        });
      } else {
        // Get the existing maxHeight
        var maxHeight = carousel.getAttr(ATTR_MAX_HEIGHT);
        var dimensions = carousel.getDimensions();
        if (!maxHeight || !A.isFiniteNumber(maxHeight)) {
          maxHeight = 1;
        }

        // Determine if any visible element is taller than the viewport
        var newMaxHeight = maxHeight;
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var current = pageSize * (carousel.getAttr(ATTR_PAGE_NUMBER) - 1);
        var limit = current + pageSize - 1;
        var itemDimensions = dimensions.items;
        var numItems = itemDimensions.length;
        var item;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
          limit++;
        }
        for (; current <= limit && current < numItems; current++) {
          item = itemDimensions[current];
          if (item && item.outerHeight > newMaxHeight) {
            newMaxHeight = itemDimensions[current].outerHeight || itemDimensions[current].height;
          }
        }

        // Apply the new height, if necessary
        if (newMaxHeight > maxHeight) {
          var newDimensions = {
            viewport: {
              height: newMaxHeight,
              outerHeight: newMaxHeight
            }
          };
          carousel.updateDimensionsCache(newDimensions);
          carousel.setAttr(ATTR_MAX_HEIGHT, newMaxHeight);
          if (maxHeight === 1) {
            carousel.dom.$viewport.height(newMaxHeight);
          } else {
            A.animate(carousel.dom.$viewport, {
              height: newMaxHeight
            }, carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED), "linear");
          }
        }
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }

  /**
   *  During init, we need to make some DOM changes to ensure that the display and transition strategies can do what needs doin
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function initDom(carousel) {
    // Set the height to ensure all elements are properly displayed
    if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
      adjustHeight(carousel);
    }
    var dimensions = carousel.getDimensions();
    var height = dimensions.viewport.height;
    carousel.dom.$container
      .find(".a-carousel-left, .a-carousel-right, .a-carousel-viewport")
      .css("height", Math.max(dimensions.viewport.height, dimensions.items[0] ? dimensions.items[0].height : 0) + "px");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function bindAttrChangeHandlers(carousel) {
    // Before we animate, we need to adjust visibility and carousel height
    carousel.onChange(ATTR_PAGE_NUMBER, function () {
      if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
        carousel.dom.$carousel.children("li").css("visibility", "");
      }
    });

    // See if a new item added to the page forces a taller carousel
    carousel.onChange(ATTR_PAGE_SIZE, function (current, old) {
      // Make sure the viewport is the right height
      if (current > old) {
        adjustHeight(carousel);
      }
    });

    carousel.onChange("loading", function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // Adjust the height to fit the new elements on the page
    carousel.onChange(ATTR_FIRST_VISIBLE_ITEM, function () {
      adjustHeight(carousel);
    });

    // Process hiding off screen elements if appropriate
    carousel.onChange(ATTR_ANIMATING, function (current) {
      if (!current && carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
        var c = carousel;
        var first = c.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1;
        var last = first + c.getAttr(ATTR_PAGE_SIZE) - 1;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
          last++;
        }
        c.dom.$carousel.children("li").each(function (idx, item) {
          var visible = idx >= first && idx <= last;
          $(item).css("visibility", visible ? "" : "hidden");
        });
      }
    });

    // A couple of attributes just need a repaint on change
    carousel.onChange(ATTR_SINGLE_PAGE_ALIGN + " " + ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });

    carousel.onChange(ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });
  }

  /**
   *  Calculate and apply a new gutter width.  Alter pageSize if necessary.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var viewportWidth = dimensions.viewport.width;
    var itemWidth = dimensions.getFirstCardWidth();
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var flushLeft = carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT);

    // Calculate the page size and the new gutter width
    var pageSize = determinePageSize(carousel, viewportWidth, itemWidth, flushLeft);
    var newGutter = determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize, flushLeft);
    // Update carousel attributes
    carousel.setAttr(ATTR_CURRENT_GUTTER, newGutter);
    carousel.setAttr(ATTR_PAGE_SIZE, pageSize);

    // Calculate the new carousel width and ensure current set values are accurate based on potential page size changes
    var $carousel = carousel.dom.$carousel;
    var $items = $carousel.children("li");
    var numItems = $items.length;
    var totalPages = carousel.getAttr(ATTR_TOTAL_PAGES);
    var currentPage = carousel.getAttr(ATTR_PAGE_NUMBER);
    var firstVisible = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    var expectedFirstVisible = (currentPage - 1) * pageSize + 1;
    
    // Determine if we're on a page number that may no longer exist as a result of resize/device rotation and move to the highest page
    if (currentPage > totalPages) {
      firstVisible = (totalPages - 1) * pageSize + 1;
      carousel.setAttr(ATTR_PAGE_NUMBER, totalPages);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisible);
    } else if (firstVisible !== expectedFirstVisible) {
    // Or determine if, after rotating, our previous first item is part of a different page now than we were on previously. If it is,
    // make sure to shift the carousel to an index divisble by the new page size *that still contains the item that was the first
    // visible item in the previous orientation*
      var newPage = Math.ceil(firstVisible / pageSize);
      firstVisible = (newPage - 1) * pageSize + 1;
      carousel.setAttr(ATTR_PAGE_NUMBER, newPage);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisible);
    }

    // Apply the new gutter width
    var first = firstVisible - 1;
    var last = first + pageSize - 1;
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      last++;
    }
    var hideOffScreen = carousel.getAttr(ATTR_HIDE_OFFSCREEN);
    var margin = newGutter + "px";
    var itemWidthAttr = itemWidth + "px";
    var visible;
    $items.each(function (idx, item) {
      visible = !hideOffScreen || (idx >= first && idx <= last);
      var marginAttr = A.capabilities.rtl ? "marginRight" : "marginLeft";
      item.style[marginAttr] = flushLeft && idx === 0 ? 0 : margin;
      item.style.visibility = visible ? "" : "hidden";
      item.style.width = itemWidthAttr;
    });

    // Apply the carousel width as well as the single page alignment, if necessary
    var itemOuterWidth, firstItemOuterWidth, carouselWidth;
    if (carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT)) {
      firstItemOuterWidth = $items.first().outerWidth(true);
      if ($items.length > 1) {
        itemOuterWidth = $items.eq(1).outerWidth(true);
      }
      carouselWidth = (numItems - 1) * itemOuterWidth + firstItemOuterWidth;
    } else {
      firstItemOuterWidth = itemOuterWidth = $items.first().outerWidth(true);
      carouselWidth = numItems * itemOuterWidth;
    }
    if (pageSize >= setSize) {
      carouselWidth = viewportWidth;
      var alignment = carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN);
      $carousel.toggleClass("a-text-right", alignment === "right");
      $carousel.toggleClass("a-text-center", alignment === "center");
      if (alignment === "center") {
        $items.first().css("margin-left", 0);
      }
    } else {
      $carousel.removeClass("a-text-right a-text-center");
    }

    carouselWidth = pageSize >= setSize ? viewportWidth : carouselWidth;
    $carousel.css("width", carouselWidth + "px");

    // Prepare and make updates to the measurements cache
    var updates = {
      carousel: {
        width: carouselWidth,
        outerWidth: $carousel.outerWidth()
      },
      items: []
    };
    for (var i = 0; i < numItems; i++) {
      updates.items.push({
        width: itemWidth,
        outerWidth: i === 0 ? firstItemOuterWidth : itemOuterWidth
      });
    }
    carousel.updateDimensionsCache(updates);

    // Make sure the item which was the first visible item in the viewport is still the first visible item
    carousel.gotoIndex(firstVisible, {
      animationDuration: 0,
      ignorePause: true
    });

    // Trigger a global event if able
    carousel.triggerEvent("repaint");
  }

  /**
   *  If the page has resized and the width of the viewport has changed, we need to repaint.
   *
   *  @param {Carousel} carousel
   *  @param {Object} changes - A hash of changed dimensions and their associated new value
   */
  function resize(carousel, changes) {
    if (changes.viewport && changes.viewport.width !== undefined) {
      repaint(carousel);
    }
  }

  /**
   *  When the carousel inits, we need to determine the minimum gutter, initial pageSize, and which items where fetched.
   *  Then we repaint to apply the right gutter sizes.
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    // Set the min gutter if the user didn't pass one in.
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    if (!A.isFiniteNumber(minGutter)) {
      minGutter = DEFAULT_MIN_GUTTER;
      carousel.setAttr(ATTR_MIN_GUTTER, minGutter);
    }
    carousel.setAttr(ATTR_CURRENT_GUTTER, minGutter);

    // Make sure the height animation speed's legit
    var heightAnimationSpeed = carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED);
    if (!A.isFiniteNumber(heightAnimationSpeed)) {
      carousel.setAttr(ATTR_HEIGHT_ANIMATION_SPEED, DEFAULT_HEIGHT_ANIMATION_SPEED);
    }

    // Cast to a boolean
    carousel.setAttr(ATTR_FIRST_ITEM_FLUSH_LEFT, !!carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT));

    // See if we need to show part of the next element
    carousel.setAttr(ATTR_SHOW_PARTIAL, !!carousel.getAttr(ATTR_SHOW_PARTIAL));

    // Repaint to get the right gutter applied and adjust the height to match page 1 content
    repaint(carousel);
    initDom(carousel);

    // If the user has navigated back to this page, see if we need to start on a different page
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem > 1) {
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleItem);
      var newPage = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      carousel.gotoPage(newPage);
    }

    // Bind all the attr change handlers we need.
    bindAttrChangeHandlers(carousel);
  }

  return {
    repaint: repaint,
    init: init,
    resize: resize
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_stretchygoodness.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_swap.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when("A", "jQuery", "p-detect", "a-carousel-utils").register("a-carousel-display-swap", function (A, $, detect, util) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 15;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I dont' misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_CURRENT_GUTTER = "currentGutter";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_HEIGHT_ANIMATION_SPEED = "height_animation_speed";
  var ATTR_MAX_HEIGHT = "maxHeight";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_LOADING = "loading";
  var ATTR_SINGLE_PAGE_ALIGN = "single_page_align";

  /**
   *  The CSS class placed on empty carousel cards
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var EMPTY_CARD_CLASS = "a-carousel-card-empty";

  /**
   *  Determines the maximum number of items which can fit in the viewport given the item width,
   *  the minimum possible gutter, and the total set size.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth - The width of the visible area of the carousel container
   *  @param {Number} itemWidth - How wide is each element
   *
   *  @returns {Number} pageSize
   */

  function determinePageSize(carousel, viewportWidth, itemWidth) {
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var pageSize = Math.max(Math.floor(viewportWidth / (itemWidth + minGutter)), 1);

    return A.isFiniteNumber(pageSize) ? pageSize : 1;
  }

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      // Get the existing maxHeight
      var maxHeight = carousel.getAttr(ATTR_MAX_HEIGHT);
      if (!maxHeight || !A.isFiniteNumber(maxHeight)) {
        maxHeight = 1;
      }

      // Determine if any visible element is taller than the viewport
      var newMaxHeight = maxHeight;
      carousel.dom.$carousel.children("li").not("." + EMPTY_CARD_CLASS).each(function (idx, item) {
        var height = $(item).outerHeight();
        newMaxHeight = Math.max(height, newMaxHeight);
      });

      if (newMaxHeight > maxHeight) {
        carousel.setAttr(ATTR_MAX_HEIGHT, newMaxHeight);
        if (detect.capabilities.transition) {
          if (maxHeight === 1) {
            carousel.dom.$viewport.height(newMaxHeight);
          } else {
            A.animate(carousel.dom.$viewport, {
              height: newMaxHeight
            }, carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED), "linear");
          }
        } else {
          carousel.dom.$viewport.height(newMaxHeight);
        }

        var newDimensions = {
          viewport: {
            height: newMaxHeight,
            outerHeight: newMaxHeight
          }
        };
        carousel.updateDimensionsCache(newDimensions);
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }

  /**
   *  Create an empty card using the attributes for this carousel
   *
   *  @private
   *  @param {Number} setSize - The total number of items in the carousel
   *  @param {Number} position - The 1-based position of the carousel item in the list
   *  @param {Number} width - The width of a card in pixels
   *  @param {Number} gutter - The amount of space between each card in pixels
   *  @param {Carousel} carousel
   *
   *  @returns {String}
   */

  function generateBlankItem(setSize, idx, width, gutter, carousel) {
    return ['<li class="a-carousel-card ', EMPTY_CARD_CLASS, '" role="listitem" aria-setsize="', setSize, '" aria-posinset="', idx, '" style="width:', width, 'px; margin-left:', gutter, 'px;">', carousel.getStaticLoader()].join("");
  }

  /**
   *  It the number of items in the list is greater than the page size, remove those extra items.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} pageSize
   */

  function removeExtraItems(carousel, pageSize) {
    carousel.dom.$carousel.children("li").slice(pageSize).remove();
  }

  /**
   *  During init, we may need to make DOM changes
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function initDom(carousel) {
    // Set the height to ensure all elements are properly displayed
    var dimensions = carousel.getDimensions();
    var height = dimensions.viewport.height;
    carousel.dom.$container.find(".a-carousel-left, .a-carousel-right, .a-carousel-viewport").css("height", Math.max(dimensions.viewport.height, dimensions.items[0] ? dimensions.items[0].height : 0) + "px");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function bindAttrChangeHandlers(carousel) {
    // After animation, we may need to adjust page size. Check that the animating attribute has
    // been set to false and then call the function that determines whether new items have been
    // brought into the DOM and are taller than the existing max height
    carousel.onChange(ATTR_ANIMATING, function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // Ensure that when new items are fetched, the height of the DOM is tall enough as above
    carousel.onChange(ATTR_LOADING, function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // See if a new item added to the page forces a taller carousel
    carousel.onChange(ATTR_PAGE_SIZE, function (current, old) {
      removeExtraItems(carousel, current);
      if (current > old) {
        var setSize = carousel.getAttr(ATTR_SET_SIZE);
        var itemWidth = carousel.getDimensions().getFirstCardWidth();
        var currentGutter = carousel.getAttr(ATTR_CURRENT_GUTTER);
        var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
        var firstVisibleIndex = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1;
        var $items = carousel.dom.$carousel.children("li");
        var fragment = document.createDocumentFragment();
        var $item, idx;
        if ($.isArray(fetchedItems)) {
          for (var i = $items.length; i < current; i++) {
            idx = i + firstVisibleIndex;
            $item = $(generateBlankItem(setSize, idx + 1, itemWidth, currentGutter, carousel));
            if (fetchedItems[idx]) {
              util.addElementToDom($item, util.getElementFromItem(fetchedItems[idx]));
            }
            if (idx >= setSize) {
              $item.removeClass(EMPTY_CARD_CLASS);
            }
            fragment.appendChild($item[0]);
          }
          carousel.dom.$carousel.append(fragment);
        }
        adjustHeight(carousel);
      }
    });

    // If the set size increases,
    carousel.onChange(ATTR_SET_SIZE, function (current, old) {
      var page = carousel.getAttr(ATTR_PAGE_NUMBER);
      var lastPage = carousel.getAttr(ATTR_TOTAL_PAGES);
      var $items = carousel.dom.$carousel.children("li");
      if (page === lastPage) {
        if (current > old) {
          if ($items.length) {
            carousel.dom.$carousel.children("li").each(function (idx, item) {
              if (!A.trim(item.innerHTML)) {
                item.className += " " + EMPTY_CARD_CLASS;
                item.innerHTML = carousel.getStaticLoader();
              }
            });
          }
          if (old === 0) {
            repaint(carousel);
          }
        }
      }
    });

    // A couple of attributes just need a repaint on change
    carousel.onChange(ATTR_SINGLE_PAGE_ALIGN + " " + ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });

    carousel.onChange(ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });
  }

  /**
   *  Calculate the new gutter width.  Relatively simple calculation, but it needs quite a bit of
   *  information about the state/dimensions of the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth
   *  @param {Number} itemWidth
   *  @param {Number} pageSize
   *  @param {Number} minGutter
   *  @param {Number} setSize
   *
   *  @returns {Number}  The new minimum gutter for the carousel
   */
  function determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize) {
    if (carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN) === "stretch" && pageSize > setSize) {
      pageSize = setSize;
    }
    // Calculate the new gutter based on the new page size
    var whiteSpace = viewportWidth - (itemWidth * pageSize);
    var newGutter = Math.ceil(whiteSpace / (pageSize + 1));
    if (!A.isFiniteNumber(newGutter)) {
      newGutter = minGutter;
    }
    return newGutter;
  }

  /**
   *  Calculate and apply a new gutter width.  Alter pageSize if necessary.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var viewportWidth = dimensions.viewport.width;
    var itemWidth = dimensions.getFirstCardWidth();
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);

    // Calculate the page size and the new gutter width
    var pageSize = determinePageSize(carousel, viewportWidth, itemWidth);
    var newGutter = determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize);

    // Update carousel attributes
    carousel.setAttr(ATTR_CURRENT_GUTTER, newGutter);
    carousel.setAttr(ATTR_PAGE_SIZE, pageSize);

    // Calculate the new carousel width
    var $carousel = carousel.dom.$carousel;
    var $items = $carousel.children("li");
    var numItems = $items.length;
    var itemOuterWidth = itemWidth + newGutter;
    var carouselWidth = numItems * itemOuterWidth;

    // Apply the new gutter and carousel width
    removeExtraItems(carousel, Math.min(pageSize, setSize));
    $items.css("margin-left", newGutter + "px");

    // Apply the carousel width as well as the single page alignment, if necessary
    if (pageSize >= setSize) {
      carouselWidth = viewportWidth;
      var alignment = carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN);
      $carousel.toggleClass("a-text-right", alignment === "right");
      $carousel.toggleClass("a-text-center", alignment === "center");
      if (alignment === "center") {
        $items.first().css("margin-left", 0);
      }
    } else {
      $carousel.removeClass("a-text-right a-text-center");
    }

    // Prepare and make updates to the measurements cache
    var updates = {
      carousel: {
        width: carouselWidth,
        outerWidth: $carousel.outerWidth()
      },
      items: []
    };
    while (numItems--) {
      updates.items.push({
        outerWidth: itemOuterWidth
      });
    }
    carousel.updateDimensionsCache(updates);

    // Trigger a global event if able
    carousel.triggerEvent("repaint");
  }

  /**
   *  When the carousel inits, we need to determine the minimum gutter, initial pageSize, and which items where fetched.
   *  We then repaint to apply the right gutter sizes.
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    // Set the min gutter if the user didn't pass one in.
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    if (!minGutter) {
      minGutter = DEFAULT_MIN_GUTTER;
      carousel.setAttr(ATTR_MIN_GUTTER, minGutter);
    }
    carousel.setAttr(ATTR_CURRENT_GUTTER, minGutter);

    // Make sure the height animation speed's legit
    var heightAnimationSpeed = carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED);
    if (!A.isFiniteNumber(heightAnimationSpeed)) {
      carousel.setAttr(ATTR_HEIGHT_ANIMATION_SPEED, DEFAULT_HEIGHT_ANIMATION_SPEED);
    }

    // Bind all the attr change handlers we need.
    bindAttrChangeHandlers(carousel);

    // Repaint to get the right gutter applied and adjust the height to match page 1 content
    repaint(carousel);
    initDom(carousel);

    // If the user has navigated back to this page, see if we need to start on a different page
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem > 1) {
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleItem);
      var newPage = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      carousel.gotoPage(newPage);
    }
  }

  /**
   *  If the page has resized and the width of the viewport has changed, we need to repaint.
   *
   *  @public
   *  @param {Carousel} carousel
   *  @param {Object} changes - A hash of changed dimensions and their associated new value
   */
  function resize(carousel, changes) {
    if (changes.viewport && changes.viewport.width !== undefined) {
      repaint(carousel);
    }
  }

  return {
    repaint: repaint,
    init: init,
    resize: resize
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_swap.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_single.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Single Item Per Page Display Strategy
 *
 */

"use strict";

P.when("A", "jQuery").register("a-carousel-display-single", function (A, $) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 14;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_FIXED_HEIGHT = "fixed_height";
  var ATTR_HIDE_OFFSCREEN = "hide_off_screen";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_SHOW_PARTIAL = "show_partial_next";

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      if (carousel.getAttr(ATTR_ANIMATING)) {
        carousel.once(ATTR_ANIMATING, function () {
          adjustHeight(carousel);
        });
      } else {
        carousel.dom.$viewport.css("height", "auto");
        A.delay(function () {
          carousel.dom.$viewport.height(carousel.dom.$viewport.height());
        }, 0);
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }
  
  function hideOffscreenCards(carousel, resetOnscreenCards) {
    var $cards = carousel.dom.$carousel.children("li");
    var visibleItemIndex = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1; // This is stored 1-based instead of 0-based
    var numberOfCards = carousel.getAttr(ATTR_SHOW_PARTIAL) ? 2 : 1;
    var $expectedVisibleCards = $cards.slice(visibleItemIndex, visibleItemIndex + numberOfCards);
    $cards.not($expectedVisibleCards).css("visibility", "hidden");
    if (resetOnscreenCards) {
      $expectedVisibleCards.css("visibility", "");
    }
  }

  /**
   *  During init, we need to make some DOM changes to ensure that the display and transition strategies can do what needs doin
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function initDom(carousel) {
    var fixedHeight = carousel.getAttr(ATTR_FIXED_HEIGHT);
    if (A.isFiniteNumber(fixedHeight)) {
      carousel.dom.$viewport.height(fixedHeight);
    } else {
      carousel.setAttr(ATTR_FIXED_HEIGHT, false);
    }
    carousel.dom.$carousel.children("li").css("visibility", "visible");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function bindAttrChangeHandlers(carousel) {
    if (!carousel.getAttr(ATTR_FIXED_HEIGHT)) {
      carousel.dom.$viewport.delegate("img", "load", function () {
        adjustHeight(carousel);
      });

      carousel.onChange("loading", function (current) {
        if (!current) {
          adjustHeight(carousel);
        }
      });

      // Before animating, make everybody visible again
      carousel.onChange(ATTR_PAGE_NUMBER, function () {
        if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
          carousel.dom.$carousel.children("li").css("visibility", "");
        }
      });
      
      // After animating, make cards other than the current one hidden
      carousel.onChange(ATTR_ANIMATING, function(current) {
        if (!current && carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
          hideOffscreenCards(carousel);
        }
      });

      carousel.onChange(ATTR_MIN_GUTTER, function () {
        repaint(carousel);
      });
    }
  }

  /**
   *  Calculate and apply a new item width.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var width = dimensions.viewport.width;
    var showPartial = carousel.getAttr(ATTR_SHOW_PARTIAL);
    var gutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var $cards = carousel.dom.$carousel.children("li");

    // Calculate and apply the new item width
    width -= gutter * 2;
    if (showPartial) {
      width -= gutter + dimensions.viewport.width / 3;
    }
    $cards.css({
      width: width + "px",
      margin: "0 " + gutter + "px"
    });

    // Update the carousel width
    var outerWidth = width + gutter * 2;
    var carouselWidth = outerWidth * setSize;
    carousel.dom.$carousel.width(carouselWidth);

    // Update the dimensions cache
    var updates = {
      carousel: {
        width: carouselWidth
      },
      items: []
    };
    while (setSize--) {
      updates.items[setSize] = {
        width: width,
        outerWidth: outerWidth
      };
    }
    carousel.updateDimensionsCache(updates);
    
    // hide elements other than the single being displayed if we ought to
    if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
      hideOffscreenCards(carousel, true);
    }

    // Make sure the item which was the first visible item in the viewport is still the first visible item
    carousel.gotoIndex(carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM), {
      animationDuration: 0,
      ignorePause: true
    });

    carousel.triggerEvent("repaint");
  }

  return {
    repaint: repaint,
    /**
     *  When the carousel inits, we need to determine the initial values for attributes like the gutter,
     *  whether to show a partial of the next, etc.  Then we need to alter the DOM to ensure display specific
     *  CSS takes effect and the proper height is set.  Then we need to bind attribute change handlers and
     *  call repaint to set the proper width.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      // Set attribute defaults
      var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
      carousel.setAttr(ATTR_MIN_GUTTER, A.isFiniteNumber(minGutter) ? minGutter : DEFAULT_MIN_GUTTER);
      carousel.setAttr(ATTR_SHOW_PARTIAL, !!carousel.getAttr(ATTR_SHOW_PARTIAL));
      carousel.setAttr("pageSize", 1);

      // Set up the DOM and bind attribute change handlers
      carousel.setAttr("pageSize", 1);
      initDom(carousel);
      bindAttrChangeHandlers(carousel);
      this.repaint(carousel);
      adjustHeight(carousel);
    },
    /**
     *  If the page has resized and the width of the viewport has changed, we need to repaint.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} changes - A hash of changed dimensions and their associated new value
     */
    resize: function (carousel, changes) {
      if (changes.viewport && changes.viewport.width !== undefined) {
        this.repaint(carousel);
        if (!carousel.getAttr(ATTR_FIXED_HEIGHT)) {
          adjustHeight(carousel);
        }
      }
    }
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_single.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_peekcircular.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Single Item Per Page Display Strategy
 *
 */

'use strict';

P.when('A', 'jQuery', 'a-carousel-constants').register('a-carousel-display-peekcircular', function (A, $, ATTR) {

    function defaultFiniteNumber (defaultValue) {
        return function (initValue) {
            return A.isFiniteNumber(initValue) ? initValue : defaultValue;
        };
    }

    var DEFAULT_MIN_GUTTER = 14,
        DEFAULT_PEEK_PERCENTAGE = 10;

    var initAttrs = {};
    initAttrs[ATTR.PAGE_SIZE] = 1;
    initAttrs[ATTR.MIN_GUTTER] = defaultFiniteNumber(DEFAULT_MIN_GUTTER);
    initAttrs[ATTR.PEEK_PERCENTAGE] = defaultFiniteNumber(DEFAULT_PEEK_PERCENTAGE);

    return {
        initAttrs: initAttrs,

        /**
         *  Establish defaults for required attributes, make cards visible, and repaint.
         *
         *  @public
         *  @param {Carousel} carousel
         */
        init: function (carousel) {
            var self = this;

            carousel.onChange(ATTR.PEEK_PERCENTAGE, function (current, old) {
                self.repaint(carousel);
            });

            carousel.dom.$carousel.children('li').css('visibility', 'visible');

            self.repaint(carousel);
        },

        /**
         *  Calculate and apply a new item and peek width.
         *
         *  @public
         *  @param {Carousel} carousel
         *
         *  triggers a:carousel:[name]:repaint
         */
        repaint: function (carousel) {
            var gutter = carousel.getAttr(ATTR.MIN_GUTTER),
                setSize = carousel.getAttr(ATTR.SET_SIZE),
                peekPercentage = carousel.getAttr(ATTR.PEEK_PERCENTAGE),
                viewportWidth = carousel.getDimensions().viewport.width,
                $carousel = carousel.dom.$carousel,
                $cards = $carousel.children('li');

            var peekWidth = (peekPercentage / 100) * viewportWidth,
                cardWidth = viewportWidth - (peekWidth * 2) - gutter,
                outerWidth = cardWidth + (gutter * 2),
                carouselWidth = outerWidth * setSize;

            // Update DOM
            $carousel.width(carouselWidth);
            $cards.css({
                width: cardWidth + 'px',
                'margin-left': gutter + 'px',
                'margin-right': gutter + 'px'
            });

            // Update cache
            carousel.updateDimensionsCache({
                carousel: {
                    width: carouselWidth
                },
                items: A.map(A.range(setSize), function () {
                    return {
                        width: cardWidth,
                        outerWidth: outerWidth
                    };
                })
            });

            // Update Attrs and do so loudly (silent = false)
            carousel.setAttr(ATTR.PEEK_WIDTH, peekWidth, false);

            carousel.triggerEvent('repaint');
        },

        /**
         *  If the viewport width changes, repaint.
         *
         *  @public
         *  @param {Carousel} carousel
         *
         *  triggers a:carousel:[name]:repaint
         */
        resize: function (carousel, changes) {
            if (changes.viewport && changes.viewport.width !== undefined) {
                this.repaint(carousel);
            }
        }
    };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_peekcircular.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_variablewidth.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel "Variable Width" Display Strategy
 *
 *  This is currently minimal strategy to support mobile variable width carousel.
 *
 */

"use strict";

P.when("A").register("a-carousel-display-variablewidth", function (A) {
  return {
    init: A.constants.NOOP,
    resize: A.constants.NOOP,
    repaint: A.constants.NOOP
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_variablewidth.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_display.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Display Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of display strategies provided for carousels.
 */
P.when("a-carousel-stretchygoodness", "a-carousel-display-swap", "a-carousel-display-single", "a-carousel-display-peekcircular", "a-carousel-display-variablewidth").register("a-carousel-strategies-display", function (stretchyGoodness, swap, single, peekCircular, variableWidth) {

    return {
        swap: swap,
        single: single,
        peekCircular: peekCircular,
        stretchyGoodness: stretchyGoodness,
        variableWidth: variableWidth,
        "default": "stretchyGoodness"
    };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_display.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_swap.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when("A", "jQuery", "a-carousel-utils").register("a-carousel-transition-swap", function (A, $, util) {
  /**
   *  When switching, this is the default delay between card swaps
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var DEFAULT_DELAY_TIME = 30;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I dont' misspell things.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_CIRCULAR = "circular";
  var ATTR_DELAY_TIME = "delay_time";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_LOADING = "loading";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PRELOADED_IMAGES = "preloadedImages";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_TIMER_ID = 'responsiveTimerId';
  var ATTR_TOTAL_PAGES = "totalPages";

  var EMPTY_CARD_CLASS = 'a-carousel-card-empty';

  /**
   *  When the AJAX strategy loads in new items preload the images for off-screen cells.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} fetchedItems
   */
  function preloadNewItemsOnChange(carousel, fetchedItems) {
    var preloadedImages = carousel.getAttr(ATTR_PRELOADED_IMAGES);
    if (! preloadedImages) {
      preloadedImages = [];
    }

    var imageUrls = [];
    for (var i = fetchedItems.length - 1; i >= 0; i--) {
      if (fetchedItems[i] && !preloadedImages[i]) {
        var element = util.getElementFromItem(fetchedItems[i]);
        if (element) {
          $('img', element).each(function() {
            imageUrls.push(this.src);
          });
        }
        preloadedImages[i] = true;
      }
    }

    A.preload(imageUrls);
    carousel.setAttr(ATTR_PRELOADED_IMAGES, preloadedImages);
  }


  /**
   * Get the sign -1, 0, 1, or NaN
   *
   * @param {number} x A number
   */

  function sign(x) {
    return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : isNaN(x) ? NaN : 0 : NaN;
  }

  /**
   *  When the AJAX strategy loads in new items which need to be shown immediately, this function makes sure
   *  they're added to the DOM correctly.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} fetchedItems
   */

  function showNewFetchedItems(carousel, fetchedItems) {
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);
    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    var delayIncrement = carousel.getAttr("delay_time");
    var delay = 0;
    var $items = carousel.dom.$carousel.children("li");
    var $emptyItems = $items.filter("." + EMPTY_CARD_CLASS);
    
    if ($emptyItems.length) {
      carousel.setAttr(ATTR_LOADING, true);
    }
    
    $emptyItems.each(function (idx, item) {
      var $item = $(item);
      var fetchedItemIdx = $items.index(item) + firstVisibleItem - 1;
      var fetchedItem = fetchedItems[fetchedItemIdx];
      if (fetchedItem) {
        A.delay(function () {
          util.addElementToDom($item, util.getElementFromItem(fetchedItem));
          if (idx === $emptyItems.length - 1) {
            carousel.setAttr(ATTR_LOADING, false);
          }
        }, delay + delayIncrement);
      }
    });
  }

  /**
   *  Make the carousel move to a different page
   *
   *  @param {Carousel} carousel
   *  @param {number} page  The page number to slide to (1 based)
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoPage(carousel, page, options) {
    options = options || {};
    var currentPage = carousel.getAttr(ATTR_PAGE_NUMBER);
    if (page !== currentPage) {
      var setSize = carousel.getAttr(ATTR_SET_SIZE); // one-based total number of items
      var maxPage = carousel.getAttr(ATTR_TOTAL_PAGES);
      var circular = carousel.getAttr(ATTR_CIRCULAR);

      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var delayTime = options.delayTime || carousel.getAttr(ATTR_DELAY_TIME);
      var direction = sign(options.direction) || NaN;
      var displayStrategy = carousel.strategies.display;


      if (!circular && page < 1) {
        page = 1;
      } else if (!circular && page > maxPage) {
        page = maxPage;
      } else if (circular && page < 1) {
        page = maxPage;
      } else if (circular && page > maxPage) {
        page = 1;
      }

      // We need to get the pre-load directionality
      if (!direction) {
        direction = currentPage < page ? 1 : -1;
      }

      // When starting over, replace as fast as possible
      if (options.startover) {
        delayTime = 1;
        direction = 1;
      }

      // Start the swapping animation
      var firstVisibleIndex = pageSize * (page - 1);
      var currentCellIndex = direction === 1 ? 0 : (pageSize - 1);
      
      // Updating various necessary stats at the beginning of the transition
      // There was a race condition of sorts between receiving new cards via AJAX and populating the carousel
      // wherein if the first visible item was set at the end of the transition and new data came in during a
      // transition, we could put the wrong page's cards into a given page.
      //
      // Page number was being set before the animation began, but first visible item was being set at the end
      // of the animation and the AJAX handler: showNewFetchedItems above was using the first visible item to
      // determine which items to drop into the page.
      carousel.setAttr(ATTR_PAGE_NUMBER, page);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleIndex + 1);
      carousel.setAttr(ATTR_ANIMATING, true);
      
      var timerId = A.interval(function () {
        var setIndex = firstVisibleIndex + currentCellIndex;

        // Animation complete
        if (timerId !== carousel.getAttr(ATTR_TIMER_ID)) {
          clearInterval(timerId);
        } else if ((direction === -1 && currentCellIndex < 0) || (direction === 1 && currentCellIndex >= pageSize)) {
          carousel.setAttr(ATTR_TIMER_ID, undefined);
          carousel.setAttr(ATTR_ANIMATING, false);
        } else {
          // Display ASIN / Update Cell
          var $cell = carousel.dom.$carousel.children('li').eq(currentCellIndex);

          var currentItem = carousel.getAttr(ATTR_FETCHED_ITEMS)[setIndex];
          if (currentItem) {
            util.addElementToDom($cell, util.getElementFromItem(currentItem));
          } else if (setIndex < setSize) {
            $cell.html(carousel.getStaticLoader()).addClass(EMPTY_CARD_CLASS);
          } else {
            $cell.empty().removeClass(EMPTY_CARD_CLASS);
          }

          // Move to the next cell
          currentCellIndex = currentCellIndex + direction;
        }
      }, delayTime);

      carousel.setAttr(ATTR_TIMER_ID, timerId);
    }
  }

  /**
   *  Find the page for a given index and navigate to it
   *
   *  @param {Carousel} carousel
   *  @param {number} idx  The index number of the item (1 based)
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoIndex(carousel, idx, options) {
    options = options || {};

    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var pageNumber = Math.ceil(idx / pageSize);

    gotoPage(carousel, pageNumber, options);
  }

  /**
   *  Tell the carousel to show the next page
   *
   *  @param {Carousel} carousel
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoNextPage(carousel, options) {
    options = options || {};
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);

    // Mark our direction as moving backward
    options.direction = -1;

    gotoPage(carousel, ++pageNumber, options);
  }

  /**
   *  Tell the carousel to show the previous page
   *
   *  @param {Carousel} carousel
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoPrevPage(carousel, options) {
    options = options || {};
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);

    // Mark our direction as moving forward
    options.direction = 1;

    gotoPage(carousel, --pageNumber, options);
  }

  /**
   *  Initializes the strategy.  Basically just ensures the animation speed is set.
   *
   *  @param {Carousel} carousel
   */

  function init(carousel) {
    // AUI Convention: passed arguments with underscores are public
    var delayTime = carousel.getAttr(ATTR_DELAY_TIME);
    if (!A.isFiniteNumber(delayTime)) {
      carousel.setAttr(ATTR_DELAY_TIME, DEFAULT_DELAY_TIME);
    }

    // Clean-up old timers
    carousel.onChange(ATTR_TIMER_ID, function (newTimerId, oldTimerId) {
      if (oldTimerId !== newTimerId) {
        clearInterval(oldTimerId);
      }
    });

    carousel.onChange(ATTR_FETCHED_ITEMS, function (current, old) {
      showNewFetchedItems(carousel, current);
      preloadNewItemsOnChange(carousel, current);
    });

    preloadNewItemsOnChange(carousel, carousel.getAttr(ATTR_FETCHED_ITEMS));
  }

  return {
    init: init,
    gotoIndex: gotoIndex,
    gotoNextPage: gotoNextPage,
    gotoPrevPage: gotoPrevPage,
    gotoPage: gotoPage
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_swap.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_slide.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 */

"use strict";

/**
 *  A set of default transition strategies which define behavior when the user navigates through the carousel.
 */
P.when("A", "jQuery", "a-carousel-utils", "a-carousel-constants").register("a-carousel-transition-slide", function (A, $, util, ATTR) {
  var undefined;

  /**
   *  When sliding, this is the default transition speed in pixels/second
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var DEFAULT_ANIMATION_SPEED = A.capabilities.touch ? 2000 : 3000;
  var RTL_DIRECTION_MULTIPLIER = A.capabilities.rtl ? -1 : 1;
  /**
   *  The default easing function for normal pagination
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DEFAULT_EASING = "ease-out";

  /**
   * Slide direction
   *
   * @param {SLIDE_DIRECTION} direction - clockwise or counter clockwise
   */
  var SLIDE_DIRECTION = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
  };

  /**
   *  This will put enough empty cards in the list to accomodate the total set_size.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function addEmptyCards(carousel) {
    var numItems = carousel.dom.$carousel.children("li").length;
    var firstIndex = numItems + 1;
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var cardsNeeded = setSize - numItems;

    if (cardsNeeded > 0) {
      var lastIndex = firstIndex + cardsNeeded - 1;
      var emptyItems = [];

      for (var i = firstIndex; i <= lastIndex; i++) {
        emptyItems.push(carousel.getEmptyCard(i, setSize));
      }
      carousel.dom.$carousel.append(emptyItems.join(""));

      carousel.setAttr(ATTR.LOADING, true);
      var fetchedItems = carousel.getAttr(ATTR.FETCHED_ITEMS);
      var $items = carousel.dom.$carousel.children("li");
      var $item, item;

      for (i = numItems; i < setSize; i++) {
        item = fetchedItems[i];
        // Dump the fetched HTML into the DOM
        if (item) {
          var element = util.getElementFromItem(item);
          $item = $items.eq(i);
          util.addElementToDom($item, element);

          // Remove the HTML string from memory since we don't need to hang onto it
          fetchedItems[i] = util.clearElementFromItem(item);
        }
      }

      if (carousel.strategies.display.repaint) {
        carousel.strategies.display.repaint(carousel);
      }

      // Put the new fetchedItems struct back in memory and update the dimensions cache with the item's dimensions
      carousel.setAttr(ATTR.FETCHED_ITEMS, fetchedItems, true);
      carousel.setAttr(ATTR.LOADING, false);
    }
  }


  /**
   *  When the fetchedItems object changes, this function will add any new items which were fetched to
   *  the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} newFetchedItems
   *  @param {array} oldFetchedItems
   */

  function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
    var animating = carousel.getAttr(ATTR.ANIMATING);

    if (animating) {
      carousel.once(ATTR.ANIMATING, function () {
        handleItemChanges(carousel, newFetchedItems, oldFetchedItems);
      });
    } else {
      var dimensions = carousel.getDimensions();
      var itemDimensions = dimensions.items;
      var nullIndexes = [];

      if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
        carousel.setAttr(ATTR.LOADING, true);
        var $items = carousel.dom.$carousel.children("li");
        var $item, item;

        // Iterate in reverse order so "splice" operations are easier.
        var i = newFetchedItems.length;
        while (i--) {
          item = newFetchedItems[i];

          // "null" ajax responses are an indicator to remove the element.
          // The server decided the element is no longer available.
          if (item === null) {
            nullIndexes.push(i);
          }

          // Dump the fetched HTML into the DOM...
          // When we change the fetched items array internally (end of this function), we trigger reprocessing of some items
          // We want to bail from rechecking those instead of doing it twice and occasionally triggering a TypeError
          // based on logic that never expected to run over items a second time - caused by A.copy becoming a deep copy
          // So also test if item === true or item.content === true.
          if (item && !A.equals(item, oldFetchedItems[i]) && !((item === true) || (item.content === true))) {
            var element = util.getElementFromItem(item);
            $item = $items.eq(i);
            if ($item.length) {
              util.addElementToDom($item, element);
              itemDimensions[i] = {
                width: $item.outerWidth(),
                outerWidth: $item.outerWidth(true),
                height: $item.outerHeight(),
                outerHeight: $item.outerHeight(true)
              };

              // Remove the HTML string from memory since we don't need to hang onto it
              newFetchedItems[i] = util.clearElementFromItem(item);
            }
          }
        }

        if (nullIndexes.length) {
          // Must iterate from largest to smallest. Indexes have been pushed in this order.
          A.each(nullIndexes, function (i) {
            $items.eq(i).remove();
            newFetchedItems.splice(i, 1);
          });
          carousel.setAttr(ATTR.SET_SIZE, carousel.getAttr(ATTR.SET_SIZE) - nullIndexes.length);
          // Recalculate accessibility visibility
          carousel.triggerEvent('repaint');
        }
      }

      // Put the new fetchedItems struct back in memory and update the dimensions cache with the item's dimensions
      carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
      carousel.updateDimensionsCache({
        items: itemDimensions
      });
      carousel.setAttr(ATTR.LOADING, false);
    }
  }

  return {
    /**
     *  After the entire carousel has slid off the page, wrap around and display the first page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wrapToFirst: function (carousel) {
      var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
      var itemWidth = carousel.getDimensions().getFirstCardWidth();
      var strategy = this;

      // Move the carousel to the other side of the viewport
      var px = pageSize * itemWidth * -1;
      carousel.gotoPixel(px, {
        animationDuration: 0,
        callback: function () {
          carousel.setAttr(ATTR.CURRENTLY_WRAPPING, false);
          strategy.gotoPage(carousel, 1);
        }
      });
    },
    /**
     *  After the entire carousel has slid off the page, wrap around and display the last page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wrapToLast: function (carousel) {
      var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
      var totalPages = carousel.getAttr(ATTR.TOTAL_PAGES);
      var strategy = this;

      // Move the carousel to the other side of the viewport
      var px = carousel.getDimensions().carousel.width;
      carousel.gotoPixel(px, {
        animationDuration: 0,
        callback: function () {
          carousel.setAttr(ATTR.CURRENTLY_WRAPPING, false);
          strategy.gotoPage(carousel, totalPages);
        }
      });
    },
    /**
     *  Make the carousel slide to a specific page.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} page  The page number to slide to (1 based)
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPage: function (carousel, page, options) {
      options = options || {};
      if ((options.animationDuration === undefined || options.animationDuration > 0) && !options.silent) {
        carousel.setAttr(ATTR.ANIMATING, true);
      }

      var maxPage = carousel.getAttr(ATTR.TOTAL_PAGES);
      if (page > 0 && page <= maxPage) {
        carousel.setAttr(ATTR.PAGE_NUMBER, page);
      }

      var circular = carousel.getAttr(ATTR.CIRCULAR);
      if (!circular && page < 1) {
        page = 1;
        options.animationDuration = Math.pow(carousel.getAttr(ATTR.ANIMATION_SPEED) * carousel.getAttr(ATTR.SPRINGINESS));
      } else if (!circular && page > maxPage) {
        page = maxPage;
        options.animationDuration = Math.pow(carousel.getAttr(ATTR.ANIMATION_SPEED), carousel.getAttr(ATTR.SPRINGINESS));
      }
      this.gotoIndex(carousel, (carousel.getAttr(ATTR.PAGE_SIZE) * (page - 1)) + 1, options);
    },
    /**
     *  Make the carousel slide so that a particular item is the left-most visible item in the carousel.
     *  Calling an index outside of the set of available items will cause the carousel to wrap, if not
     *  disabled.  It'll do nothing otherwise.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} idx  The index number of the item (1 based)
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoIndex: function (carousel, idx, options) {
      options = options || {};

      if ((options.animationDuration === undefined || options.animationDuration > 0) && !options.silent) {
        carousel.setAttr(ATTR.ANIMATING, true);
      }

      var allowWrap = carousel.getAttr(ATTR.CIRCULAR) && !carousel.getAttr(ATTR.CURRENTLY_WRAPPING);
      var callback = options.callback;
      var strategy = this;
      var pixel = false;
      var viewportWidth = carousel.getViewportWidth();
      var newPage = Math.ceil(idx / carousel.getAttr(ATTR.PAGE_SIZE));
      var wrapCallback;
      if (newPage !== carousel.getAttr(ATTR.PAGE_NUMBER) && newPage > 0 && newPage <= carousel.getAttr(ATTR.TOTAL_PAGES)) {
        carousel.setAttr(ATTR.PAGE_NUMBER, newPage);
      }

      carousel.setAttr(ATTR.FIRST_VISIBLE_ITEM, idx);

      if (idx < 1) {
        if (allowWrap) {
          pixel = viewportWidth * -1;
          wrapCallback = function () {
            if (callback) {
              callback();
            }
            strategy.wrapToLast(carousel);
          };
        }
      } else if (idx > carousel.getAttr(ATTR.SET_SIZE)) {
        if (allowWrap) {
          pixel = carousel.getAttr(ATTR.CURRENT_PIXEL) + viewportWidth;

          // Set new options specific to the wrapping use-case
          wrapCallback = function () {
            if (callback) {
              callback();
            }
            strategy.wrapToFirst(carousel);
          };
        }
      } else {
        pixel = carousel.getItemOffset(idx);
      }

      // We're going to be wrapping around from last to first, or first to last, so set common params
      if (wrapCallback) {
        carousel.setAttr(ATTR.CURRENTLY_WRAPPING, true);
        options.callback = wrapCallback;
        options.easingFunction = options.easingFunction || carousel.getAttr(ATTR.WRAP_EASING);
        options.animationSpeed = (A.isFiniteNumber(options.animationSpeed) ? options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED)) * 1.3;
      } else {
        options.callback = callback;
      }

      // Goto a pixel value if we need to
      if (pixel !== false) {
        this.gotoPixel(carousel, pixel, options);
      }
    },
    /**
     *  Tell the carousel to slide to a specific offset position
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} px  The pixel to slide to
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPixel: function (carousel, px, options) {
      var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
      if (px !== currentPx) {
        options = options || {};
        var easingFunction = options.easingFunction || DEFAULT_EASING;
        var callback = options.callback;
        var viewportWidth = carousel.getViewportWidth();
        var animationDuration, afterAnimate;

        if (options.animationDuration !== undefined) {
          animationDuration = options.animationDuration;
        } else {
          var pxPerSecond = A.isFiniteNumber(options.animationSpeed) ? options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED);
          var distance = Math.abs(px - currentPx);
          animationDuration = pxPerSecond === 0 ? 0 : Math.floor(distance / pxPerSecond * 1000);
        }

        if (animationDuration > 0 && !options.silent) {
          carousel.setAttr(ATTR.ANIMATING, true);
        }

        if (A.isFiniteNumber(px)) {

          if (animationDuration > 0) {
            afterAnimate = function () {
              if (callback) {
                callback();
              }
              if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
                carousel.setAttr(ATTR.ANIMATING, A.isAnimated(carousel.dom.$carousel), options.silent);
              }
            };
          } else {
            afterAnimate = callback;
          }

          //To check if the site is in RTL (right to left) mode.
          var slideDirection = (A.capabilities.rtl) ? SLIDE_DIRECTION.CLOCKWISE : SLIDE_DIRECTION.COUNTER_CLOCKWISE;

          carousel.setAttr(ATTR.CURRENT_PIXEL, px);
          A.animate(carousel.dom.$carousel, {
            "left": px * slideDirection
          }, animationDuration, easingFunction, afterAnimate);
        } else {
          P.error("Target pixel is not a finite number", "a-carousel-transition-slide", "gotoPixel");
        }
      }
    },
    /**
     *  Tell the carousel to slide to the next page
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoNextPage: function (carousel, options) {
      var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
      this.gotoPage(carousel, ++pageNumber, options);
    },
    /**
     *  Tell the carousel to slide to the previous page
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPrevPage: function (carousel, options) {
      var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
      this.gotoPage(carousel, --pageNumber, options);
    },
    /**
     *  Slide to the correct page with a custom velocity based on the movement of the user's finger
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} touch  Touch event data generated by the gesture detection library
     */
    onSwipe: function (carousel, touch) {
      if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
        var firstVisibleItem = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);
        var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
        var currentPage = carousel.getAttr(ATTR.PAGE_NUMBER);
        var goingRight = (RTL_DIRECTION_MULTIPLIER * touch.velocityX) < 0;
        var newIdx = firstVisibleItem;
        if (goingRight && currentPage < carousel.getAttr(ATTR.TOTAL_PAGES)) {
          newIdx = firstVisibleItem + pageSize;
        } else if (!goingRight && currentPage > 1) {
          newIdx = firstVisibleItem - pageSize;
        }

        // The animation speed should be based on the speed of the user's finger.  However, some sane boundaries
        // (min/max) need to be put into place in order to prevent the thing from slowing to a crawl or firing off
        // into infinity like a rocket.  Those upper and lower bounds are really just pulled out of my ass, so if
        // they need changing, feel free.
        var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
        var itemOffset = carousel.getItemOffset(newIdx);
        var dx = goingRight ? currentPx - itemOffset : currentPx + itemOffset;
        var duration = Math.abs(dx * 1000 / touch.velocityX);
        duration = Math.max(duration, 300);
        duration = Math.min(duration, A.viewport().width * 1.2);

        var options = {
          animationDuration: duration,
          easingFunction: carousel.getAttr(ATTR.TOUCH_EASING)
        };

        if (newIdx === firstVisibleItem && !carousel.getAttr("circular")) {
          options.animationSpeed = A.viewport().width * 0.95;
          delete options.animationDuration;
          carousel.gotoIndex(newIdx, options);
        } else if (goingRight) {
          carousel.gotoNextPage(options);
        } else {
          carousel.gotoPrevPage(options);
        }
      }
    },
    /**
     *  Allow the user to pan to a specific pixel based on the movement of the user's finger.
     *  When the user lifts their finger, if they haven't swiped, this will return the user
     *  to the closest page.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} touch  Touch event data generated by the gesture detection library.
     */
    onPan: function (carousel, touch) {
      if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
        carousel.setAttr(ATTR.ANIMATING, true);
        var offset = carousel.getItemOffset(carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
        var px = offset - (RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX);
        var circular = carousel.getAttr(ATTR.CIRCULAR);
        var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
        var totalPages = carousel.getAttr(ATTR.TOTAL_PAGES);

        if (touch.ended) {
          var options = {
            easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
            animationSpeed: A.viewport().width * 0.95
          };

          options.silent = true;
          var delta = RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX;

          var underThreshold = Math.abs(delta) < carousel.getViewportWidth() * 0.4;
          var pastEdge = (delta < 0 && totalPages === pageNumber) || (delta > 0 && pageNumber === 1);
          if (!circular && pastEdge || underThreshold) {
            carousel.gotoPage(pageNumber, options);
          } else if (delta < 0) {
            carousel.gotoNextPage(options);
          } else {
            carousel.gotoPrevPage(options);
          }
        } else {
          if (!circular) {
            var springiness = carousel.getAttr(ATTR.SPRINGINESS);
            if ((px < 0 && touch.touchDeltaX > 0) || (pageNumber === totalPages && touch.touchDeltaX < 0)) {
              var diff = Math.pow(Math.abs(touch.touchDeltaX), springiness);
              if (px <= 0) {
                px = diff * -1;
              } else {
                px = offset + diff;
              }
            }
          }

          carousel.gotoPixel(px, {
            easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
            animationDuration: 0,
            silent: true
          });
        }
      }
    },
    /**
     *  Initializes the strategy.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      var animationSpeed = carousel.getAttr(ATTR.ANIMATION_SPEED);
      if (!A.isFiniteNumber(animationSpeed)) {
        carousel.setAttr(ATTR.ANIMATION_SPEED, DEFAULT_ANIMATION_SPEED);
      }
      if (carousel.getAttr(ATTR.WRAP_EASING) === undefined) {
        carousel.setAttr(ATTR.WRAP_EASING, "linear");
      }

      // If the set size is greater than the number of preloaded cards, we need to create some empty ones.
      addEmptyCards(carousel);

      carousel.onChange(ATTR.FETCHED_ITEMS, function (current, old) {
        handleItemChanges(carousel, current, old);
      });

      carousel.onChange(ATTR.SET_SIZE, function (current, old) {
        if (current > old) {
          addEmptyCards(carousel);
        }
      });
    }
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_slide.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_slidecircular.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategy slide circular
 *
 */

'use strict';

P.when('A', 'a-carousel-utils', 'a-carousel-circular-utils', 'a-carousel-constants').register(
    'a-carousel-transition-slidecircular', function (A, util, circularUtil, ATTR) {

        var SLIDE_DIRECTION = {
            CLOCKWISE: 1,
            COUNTER_CLOCKWISE: -1
        };
        var EDGE_SPRING_MULTIPLIER = 0.4;
        var MIN_SWIPE_DISTANCE = 0.4;
        var RTL_DIRECTION_MULTIPLIER = A.capabilities.rtl ? -1 : 1;

        /**
         *  This will put enough empty cards in the list to accomodate the total set_size.
         *
         *  @private
         *  @param {Carousel} carousel
         */
        function addEmptyCards(carousel) {
            var cardsPresent = carousel.dom.$carousel.children('li').length;
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            var cardsNeeded = setSize - cardsPresent;
            var $card = getCard(carousel, cardsPresent);

            if (cardsNeeded > 0) {
                var firstIndex = cardsPresent + 1;
                var lastIndex = firstIndex + cardsNeeded;

                var emptyItems = A.map(A.range(firstIndex, lastIndex), function (idx) {
                    return carousel.getEmptyCard(idx, setSize);
                });
                $card.after(emptyItems.join(''));

                carousel.measure('items');
            }
        }

        /**
         * Moves the cards (in the DOM) such that there are enough cards on to the left and the right of the current
         * visible card to allow for swiping in either direction
         *
         * @private
         * @param {Carousel} carousel
         * @param {TransitionStrategy} strategy - current transition strategy
         */

        function arrangeCards(carousel, strategy) {
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            // transition will act like slideHorizontal strategy when 2 or less cards
            if (isCircularCarousel(carousel)) {
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var desiredFirstCardIdx = Math.round(carousel.getAttr(ATTR.SET_SIZE) / 2);
                var cardsToMove = calculateCardsToMove(desiredFirstCardIdx, firstCardIdx, setSize);
                if (cardsToMove.quantity !== 0) {
                    rotateCards(carousel, cardsToMove.direction, cardsToMove.quantity);
                    if (cardsToMove.direction === SLIDE_DIRECTION.CLOCKWISE) {
                        firstCardIdx -= cardsToMove.quantity;
                    }
                    else {
                        firstCardIdx += cardsToMove.quantity;
                    }
                    strategy.gotoPixel(carousel, getItemOffset(carousel, firstCardIdx), {animationDuration: 0}); // snap back to original card in viewport
                }
            }
        }

        /**
         * Calculates the number of cards that need to be moved, and the direction of rotation, to move from
         * currentIdx to destinationIdx
         *
         * @private
         * @param currentIdx
         * @param destinationIdx
         * @param setSize
         */
        function calculateCardsToMove(currentIdx, destinationIdx, setSize) {
            var result = {};
            var clockwise;
            var counterClockwise;
            if (currentIdx === destinationIdx) {
                clockwise = counterClockwise = 0;
            }
            else if (currentIdx > destinationIdx) {
                counterClockwise = currentIdx - destinationIdx;
                clockwise = setSize - counterClockwise;
            }
            else {
                clockwise = destinationIdx - currentIdx;
                counterClockwise = setSize - clockwise;
            }
            result.direction = (clockwise <= counterClockwise) ? SLIDE_DIRECTION.CLOCKWISE : SLIDE_DIRECTION.COUNTER_CLOCKWISE;
            result.quantity = Math.min(clockwise, counterClockwise);
            return result;
        }

        /**
         * Gets the card associated with the index from DOM
         *
         * @private
         * @param {Carousel} carousel
         * @param {number} idx - index of the card to be returned
         */
        function getCard(carousel, idx) {
            return carousel.dom.$carousel.children('li').eq(getRelativeIndex(carousel, idx) - 1); //DOM uses 0 based index
        }

        /**
         * Helper method to get the offset taking peek width into account
         *
         * @private
         * @param {Carousel} carousel
         * @param {Number} idx
         */
        function getItemOffset(carousel, idx) {
            var peekWidth = Math.floor(carousel.getAttr(ATTR.PEEK_WIDTH) || 0);
            var offset = carousel.getItemOffset(idx);
            return (offset - peekWidth);
        }

        /**
         * There are two different types of card indices. The cards often get moved around within the parent carousel
         * container which is called a rotation clockwise or counter-clockwise creating a difference between what is
         * present in the DOM and how the carousel manages each card.
         *
         * @private
         * @param {Carousel} carousel
         * @param {Number} idx - the index as determined by the original order of the cards in, or ajaxed into, the markup.
         * @return {Number} - the current position of the card in the carousel container
         */
        function getRelativeIndex(carousel, idx) {
            idx = idx || 1;
            var idxOfFirstCard = carousel.getAttr(ATTR.TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX);
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            return circularUtil.relativeIndexFromIndex(idx, idxOfFirstCard, setSize);
        }

        /**
         *  When the fetchedItems object changes, this function will add any new items which were fetched to
         *  the carousel.
         *
         *  @private
         *  @param {Carousel} carousel
         *  @param {array} newFetchedItems
         *  @param {array} oldFetchedItems
         */
        function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
            if (carousel.getAttr(ATTR.ANIMATING)) {
                carousel.once(ATTR.ANIMATING, function () {
                    handleItemChanges(carousel, newFetchedItems, oldFetchedItems);
                });
            } else {
                var itemDimensions = carousel.getDimensions().items;
                var itemsToProcess = Math.min(newFetchedItems.length, carousel.getAttr(ATTR.SET_SIZE));

                if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
                    carousel.setAttr(ATTR.LOADING, true);

                    A.each(A.range(itemsToProcess), function (idx) {
                        var ajaxIdx = idx; // ajax uses 0-based index
                        var crslIdx = ajaxIdx + 1; // carousel uses 1-based index

                        var item = newFetchedItems[ajaxIdx];
                        var $item = getCard(carousel, crslIdx);

                        // If the item is indeed new, update the DOM and demensionsCache
                        var itemNotProcessed = item && !((item === true) || (item.content === true));
                        if (item && !A.equals(item, oldFetchedItems[ajaxIdx]) && $item.length && itemNotProcessed) {
                            var relativeItemIdx = getRelativeIndex(carousel, crslIdx);

                            itemDimensions[relativeItemIdx] = {
                                width: $item.outerWidth(),
                                outerWidth: $item.outerWidth(true),
                                height: $item.outerHeight(),
                                outerHeight: $item.outerHeight(true)
                            };
                            util.addElementToDom($item, util.getElementFromItem(item));
                            newFetchedItems[ajaxIdx] = util.clearElementFromItem(item);
                        }
                    });
                    carousel.setAttr(ATTR.LOADING, false);
                }

                carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
                carousel.updateDimensionsCache({
                    items: itemDimensions
                });
            }
        }


        function isCircularCarousel(carousel) {
            return (carousel.getAttr(ATTR.SET_SIZE) > 2);
        }

        function getEdge(carousel) {
            var edge = {
                reached: false,
                left: false,
                right: false
            };
            if (!isCircularCarousel(carousel)) {
                var currentPage = carousel.getAttr(ATTR.PAGE_NUMBER);
                var setSize = carousel.getAttr(ATTR.SET_SIZE);
                if (currentPage === 1) {
                    edge.reached = true;
                    edge.left = true;
                }
                if (currentPage === setSize) {
                    edge.reached = true;
                    edge.right = true;
                }
            }
            return edge;
        }

        function gotoDirection(carousel, direction, options) {
            var edge = getEdge(carousel);
            var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);

            if (edge.reached && edge[direction]) {
                carousel.gotoPage(pageNumber);
                return;
            }
            var gotoNextOrPrevPage = (direction === 'right') ? carousel.gotoNextPage : carousel.gotoPrevPage
            gotoNextOrPrevPage.call(carousel, options);
        }

        /**
         * Rotate the carousel in specified direction
         *
         * @private
         * @param {Carousel} carousel
         * @param {SLIDE_DIRECTION} direction
         * @param {Number} quantity
         */
        function rotateCards(carousel, direction, quantity) {
            var firstCardIdx = carousel.getAttr(ATTR.TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX) || 1;
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            var $cards = carousel.dom.$carousel.children('li');
            var $carousel = carousel.dom.$carousel;
            if (direction === SLIDE_DIRECTION.CLOCKWISE) {
                circularUtil.rotateCW($carousel, $cards, quantity);
                firstCardIdx = circularUtil.firstCardIndexAfterRotate(quantity, firstCardIdx, setSize);
            } else {
                circularUtil.rotateCCW(carousel.dom.$carousel, carousel.dom.$carousel.children('li'), quantity);
                firstCardIdx = circularUtil.firstCardIndexAfterRotate((-1 * quantity), firstCardIdx, setSize);
            }
            carousel.setAttr(ATTR.TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX, firstCardIdx);
            updateDimension(carousel, quantity, direction);
        }


        /**
         * Slides the carousel clockwise/counter-clockwise by quantity. Carousel shows the card that's in the middle,
         * for peek to work the carousel shoul have card in both left or right hand side of the viewport. This involves
         * 1. Move the necessary number of cards to the direction of slide
         * 2. Make sure that the same card that was visible in the viewport before rotating (reposition)
         * 3. Animate the cards
         *
         * @private
         * @param carousel
         * @param direction
         * @param strategy
         * @param quantity
         * @param options
         */
        function slide(carousel, direction, strategy, quantity, options) {
            var originalCallback = options.callback;
            var currentVisibleCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
            var deltaPx = carousel.getAttr(ATTR.CURRENT_PIXEL) - getItemOffset(carousel, currentVisibleCardIdx);

            function rotate(next) {
                // move desired number of cards
                rotateCards(carousel, direction, quantity);
                next();
            }

            function reposition(next) {
                // reposition the viewport to ensure card that was visible before rotation is still visible
                var cardIndex = (direction === SLIDE_DIRECTION.CLOCKWISE) ?
                    (currentVisibleCardIdx - quantity) : (currentVisibleCardIdx + quantity);

                strategy.gotoPixel(carousel, getItemOffset(carousel, cardIndex) + deltaPx,
                    {animationDuration: 0, callback: next});
            }

            function animate(next) {
                // slide animation
                options.callback = next;
                strategy.gotoPixel(carousel, getItemOffset(carousel, currentVisibleCardIdx), options);
            }

            function rearrange(next) {
                // balancing carousel such that equal number of cards are present in either side of viewport
                arrangeCards(carousel, strategy);
                next();
            }

            function triggerCallback(next) {
                if (originalCallback) {
                    originalCallback();
                }
                next();
            }

            A.sequence(rotate, reposition, animate, rearrange, triggerCallback)();

        }

        /**
         * updates dimensions to reflect rotation of cards
         *
         * @private
         * @param {Carousel} carousel
         * @param {number} quantity
         * @param {number} direction - clockwise or counter clockwise
         */

        function updateDimension(carousel, quantity, direction) {
            quantity = quantity || 1;
            direction = direction || SLIDE_DIRECTION.CLOCKWISE;
            var dimensionItems = carousel.getDimensions().items;

            if (direction === SLIDE_DIRECTION.CLOCKWISE) {
                dimensionItems = circularUtil.rotateArrayCW(dimensionItems, quantity);
            }
            else {
                dimensionItems = circularUtil.rotateArrayCCW(dimensionItems, quantity);
            }
            carousel.updateDimensionsCache({
                items: dimensionItems
            });
        }


        function defaultFiniteNumber(defaultValue) {
            return function (initValue) {
                return A.isFiniteNumber(initValue) ? initValue : defaultValue;
            };
        }


        var DEFAULT_ANIMATION_SPEED = A.capabilities.touch ? 2000 : 3000; // in pixel/second
        var DEFAULT_EASING = 'ease-out';

        var initAttrs = {};
        initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
        initAttrs[ATTR.ANIMATION_SPEED] = defaultFiniteNumber(DEFAULT_ANIMATION_SPEED);
        initAttrs[ATTR.TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX] = 1;

        return {
            initAttrs: initAttrs,

            /**
             *  Add empty card, updates ajaxed in content and bind attr handlers
             *
             *  @public
             *  @param carousel
             */
            init: function (carousel) {
                addEmptyCards(carousel);

                carousel.onChange(ATTR.FETCHED_ITEMS, function (current, old) {
                    handleItemChanges(carousel, current, old);
                    carousel.strategies.display.repaint(carousel);
                });

                carousel.onChange(ATTR.SET_SIZE, function (current, old) {
                    if (current > old) {
                        addEmptyCards(carousel);
                    }
                });
                carousel.onChange(ATTR.PEEK_WIDTH, function (current, old) {
                    if (current !== old) {
                        var idx = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);
                        carousel.gotoIndex(idx);
                    }
                })
            },

            /**
             *  Balances the card carousl such that equal number of cards are present on either side of viewport
             *
             *  @public
             *  @param carousel
             */
            afterInit: function (carousel) {
                arrangeCards(carousel, this);
                carousel.strategies.display.repaint(carousel);
                carousel.gotoPage(carousel.getAttr(ATTR.PAGE_NUMBER));
            },
            gotoPage: function (carousel, page, options) {
                options = options || {};
                var maxPage = carousel.getAttr(ATTR.TOTAL_PAGES);
                if (page > 0 && page <= maxPage) {
                    carousel.setAttr(ATTR.PAGE_NUMBER, page);
                    this.gotoIndex(carousel, (carousel.getAttr(ATTR.PAGE_SIZE) * (page - 1)) + 1, options);
                }
            },
            gotoIndex: function (carousel, idx, options) {
                var setSize = carousel.getAttr(ATTR.SET_SIZE);
                var relativeIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var desiredRelativeIdx = getRelativeIndex(carousel, idx);
                if (relativeIdx === desiredRelativeIdx) {
                    this.gotoPixel(carousel, getItemOffset(carousel, relativeIdx), options);
                    return;
                }

                if (isCircularCarousel(carousel)) {
                    var cardsToMove = calculateCardsToMove(relativeIdx, desiredRelativeIdx, setSize);
                    // in case of of start over, the animation should be snappy
                    if (options.startover) {
                        if (cardsToMove.quantity > 5) {
                            options.animationDuration = 1250;
                        } else {
                            delete options.animationDuration;
                            options.animationSpeed = carousel.getDimensions().viewport.width * 5;
                        }
                    }
                    slide(carousel, cardsToMove.direction, this, cardsToMove.quantity, options);
                } else {
                    this.gotoPixel(carousel, getItemOffset(carousel, idx), options);
                }
                carousel.setAttr(ATTR.FIRST_VISIBLE_ITEM, idx);
            },
            gotoPixel: function (carousel, desiredPx, options) {
                var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
                if (desiredPx === currentPx) {
                    return;
                }

                if (!A.isFiniteNumber(desiredPx)) {
                    P.error('Target pixel is not a finite number', 'a-carousel-transition-slide-circular', 'gotoPixel');
                }

                options = options || {};
                var easingFunction = options.easingFunction || DEFAULT_EASING;
                var afterAnimate = options.callback;
                var animationDuration;

                if (options.animationDuration !== undefined) {
                    animationDuration = options.animationDuration;
                } else {
                    var pxPerSecond = A.isFiniteNumber(options.animationSpeed) ?
                        options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED);
                    var distance = Math.abs(desiredPx - currentPx);
                    animationDuration = pxPerSecond === 0 ? 0 :
                        Math.floor(distance / pxPerSecond * 1000);
                }

                if (animationDuration > 0) {
                    !options.silent && carousel.setAttr(ATTR.ANIMATING, true);
                    afterAnimate = function () {
                        if (options.callback) {
                            options.callback();
                        }
                        carousel.setAttr(ATTR.ANIMATING, A.isAnimated(carousel.dom.$carousel), options.silent);
                    };
                }

                //To check if the site is in RTL (right to left) mode.
                var slideDirection = (A.capabilities.rtl) ? SLIDE_DIRECTION.CLOCKWISE : SLIDE_DIRECTION.COUNTER_CLOCKWISE;

                carousel.setAttr(ATTR.CURRENT_PIXEL, desiredPx);
                A.animate(carousel.dom.$carousel, {
                    left: desiredPx * slideDirection
                }, animationDuration, easingFunction, afterAnimate);
            },
            gotoNextPage: function (carousel, options) {
                var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
                pageNumber = (pageNumber === carousel.getAttr(ATTR.TOTAL_PAGES)) ? 1 : pageNumber + 1;
                this.gotoPage(carousel, pageNumber, options);

            },
            gotoPrevPage: function (carousel, options) {
                var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
                pageNumber = (pageNumber === 1) ? carousel.getAttr(ATTR.TOTAL_PAGES) : (pageNumber - 1);
                this.gotoPage(carousel, pageNumber, options);
            },
            /**
             *  Delegates swipe events to gotoNextPage/PrevPage based on thresholds
             *  @param carousel
             *  @param touch
             */
            onSwipe: function (carousel, touch) {
                var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
                var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));

                // Calculate Duration
                var goingRight = (RTL_DIRECTION_MULTIPLIER * touch.velocityX) < 0;
                var newIdx = goingRight ? firstCardIdx + pageSize : firstCardIdx - pageSize;
                var itemOffset = getItemOffset(carousel, newIdx);
                var dx = goingRight ? currentPx - itemOffset : currentPx + itemOffset;
                var duration = Math.abs(dx * 1000 / touch.velocityX);

                var maxDuration = 300,
                    minDuration = A.viewport().width * 1.2;

                var direction = (RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX) < 0 ? 'right' : 'left';
                gotoDirection(carousel, direction, {
                    animationDuration: Math.min(Math.max(duration, maxDuration), minDuration),
                    easingFunction: carousel.getAttr(ATTR.TOUCH_EASING)
                });

            },
            /**
             *  Allow the user to pan to a specific pixel based on the movement of the user's finger.
             *  When the user lifts their finger, if they haven't swiped, this will return the user
             *  to the closest page.
             *
             *  @public
             *  @param {Carousel} carousel
             *  @param {object} touch  Touch event data generated by the gesture detection library.
             */
            onPan: function (carousel, touch) {
                carousel.setAttr(ATTR.ANIMATING, true);
                var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var offset = getItemOffset(carousel, firstCardIdx);
                var px;
                if (getEdge(carousel).reached) {
                    px = offset - (RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX) * EDGE_SPRING_MULTIPLIER;
                } else {
                    px = offset - (RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX);
                }

                if (touch.ended) {
                    var options = {
                        easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
                        animationSpeed: A.viewport().width * 0.95,
                        silent: true
                    };

                    var isSwipe = Math.abs(touch.touchDeltaX) >= carousel.getViewportWidth() * MIN_SWIPE_DISTANCE;
                    if (isSwipe) {
                        var direction = (RTL_DIRECTION_MULTIPLIER * touch.touchDeltaX) < 0 ? 'right' : 'left';
                        gotoDirection(carousel, direction, options);
                    } else {
                        carousel.gotoPage(pageNumber, options);
                    }
                } else {
                    carousel.gotoPixel(px, {
                        easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
                        animationDuration: 0,
                        silent: true
                    });
                }
            }
        };
    });
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_slidecircular.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_freescroll.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 *  This is currently minimal strategy to support mobile variable width carousel.
 *
 */

'use strict';

P.when('A', 'a-carousel-utils', 'a-carousel-constants').register('a-carousel-transition-freescroll', function (A, util, ATTR) {

  /**
   *  Constants for attribute names.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_NEXT_REQUEST_SIZE = 'next_request_size';
  var ATTR_LOADING_THRESHOLD_PIXELS = 'loading_threshold_pixels';
  var ATTR_AJAX_LOCK = "ajaxLock";

  // Import CarouselInteractions
  /* Importing js/strategies/transition/_carousel_strategies_transition_freescroll_interactions.js */
/**
 * CarouselInteractions factory method returns instance for provided carousel.
 * @private
 */
function carouselInteractions(carousel) {
  if (!carouselInteractionsInstances[carousel.__id]) {
    carouselInteractionsInstances[carousel.__id] = new CarouselInteractions(carousel);
  }
  return carouselInteractionsInstances[carousel.__id];
}

// tracks CarouselInteractions instances by carousel id
var carouselInteractionsInstances = {};

/**
 * CarouselInteractions encapsulates carousel API and DOM interactions for freescroll transtion strategy.
 * @private
 */
var CarouselInteractions = function(carousel) {
  this.carousel = carousel;
}
A.extend(CarouselInteractions.prototype, {
  setAttr: function(name, value) {
    return this.carousel.setAttr(name, value);
  },
  getAttr: function(name) {
    return this.carousel.getAttr(name);
  },
  onChange: function(attr, changeCallback) {
    this.carousel.onChange(attr, changeCallback);
  },
  getItems: function() {
    return this.carousel.dom.$carousel.children('li');
  },
  countItems: function() {
    return this.getItems().length;
  },
  showItems: function() {
    return this.getItems().css('visibility', '').attr('aria-hidden', 'false');
  },
  getEmptyCard: function(cardIndex, setSize) {
    return this.carousel.getEmptyCard(cardIndex, setSize);
  },
  getEmptyCards: function() {
    return this.carousel.dom.$carousel.children('.a-carousel-card-empty');
  },
  hasEmptyCard: function() {
    return this.getEmptyCards().length > 0;
  },
  getFirstEmptyDetails: function() {
    var $empty = this.getEmptyCards();
    if ($empty.length > 0) {
      var $card = $empty.first();
      return {
        index: $card.index(),
        left: $card.position().left
      };
    } else {
      return {
        index: -1,
        left: -1
      };
    }
  },
  appendItems: function(items) {
    this.carousel.dom.$carousel.append(items.join(''));
  },
  hasItem: function(items, i) {
    return items.eq(i).length > 0;
  },
  insertFetchedItem: function(fetchedItem, items, i) {
    util.addElementToDom(items.eq(i), util.getElementFromItem(fetchedItem));
    return util.clearElementFromItem(fetchedItem);
  },
  attachScrollListener: function(scrollCallback) {
    this.carousel.dom.$carousel.bind(A.action.move + '.a-carousel-freeScroll scroll.a-carousel-freeScroll', scrollCallback);
  },
  detachScrollListener: function(scrollCallback) {
    this.carousel.dom.$carousel.unbind('.a-carousel-freeScroll');
  },
  measureWidth: function() {
    return this.carousel.dom.$carousel.outerWidth();
  },
  wantNext: function(index, nextRequestSize) {
    this.carousel.strategies.ajax.want(this.carousel, index, nextRequestSize);
  },
  throttle: function(name, fn) {
    var carouselInteractions = this;
    // Clear throttle timeout
    clearTimeout(carouselInteractions[name]);
    // Schedule throttled scroll handling
    carouselInteractions[name] = setTimeout(function() {
      fn(carouselInteractions);
    }, 100);
  }
});
/* Done importing js/strategies/transition/_carousel_strategies_transition_freescroll_interactions.js */


  /**
   *  Prepare fetched items attribute based on preloaded items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function prepareFetchedItems(carousel) {
      var numItems = carousel.countItems();
      var fetchedItems = [];

      for (var i = 0; i < numItems; i++) {
          fetchedItems.push(true);
      }
      carousel.setAttr(ATTR.FETCHED_ITEMS, fetchedItems);
  }

  /**
   *  This will put enough empty cards in the list to accomodate the total set_size.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function addEmptyCards(carousel) {
    var numItems = carousel.countItems();
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var emptyItems = [];
    var cardIndex;

    if (setSize > numItems) {
      for (var i = 0; i < (setSize - numItems); i++) {
        cardIndex = numItems + i + 1; // one based index, offset by existing cards
        emptyItems.push(carousel.getEmptyCard(cardIndex, setSize));
      }
      carousel.appendItems(emptyItems);
    }
  }

  /**
   *  When the fetchedItems object changes, this function will add any new items which were fetched to
   *  the carousel.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   *  @param {array} newFetchedItems
   *  @param {array} oldFetchedItems
   */

  function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
    if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
      var items = carousel.getItems();
      var i = newFetchedItems.length;
      var fetched;
      while (i--) {
        fetched = newFetchedItems[i];
        // Dump the fetched HTML into the DOM...
        // Uses skip reprocessing pattern from slide transition handleItemChanges function
        if (fetched && !A.equals(fetched, oldFetchedItems[i]) && !((fetched === true) || (fetched.content === true))) {
          if (carousel.hasItem(items, i)) {
            newFetchedItems[i] = carousel.insertFetchedItem(fetched, items, i);
          }
        }
      }
    }
    // Put the new fetchedItems struct back in memory
    carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
  }

  /**
   * Add scroll listener to carousel if empty cards present. Throttles scroll events.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function addScrollListener(carousel) {
    // Add handler when empty cards present.
    if (carousel.hasEmptyCard()) {
      carousel.attachScrollListener(function() {
        carousel.throttle('detect', detectEmptyCardsLoadingThreshold);
      });
    }
  }

  /**
   * Check if scroll listener still necessary for carousel, if not remove.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function checkScrollListener(carousel) {
    // Remove handler when empty cards not present.
    if (!carousel.hasEmptyCard()) {
      carousel.detachScrollListener();
    }
  }

  /**
   * Determines when to request next items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function detectEmptyCardsLoadingThreshold(carousel) {
      var loadingThresholdPixels = carousel.getAttr(ATTR_LOADING_THRESHOLD_PIXELS);
      var carouselWidth = carousel.measureWidth();
      var emptyCard = carousel.getFirstEmptyDetails();

      // check if first empty card is in view
      if (emptyCard.index !== -1 && emptyCard.left < carouselWidth + loadingThresholdPixels) {
        next(carousel, emptyCard.index);
      } else {
        // continue to check loading threshold for momentum scrolling
        if (carousel.previousCardLeft && carousel.previousCardLeft !== emptyCard.left) {
          carousel.throttle('detect', detectEmptyCardsLoadingThreshold);
        }
        carousel.previousCardLeft = emptyCard.left;
      }
  }

  /**
   * Inform ajax strategy of want for additional items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   *  @param {int} index
   */
  function next(carousel, index) {
    carousel.wantNext(index, carousel.getAttr(ATTR_NEXT_REQUEST_SIZE));
  }

  var initAttrs = {};
  initAttrs[ATTR_AJAX_LOCK] = true;
  initAttrs[ATTR.NO_TRANSITION] = true;
  initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
  initAttrs[ATTR.AUTO_ADJUST_HEIGHT] = false;
  initAttrs[ATTR_NEXT_REQUEST_SIZE] = 10;
  initAttrs[ATTR_LOADING_THRESHOLD_PIXELS] = 400;

  return {
    gotoIndex: A.constants.NOOP,
    gotoNextpage: A.constants.NOOP,
    gotoPrevPage: A.constants.NOOP,
    gotoPage: A.constants.NOOP,
    initAttrs: initAttrs,
    init: function (rawCarousel) {
      var carousel = carouselInteractions(rawCarousel);
      carousel.showItems();

      prepareFetchedItems(carousel);
      addEmptyCards(carousel);
      addScrollListener(carousel);

      carousel.onChange(ATTR.FETCHED_ITEMS, function (current, old) {
        detectEmptyCardsLoadingThreshold(carousel);
        handleItemChanges(carousel, current, old);
        checkScrollListener(carousel);
      });

      // orientation change may require loading cards
      A.on.resize(function() {
        detectEmptyCardsLoadingThreshold(carousel);
      });
    },
    afterInit : function(rawCarousel) {
      var carousel = carouselInteractions(rawCarousel);
      A.delay(function() {
        carousel.setAttr(ATTR_AJAX_LOCK, false);
        detectEmptyCardsLoadingThreshold(carousel);
      });
    },
    // visible for testing
    prepareFetchedItems: prepareFetchedItems,
    addEmptyCards: addEmptyCards,
    handleItemChanges: handleItemChanges,
    detectEmptyCardsLoadingThreshold: detectEmptyCardsLoadingThreshold,
    ATTR: {
      NEXT_REQUEST_SIZE: ATTR_NEXT_REQUEST_SIZE,
      LOADING_THRESHOLD_PIXELS: ATTR_LOADING_THRESHOLD_PIXELS
    }
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_freescroll.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_transition.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 */

"use strict";

/**
 *  A set of default transition strategies which define behavior when the user navigates through the carousel.
 */
P.when("A", "jQuery", "a-carousel-transition-slide", "a-carousel-transition-swap", "a-carousel-transition-freescroll", "a-carousel-transition-slidecircular", "a-carousel-constants").register("a-carousel-strategies-transition", function (A, $, slide, swap, freeScroll, slideCircular, ATTR) {

  var initAttrs = {};
  initAttrs[ATTR.NO_TRANSITION] = true;
  initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
  initAttrs[ATTR.AUTO_ADJUST_HEIGHT] = false;

  return {
    slideHorizontal: slide,
    swap: swap,
    freeScroll: freeScroll,
    slideCircular: slideCircular,
    none: {
      gotoIndex: A.constants.NOOP,
      gotoNextPage: A.constants.NOOP,
      gotoPrevPage: A.constants.NOOP,
      gotoPage: A.constants.NOOP,
      initAttrs: initAttrs,
      init: function (carousel) {
        carousel.dom.$carousel.children("li").css("visibility", "").attr("aria-hidden", "false");
      }
    },
    "default": "slideHorizontal"
  };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_transition.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/ajax/carousel_strategies_ajax_standard.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel AJAX Strategies
 *
 */

"use strict";

/**
 *  Generate the default AJAX strategy for use in a Carousel.  This strategy involves queued fetching based on AJAX
 *  endpoint and optional prefetching the next page for the user
 */
P.when("A").register("a-carousel-ajax-standard", function (A) {
  var undefined;

  /**
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_FETCH_DELAY = 500;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_AJAX_HASH = "ajax";
  var ATTR_SHOW_PARTIAL_NEXT = "show_partial_next";
  var ATTR_REQUEST_TIMER = "requestTimer";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_AJAX_LOCK = "ajaxLock";
  var ATTR_LOADING = "loading";

  /**
   * Blurb including a link to a wiki page that details AJAX response formatting.
   *  @private
   *  @constant
   *  @type {String}
   */
  var AJAX_WIKI_LINK = " - see http://tiny/c1mr5h0u for details.";

  /**
   *  Fires an AJAX request to fetch more items in the Carousel
   *
   *  @private
   *  @param {Carousel} carousel - The carousel which will be receiving the fetched items
   *  @param {String} url - The AJAX endpoint to hit
   *  @param {Object} params - HTTP request parameters to send
   *  @param {Object} headers - HTTP headers to send
   */

  function sendRequest(carousel, url, params, headers) {
    var success = function (data) {
      data = _getValidatedData(data, url);

      if(data === null) {
        P.error("Invalid JSON returned to carousel from " + url + AJAX_WIKI_LINK, "a-carousel-ajax-standard", "sendRequest");
        return;
      }

      // If the carousel needed a set_size, we need need to get it from the returned data
      if (params.needSetSize) {
        if (!data || !data.length) {
          P.error("Carousel requires a set_size and none was returned by the fallback AJAX request at: " + url, "a-carousel-ajax-standard", "sendRequest");
        }
        var setSize = data[0].setSize ? data[0].setSize : data.length;
        carousel.setAttr(ATTR_SET_SIZE, setSize);
      }

      // Get the current set of fetchedItems and add the returned data to the array
      var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);

      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      var nullResponseIndexes = [];
      var item;
      var i = data.length;
      while (i--) {
        item = data[i];

        // Collect the null responses for later removal
        if (item === null) {
          nullResponseIndexes.push(i);
        }

        // Check if the item is not somehow null and then act on it based on one of the two accepted patterns for AJAX response
        // [{"content":"blahblahblah"}, ...] or
        // ["blahblahblah", ...]
        if (item) {
          if (item.content || item.content === "") {
            item.content = A.trim(item.content);
          } else {
            item = A.trim(item);
          }
        }

        fetchedItems[params.offset + i] = item;
      }

      if (ajax.remove_nulls && ajax.id_list) {
        if (nullResponseIndexes.length) {
          A.each(nullResponseIndexes, function (indexToRemove) {
            ajax.id_list.splice(params.offset + indexToRemove, 1);
          });
          carousel.setAttr(ATTR_AJAX_HASH, ajax);
        }
      }

      // If the carousel didn't have a set_size, it didn't initialize.  Do that now.
      if (params.needSetSize) {
        carousel.init();
      }

      carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems);

      // Allow the want functions to trigger AJAX calls again
      carousel.setAttr(ATTR_AJAX_LOCK, false);
      if (params.needSetSize && carousel.getAttr(ATTR_PAGE_SIZE) >= fetchedItems.length) {
        carousel.strategies.ajax.wantCurrentPage(carousel);
      }

      // Useful event for metrics
      carousel.triggerEvent("ajaxSuccess", {
        url: url,
        params: params
      });
    };

    // Useful event for metrics
    carousel.triggerEvent("beforeAjax", {
      url: url,
      params: params
    });

    A.get(url, {
      cache: false,
      success: success,
      params: params,
      headers: headers
    });
  }

  /**
   *  If another fetch is requested before the queued request is fired, we need to clear out
   *  that queued request.
   *
   *  @private
   *  @param {Carousel} carousel - The carousel to check
   */

  function clearRequestQueue(carousel) {
    var timer = carousel.getAttr(ATTR_REQUEST_TIMER);
    if (timer) {
      clearTimeout(timer);
      carousel.setAttr(ATTR_REQUEST_TIMER, null);
    }
  }

  /**
   *  Validate that AJAX response is properly formatted; return the array
   *  of carousel items if it is or null if it is invalid JSON.
   *
   *  @private
   *  @param {object} data - the JSON data returned from the AJAX call
   *  @param {string} url - the URL of the AJAX call
   */
  function _getValidatedData(data, url) {
    // We support array because this is how we used to tell teams to construct the code
    // Now, we expect users to return a JSON object that looks like:
    // { data: [/* card data goes here */] }
    if(A.isArray(data)) {
      // NOTE: turning off warning for now due to false alarms (tt/0058346174).  Turn back on in
      // 3.15.9 or 3.15.10 after SIMS has updated their carousels to use the new format.
      //P.log("Invalid carousel AJAX format from " + url + AJAX_WIKI_LINK, "WARN", "a-carousel-ajax-standard");
      return data;
    }

    if(data === undefined || data === null || A.objectIsEmpty(data) || !data.hasOwnProperty('data') || !A.isArray(data.data)) {
      return null;
    }

    return data.data;
  }

  return {
    /**
     *  AJAX requests should have a slight delay in case the user spams the next or prev buttons.
     *  Queue up a request with a given delay.
     *
     *  @public
     *  @param {Carousel} carousel - The carousel which will be receiving the fetched items
     *  @param {String} url - The AJAX endpoint to hit
     *  @param {Object} params - HTTP request parameters to send
     *  @param {Object} headers - HTTP request headers to send
     */
    getItems: function (carousel, url, params, headers) {
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      carousel.setAttr(
        ATTR_REQUEST_TIMER,
        A.delay(sendRequest, ajax.fetch_delay, carousel, url, params, headers)
      );
    },
    /**
     *  Convenience method which calls want on the current and next page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantNextPage: function (carousel) {
      clearRequestQueue(carousel);
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (ajax.prefetch_next_page) {
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var size = pageSize * 2;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT)) {
          size++;
        }
        this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize, size);
      } else {
        this.wantCurrentPage(carousel);
      }

    },
    /**
     *  Convenience method which calls want on the current and previous page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantPrevPage: function (carousel) {
      clearRequestQueue(carousel);
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (ajax.prefetch_next_page) {
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var size = pageSize * 2;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT)) {
          size++;
        }
        this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 2) * pageSize, size);
      } else {
        this.wantCurrentPage(carousel);
      }
    },
    /**
     *  Convenience method which calls want on the current page
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantCurrentPage: function (carousel) {
      clearRequestQueue(carousel);
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var size = carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT) ? pageSize + 1 : pageSize;
      this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize, size);
    },
    /**
     *  Expresses a desire for a set of indexes.  Will queue up a fetch for indexes which haven't been fetched.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {Number} startIdx - The index of the first item in the set which is desired
     *  @param {Number} size - The number of items desired.
     */
    want: function (carousel, startIdx, size) {
      if (!carousel.getAttr(ATTR_AJAX_LOCK)) {
        clearRequestQueue(carousel);
        var ajax = carousel.getAttr(ATTR_AJAX_HASH);
        var setSize = carousel.getAttr(ATTR_SET_SIZE);
        if (ajax.url) {
          var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
          var ids = ajax.id_list;
          if (!ids) {
            ids = [];
          }
          var current = startIdx > -1 ? startIdx : 0;
          var end = startIdx + size - 1;
          var params = ajax.params || {};
          var headers = ajax.headers || {};
          var idsToFetch = [];
          var itemsToFetch = [];
          var id;
          if (setSize === 0) {
            if (ids.length) {
              setSize = ids;
            }
            params.needSetSize = "true";
            carousel.setAttr(ATTR_AJAX_LOCK, true);
          }
          if (size === -1 && setSize) {
            end = setSize;
          }
          while (current <= end && current < setSize) {
            if (!fetchedItems[current]) {
              id = ids[current];
              if (id) {
                idsToFetch.push(id);
              }
              itemsToFetch.push(current);
              fetchedItems[current] = false;
            }
            current++;
          }
          carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems, {
            silent: true
          });

          params.count = itemsToFetch.length;
          params.offset = itemsToFetch[0] || 0;
          if (idsToFetch.length > 0) {
            params[ajax.id_param_name] = idsToFetch.join(",");
          }
          if (itemsToFetch.length > 0 || params.needSetSize) {
            this.getItems(carousel, ajax.url, params, headers);
          }
        }
      }
    },
    /**
     *  Sets up the default for the AJAX queue fetch delay.
     *  Fetches missing items for the current page and optionally fetches the next page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      // Set some defaults
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (!A.isFiniteNumber(ajax.fetch_delay)) {
        ajax.fetch_delay = DEFAULT_FETCH_DELAY;
      }
      ajax.id_param_name = ajax.id_param_name || "ids";
      ajax.prefetch_next_page = ajax.prefetch_next_page === undefined ? true : !!ajax.prefetch_next_page;

      carousel.setAttr(ATTR_AJAX_HASH, ajax);

      if (!carousel.getAttr(ATTR_SET_SIZE)) {
        this.want(carousel, 0, -1);
      }
    },
    /**
     *  Ensure that all fetching is done after all change handlers have been bound.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    afterInit: function (carousel) {
      // Make sure we have enough items to fill the current page
      carousel.strategies.ajax.wantCurrentPage(carousel);

      // When the page number changes, we might have to get more items
      carousel.onChange(ATTR_PAGE_NUMBER, function (current, old) {
        if (current > old) {
          carousel.strategies.ajax.wantNextPage(carousel);
        } else {
          carousel.strategies.ajax.wantPrevPage(carousel);
        }
      });

      carousel.onChange(ATTR_LOADING, function (isLoading) {
        if (!isLoading) {
          carousel.strategies.ajax.wantCurrentPage(carousel);
        }
      })
    }
  };
});
/////////////////////////
// END FILE js/strategies/ajax/carousel_strategies_ajax_standard.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/ajax/carousel_strategies_ajax_promise.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AmazonUI Carousel Ajax - Promise Strategy
 * 
 * Does not support options:
 * - show_partial_next
 * - prefetch_next_page (default is true, no option to disable)
 * - url (Not relevant for Promise-based provider)
 * - id_param_name (Not relevant for Promise-based provider)
 * 
 * Requires `set_size` on CarouselContainer.
 * 
 * Client must register an async_provider, a method with the signature:
 * 
 * ```
 * (indexes: number[], ids?: string[]) => Promise<string|Element[]>
 * ```
 *
 * If strings are returned, they are treated as the inner html to new carousel items.
 *
 * If Elements are returned, they are appended as child elements in new carousel items.
 *
 * If <aui:CarouselElementFragment>s are returned, their contents are appended in new carousel items.
 * This is helpful if your carousel items contain a loose collection of elements and text without a wrapper element.
 * 
 * For example:
 * 
 * ```
 * var carousel = CarouselFramework.getCarousel(carouselContainerElement);
 * carousel.setAttr('async_provider', function (indexes, ids) {
 *   return fetch('my-ajax-endpoint', { params: ids })
 *     .then(function (response) { return response.json(); })
 *     .then(function (response) { return response.data; });
 * });
 * ```
 */

"use strict";

P.when("a-util").register("a-carousel-ajax-promise", function (util) {
  var DEFAULT_FETCH_DELAY = 500;
  var ATTR_ASYNC_PROVIDER = "async_provider";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_AJAX_HASH = "ajax";
  var ATTR_REQUEST_TIMER = "requestTimer";
  var ATTR_SET_SIZE = "set_size";

  /**
   * Debounce requests per-carousel, not global
   *
   * @private
   * @param {Carousel} carousel - The carousel scope
   * @param {Function} fn - The function to debounce
   */
  function debounce(carousel, fn) {
    var timer = carousel.getAttr(ATTR_REQUEST_TIMER);
    if (timer) {
      clearTimeout(timer);
    }
    carousel.setAttr(ATTR_REQUEST_TIMER, util.delay(fn, DEFAULT_FETCH_DELAY));
  }

  return {
    /**
     * Async requests should have a slight delay in case the user spams the next or prev buttons.
     * Queue up a request with a given delay.
     *
     * @public
     * @param {Carousel} carousel - The carousel which will be receiving the fetched items
     * @param {number[]} indexesToFetch - array of carousel item indexes to fetch
     * @param {string[]} idsToFetch - Optional corresponding array of ids to fetch
     */
    getItems: function (carousel, indexesToFetch, idsToFetch) {
      debounce(carousel, function () {
        var provider = carousel.getAttr(ATTR_ASYNC_PROVIDER);
        if (!provider) {
          // Client has not registered their provider yet.
          // Once it's registered, `wantCurrentPage` will automatically call,
          // which will call this method again.
          return;
        }
        provider(indexesToFetch, idsToFetch).then(function (newItems) {
          // Get the current set of fetchedItems and add the returned data to the array
          var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
    
          util.each(newItems, function (item, index) {
            fetchedItems[indexesToFetch[index]] = item;
          });
      
          carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems);
        });
      });
    },

    /**
     * Convenience method which calls want on the current and next page.
     *
     * @public
     * @param {Carousel} carousel
     */
    wantNextPage: function (carousel) {
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var startIndex = (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize;
      var size = pageSize * 2;
      this.want(carousel, startIndex, size);
    },

    /**
     * Convenience method which calls want on the current and previous page.
     *
     * @public
     * @param {Carousel} carousel
     */
    wantPrevPage: function (carousel) {
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var startIndex = (carousel.getAttr(ATTR_PAGE_NUMBER) - 2) * pageSize;
      var size = pageSize * 2;
      this.want(carousel, startIndex, size);
    },

    /**
     * Convenience method which calls want on the current page
     *
     * @public
     * @param {Carousel} carousel
     */
    wantCurrentPage: function (carousel) {
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var startIndex = (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize;
      var wantSize = pageSize;
      this.want(carousel, startIndex, wantSize);
    },

    /**
     * Expresses a desire for a set of indexes.
     * Will queue up a fetch for indexes which haven't been fetched.
     *
     * @public
     * @param {Carousel} carousel
     * @param {Number} startIndex - The index of the first item in the set which is desired
     * @param {Number} wantSize - The number of items desired.
     */
    want: function (carousel, startIndex, wantSize) {
      // "Proposed" fetch range [start, end)
      startIndex = Math.max(0, startIndex);
      var endIndex = Math.min(startIndex + wantSize, carousel.getAttr(ATTR_SET_SIZE));

      // Trim the proposed fetch range into only what is needed
      var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);

      var indexesToFetch = [];
      for (var index = startIndex; index < endIndex; index++) {
        if (!fetchedItems[index]) {
          indexesToFetch.push(index);
          fetchedItems[index] = false;
        }
      }

      if (!indexesToFetch.length) {
        return;
      }

      var idsToFetch;
      var ids = carousel.getAttr(ATTR_AJAX_HASH).id_list;
      if (ids) {
        idsToFetch = util.map(indexesToFetch, function (index) {
          return ids[index];
        });
      }

      carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems, {silent: true});
      this.getItems(carousel, indexesToFetch, idsToFetch);
    },
    
    /**
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (_carousel) {},

    /**
     *  Ensure that all fetching is done after all change handlers have been bound.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    afterInit: function (carousel) {
      carousel.strategies.ajax.wantCurrentPage(carousel);
      carousel.onChange(ATTR_ASYNC_PROVIDER, util.once(function () {
        // Make sure we have enough items to fill the current page
        carousel.strategies.ajax.wantCurrentPage(carousel);
      }));
  
      // When the page number changes, we might have to get more items
      carousel.onChange(ATTR_PAGE_NUMBER, function (current, old) {
        if (current > old) {
          carousel.strategies.ajax.wantNextPage(carousel);
        } else {
          carousel.strategies.ajax.wantPrevPage(carousel);
        }
      });
    }
  };
});
/////////////////////////
// END FILE js/strategies/ajax/carousel_strategies_ajax_promise.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel AJAX Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of ajax strategies provided for carousels.
 */
P.when("A", "a-carousel-ajax-standard", "a-carousel-ajax-promise").register("a-carousel-strategies-ajax", function (A, standard, promise) {

  return {
    standard: standard,
    promise: promise,
    none: {
      wantNextPage: A.constants.NOOP,
      wantPrevPage: A.constants.NOOP,
      wantCurrentPage: A.constants.NOOP,
      want: A.constants.NOOP,
      init: A.constants.NOOP
    },
    "default": "standard"
  };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_desktop.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Standard Desktop Strategy
 *
 */

"use strict";

/**
 *  Generate the default accessibility strategy for use in a Carousel on desktops.
 */
P.when("A", "a-carousel-constants").register("a-carousel-accessibility-standard-desktop", function (A, ATTR) {
  var $ = A.$;

  /**
   *  The CSS class placed on empty carousel cards
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var LOADING_SPINNER_CARD_CLASS = "a-carousel-card-empty";

  /**
   *  Combined child selector to get a list of all "real" cards (returns in DOM order)
   *
   *  Different carousel display strategies have different behaviors for what ends up inside the carousel's <ol>
   *  This selector will ensure that we get <li.a-carousel-card>s that are, at the moment the selector is run, either
   *  actual cards with content or cards that are loading and waiting for new content.
   *
   *  The swap carousel has a concept of a third type of card which is a card that is neither loading nor containing
   *  any content and is just a placeholder so that the swap animation looks correct when moving to another page. This
   *  selector avoids those cards.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var REAL_CARDS_SELECTOR = "li:not(:empty), li." + LOADING_SPINNER_CARD_CLASS;

  /**
   *  The CSS class for the carousel's next page button
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var NEXT_PAGE_BUTTON_CLASS = "a-carousel-goto-nextpage";

  /**
   *  The CSS class for the carousel's previous page button
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var PREV_PAGE_BUTTON_CLASS = "a-carousel-goto-prevpage";


  // ----------------------- PRIVATE FUNCTIONS ----------------------- //


  /**
   *  Return the first descendent element from the passed in element that can become activeElement via tab
   *
   *  @private
   *  @param {jQuery Object} $elem
   *
   *  @return {jQuery Object} single jQuery object representing the element or empty
   */
  function _getFirstTabbableDescendant($elem) {
    return $elem.find("a, button, input, select, textarea, [tabindex]:not([tabindex='-1'])").not(":disabled").first();
  }

  /**
   *  Return a list of cards that are visible and aren't filler cards from the swap strategy
   *
   *  @private
   *  @param {Carousel} carousel
   *
   *  @return {jQuery Object} list of visible items
   */
  function _getVisibleCards(carousel) {
    var $carousel = carousel.dom.$carousel;
    var $cards = $carousel.children("li");
    var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
    var firstVisibleIndex = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM); // ATTR.FIRST_VISIBLE_ITEM starts at 1, not 0
    var firstVisibleZeroIndex = firstVisibleIndex - 1; // firstVisibleZeroIndex starts at 0
    var transitionSlideCircularFirstCardIndex = carousel.getAttr(ATTR.TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX);

    // The if/else if/final here do not necessarily map to a specific implementation of display/transition strategy
    // While the following explanations discuss which built-in strategy they target, by not specifically mentioning
    // strategies by name, when possible, we can cover similar use cases from custom strategies if they conform enough.

    // For a transition strategy of none, we want to return all cards as they are all visible and available all the time
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return $cards;
    // This else if will run for:
    // - Swap:             Always, Swap always has the same number of cards in the <ol> as pageSize
    // - Single:           When $cards.length = 1, essentially that the carousel only contains one card
    // - Stretchygoodness: When the carousel contains fewer total cards than can be displayed on one page
    } else if ($cards.length <= pageSize) {
      return $carousel.children(REAL_CARDS_SELECTOR);
    }

    if (carousel.getAttr(ATTR.TRANSITION_STRATEGY) === 'slideCircular') {
      // if the cards length is odd, when it arranges cards, it moves transitionSlideCircularFirstCardIndex - firstVisibleIndex cards to the left
      firstVisibleZeroIndex = transitionSlideCircularFirstCardIndex - firstVisibleIndex - 1;
      // if the cards length is even, when it arranges cards, it moves transitionSlideCircularFirstCardIndex - firstVisibleIndex - 1 cards to the left
      if($cards.length % 2 === 0){
        firstVisibleZeroIndex -= 1;
      }
    }
    //responsive to wide screensize
    firstVisibleZeroIndex = (firstVisibleZeroIndex + 2 * $cards.length) % $cards.length;
    // This case covers Single and Stretchygoodness for all cases other than mentioned above
    return $cards.slice(firstVisibleZeroIndex, firstVisibleZeroIndex + pageSize);
  }

  /**
   *  Handle waiting for the carousel to stop animating and move the focus to the first
   *  or last card on the current page
   *
   *  @private
   *  @param {boolean} toFirst
   */
  function _moveFocusAfterPagination(carousel, toFirst, duration, speed) {
    var actualFocusMove = function() {
      var $cards = _getVisibleCards(carousel);
      var $focusTarget = toFirst ? $cards.first() : $cards.last();

      // From the first card, find the first child that is selectable, if any, and focus it.
      _getFirstTabbableDescendant($focusTarget).focus();

      A.delay(function() {
        _updateLivePaginationText(carousel);
      }, carousel.getAttr(ATTR.PAGE_SIZE) * carousel.getAttr(ATTR.DELAY_TIME) + 50);
      // e.g.: 7x30 + 50 (7 items per page, 30ms default delay time, 50 because we may have triggered 7x A.delays()
      // and they may not execute perfectly in the calculated timeframe)
      // This value cannot be stored as a simple constant as these attributes can change over the life of the carousel
    }

    // If the duration or speed are 0 (instantaneous movement), the carousel does not toggle the ANIMATING attribute
    // However it defers using A.delay before calling any callbacks to ensure animation has had time to commit the change
    // visually to the DOM. Delay here as well.
    if (duration === 0 || speed === 0) {
      A.delay(actualFocusMove, 0);
    } else {
      // In the base class, the transition strategy is called first, which sets ATTR.ANIMATING to true, check once for false
      var animatingDoneCallback = function(current) {
        if (!current) {
          actualFocusMove();
          carousel.unbind(ATTR.ANIMATING, animatingDoneCallback);
        }
      };
      carousel.onChange(ATTR.ANIMATING, animatingDoneCallback);
    }
  }

  /**
   *  If we know what size the set is, set it to all the elements and setup position
   *  If not, at least set position
   *
   *  This function primarily exists to keep downstream users of the carousel from needing to configure
   *  these values on their preloaded content in Mason (they should, but they might not). Given that
   *  various things may have changed from the past, we need to normalize any pre-rendered content to
   *  be sure it fits the new accessibility model the carousel is following.
   *
   *  In the case of a changing set size (future functionality, the carousel doesn't support this now),
   *  this function will be invoked again as the safest possible approach for normalizing the resulting cards
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateAriaInfo(carousel) {
    var $cards = carousel.dom.$carousel.children("li");
    var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var cardProps = (setSize) ? {"aria-setsize": setSize} : {};

    if (transitionStrategy === "swap") {
      var firstItemNumber = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);

      $cards.each(function(idx) {
        var $this = $(this);
        // If this card is higher than the set size, we're dealing with empty cards that we want to skip
        // otherwise we'd end up with posinset numbers greater than the set size.
        if (firstItemNumber + idx > setSize) {
          // When we move to jQuery 1.7, consolidate to a single call
          $this.removeAttr("aria-setsize");
          $this.removeAttr("aria-posinset");
        } else {
          cardProps["aria-posinset"] = firstItemNumber + idx;
          $this.attr(cardProps);
        }
      });
    } else {
      $cards.each(function(idx) {
        cardProps["aria-posinset"] = idx + 1;
        $(this).attr(cardProps);
      });
    }
  }

  /**
   *  In order to get screen readers to announce the current page, we place this text inside of an aria-live polite
   *  flagged container. At various times it is appropriate to update this information and announce it aloud. Do that.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateLivePaginationText(carousel) {
    var $outerCarouselContainer = carousel.dom.$container;
    $outerCarouselContainer.find(".a-carousel-accessibility-page-info").html($outerCarouselContainer.find(".a-carousel-page-count").text());
  }

  /**
   *  For carousels where cards are present but off screen (that aren't using transition strategy none)
   *  handle toggling aria-hidden behavior so that screen readers don't start reading things that are off screen.
   *  Not all carousels will have the hide offscreen parameter set, but in order to normalize for screen readers,
   *  we need to hide anyway so that tabbing doesn't leave the visible set yet end up on pagination buttons after...
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateOffscreenVisibility(carousel) {
    _setCardVisibility(carousel, _getVisibleCards(carousel))
  }

  function _setCardVisibility(carousel, $visibleCards) {
    // No transition strategy means we need the cards to all be visible to screen readers all at once
    // They should still be read as separate entities, but we don't want to hide ones that aren't visible
    // because they are just overflow: scrolled out of view
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }

    var $cards = carousel.dom.$carousel.children("li");
    var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);
    var displayStrategy = carousel.getAttr(ATTR.DISPLAY_STRATEGY);
    var $nonVisibleCards = $cards.not($visibleCards);
    
    $visibleCards.attr("aria-hidden", false);
    $nonVisibleCards.attr("aria-hidden", true);

    if (
      // fix tabbing issue for screen readers
      transitionStrategy === 'slideCircular' && displayStrategy !== 'peekCircular'
      // fix issue when removing null ajax responses
      || transitionStrategy === 'slideHorizontal'
    ) {
      $visibleCards.css('visibility', 'visible');
      $nonVisibleCards.css('visibility', 'hidden');
    }
  }

  /**
   *  Check for circular/non-circular and enable/disable the right buttons at the right times
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updatePaginationButtonStatus(carousel, currentPage) {
    if (!carousel.getAttr(ATTR.CIRCULAR)) {
      var $container = carousel.dom.$container;
      $container.find("." + PREV_PAGE_BUTTON_CLASS).attr("aria-disabled", (currentPage === 1) ? "true" : "false");
      $container.find("." + NEXT_PAGE_BUTTON_CLASS).attr("aria-disabled", (currentPage === carousel.getAttr(ATTR.TOTAL_PAGES)) ? "true" : "false");
    }
  }

  /**
   *  Shared functionality between accessibility strategies
   *  Signature(s):
   *  - _setCarouselBusy
   */

  /* Importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */
/**
 *  AmazonUI Carousel Accessibility Standard Shared Functions
 *
 */

/**
 *  setCarouselBusy: Update the aria-busy attribute for the carousel container
 *
 *  @private
 *  @param {Carousel} carousel
 *  @param {boolean} busy
 */
function _setCarouselBusy(carousel, busy) {
  carousel.dom.$carousel.attr("aria-busy", (!!busy).toString());
}
/* Done importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */



  // ----------------------- PUBLIC FUNCTIONS ----------------------- //


  /**
   *  Initializes the strategy.  Sets up appropriate change handlers
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    var carouselName = carousel.getAttr(ATTR.NAME);
    var $carouselContainer = carousel.dom.$container;

    _updateAriaInfo(carousel);
    _updateOffscreenVisibility(carousel);
    _updatePaginationButtonStatus(carousel, 1);

    // If the carousel has a name, listen only to named repaints, otherwise listen to all so we don't miss one
    A.on("a:carousel" + (carouselName ? (":" + carouselName) : "") + ":repaint", function() {
      _updateOffscreenVisibility(carousel);
    });

    // If the carousel's overall size changes we need to process the items again
    carousel.onChange(ATTR.SET_SIZE, function(current, old) {
      _updateAriaInfo(carousel);
    });

    // SWAP: Loading is set to true when data has actually been returned only
    // SLIDE: Loading is set to true when adding new empty cards during init / set size change
    // as well as when new items become available to replace the placeholder cards
    carousel.onChange(ATTR.LOADING, function(current) {
      // Ensure busy state remains when animating or loading and removes only when both are finished
      if (!carousel.getAttr(ATTR.ANIMATING)) {
        _setCarouselBusy(carousel, current);
      }
      // we do not need to call ariaInfoUpdate here as the proper settings are applied via the prototype's
      // getEmptyCard function and we use that to generate proper markup when injecting new cards to the list
    });

    // All elements that aren't visible after animate should be aria-hidden.
    // Animate is set to true during the swap and slide *actual animations* whether or not individual
    // cards have been loaded in
    carousel.onChange(ATTR.ANIMATING, function(current) {
      // Ensure busy state remains when animating or loading and removes only when both are finished
      if (!carousel.getAttr(ATTR.LOADING)) {
        _setCarouselBusy(carousel, current);
      }

      if (!current) {
        // If we have more items than will fit on a single page, reprocess the aria-hidden states
        // Also, if using the swap strategy, update the carousel items aria-related parameters
        if (carousel.getAttr(ATTR.SET_SIZE) > carousel.getAttr(ATTR.PAGE_SIZE)) {
          var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);

          _updateOffscreenVisibility(carousel);

          // Try not to preclude this from working elsewhere. We want to update for swap, but variations
          // on swap that others create should also update here, just not slide (and it's not destructive
          // if we do act on variations of slide, just some JS overhead).
          if (transitionStrategy !== "slide") {
            _updateAriaInfo(carousel);
          }
        }
      }
    });

    // Disable the pagination buttons on non-circular carousels when appropriate
    carousel.onChange(ATTR.PAGE_NUMBER, function(current) {
      _updatePaginationButtonStatus(carousel, current);
      // Pre-emptively make all cards visible during transitions
      _setCardVisibility(carousel, carousel.dom.$carousel.children("li"));
    });
  }

  /**
   *  Handles calls from the base class to paginate to a specific page
   *  Move to the first element. This should be invoked by the reset link and other calls to move to a
   *  specific page programmatically via the Carousel object prototype
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function gotoPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, true, duration, speed);
  }

  /**
   *  Handles calls from the base class to paginate to the next page
   *  This is so we have a proper direction so we know which way the carousel is moving as you can't tell
   *  by just using page numbers in a two page long carousel
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function nextPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, true, duration, speed);
  }

  /**
   *  Handles calls from the base class to paginate to the previous page
   *  This is so we have a proper direction so we know which way the carousel is moving as you can't tell
   *  by just using page numbers in a two page long carousel
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function prevPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, false, duration, speed);
  }

  /**
   *  Handles any accessibility needs post-initalization
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function afterInit(carousel) {
    // Update the pagination next after the number of pages has been determined
    _updateLivePaginationText(carousel);
  }

  return {
    init: init,
    afterInit: afterInit,
    gotoPage: gotoPage,
    nextPage: nextPage,
    prevPage: prevPage
  }
});
/////////////////////////
// END FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_desktop.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_mobile.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Standard Mobile Strategy
 *
 */

"use strict";

/**
 *  Generate the default accessibility strategy for use in a Carousel on mobile and tablet devices.
 */
P.when("A", "a-carousel-constants").register("a-carousel-accessibility-standard-mobile", function (A, ATTR) {
  var $ = A.$;
  var NOOP = A.constants.NOOP;


  // ----------------------- PRIVATE FUNCTIONS ----------------------- //


  /**
   *  The carousel cannot be swiped with assistive technologies enabled, and concerns from the accessibility team
   *  about unmanageably long carousels suggest that we should not attempt to aid in the creation of extremely long
   *  carousels as that is difficult for our accessibility-device-using customers to navigate.
   *
   *  Take all currently empty cards and mark them hidden.
   *  Then properly set the posinset and set-size values for the remaining cards.
   *  If an intial AJAX call is made, this function will be called again to reprocess for the cards we receive that one time
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateAriaInfo(carousel) {
    var $carousel = carousel.dom.$carousel;
    var $emptyCards = $carousel.children(".a-carousel-card-empty");
    var $nonEmptyCards = $carousel.children("li").not($emptyCards);
    var setSize = $nonEmptyCards.length;
    var cardProps = (setSize) ? {"aria-setsize": setSize} : {};
    
    $emptyCards.attr("aria-hidden", "true")
               .removeAttr("aria-setsize")
               .removeAttr("aria-posinset");
    $nonEmptyCards.each(function(idx) {
      cardProps["aria-posinset"] = idx + 1;
      cardProps["aria-hidden"] = "false";
      $(this).attr(cardProps);
    });
  }

  /**
   *  Shared functionality between accessibility strategies
   *  Signature(s):
   *  - _setCarouselBusy
   */

  /* Importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */
/**
 *  AmazonUI Carousel Accessibility Standard Shared Functions
 *
 */

/**
 *  setCarouselBusy: Update the aria-busy attribute for the carousel container
 *
 *  @private
 *  @param {Carousel} carousel
 *  @param {boolean} busy
 */
function _setCarouselBusy(carousel, busy) {
  carousel.dom.$carousel.attr("aria-busy", (!!busy).toString());
}
/* Done importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */



  // ----------------------- PUBLIC FUNCTIONS ----------------------- //


  /**
   *  Initializes the strategy.  Essentially ensures that aria posinset and aria setsize are always accurate
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    _updateAriaInfo(carousel);

    // If the carousel's overall size changes we need to process the items again
    carousel.onChange(ATTR.SET_SIZE, function() {
      _updateAriaInfo(carousel);
    });

    // Because we cannot swipe with screen readers active, we will never be animating, but we may be loading
    // so manage the busy state of the carousel in that case.
    carousel.onChange(ATTR.LOADING, function(current) {
      _setCarouselBusy(carousel, current);
      // The transition strategies manage adding newly acquired data into the DOM...
      // When loading is complete, reprocess our limited set of visible-to-aria elements
      if (!current) {
        _updateAriaInfo(carousel);
      }
    });
  }

  // Take no action on goto/next/prev because those actions are visual in nature. If pagination does occur
  // which kicks off AJAX, we will update and include those results in the available content for screen readers
  // to tab over when the carousel is discovered.
  return {
    init: init,
    gotoPage: NOOP,
    nextPage: NOOP,
    prevPage: NOOP
  }
});
/////////////////////////
// END FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_mobile.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_accessibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of accessibility strategies provided for carousels.
 */
P.when("A", "a-carousel-accessibility-standard-desktop", "a-carousel-accessibility-standard-mobile").register("a-carousel-strategies-accessibility", function (A, standardDesktop, standardMobile) {
  return {
    standardDesktop: standardDesktop,
    standardMobile: standardMobile,
    none: {
      init: A.constants.NOOP,
      gotoPage: A.constants.NOOP,
      nextPage: A.constants.NOOP,
      prevPage: A.constants.NOOP
    },
    "default": (A.capabilities.mobile || A.capabilities.tablet) ? "standardMobile" : "standardDesktop"
  };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_accessibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Strategies Aggregator
 */

"use strict";

P.when("a-carousel-strategies-display", "a-carousel-strategies-transition", "a-carousel-strategies-ajax", "a-carousel-strategies-accessibility").register("a-carousel-strategies", function (display, transition, ajax, accessibility) {
  return {
    display: display,
    transition: transition,
    ajax: ajax,
    accessibility: accessibility
  };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_framework.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Framework
 */

"use strict";

/**
 *  Contains a framework for managing carousels on the page.  If you need to include strategies or classes which are not included in the aui,
 *  this framework will allow you to register those extra modules.  Most carousel creation and initialization should happen automatically.  If you
 *  add a carousel to the page via AJAX but the a:pageUpdate event isn't getting fired, you will need to manually run the createAll method.
 */
P.when("A", "jQuery", "a-timing-analytics", "a-carousel-classes", "a-carousel-strategies", "a-carousel-constants")
    .register("a-carousel-framework", function (A, $, timingAnalytics, carouselClasses, strategies, constants) {
  var undefined;

  /**
   *  The name of the DOM node's data attribute which contains the carousel
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_DATA_ATTRIBUTE = "a-carousel";

  /**
   *  The class name for the DOM node which contains a carousel and has the requisite data attributes
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_CONTAINER_CLASS = "a-carousel-container";

  /**
   *  The class name for a carousel which has been created and initialized
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_INITIALIZED_CLASS = "a-carousel-initialized";

  /**
   *  The class name for a carousel which needs to be created
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_STATIC_CLASS = "a-carousel-static";

  /**
   *  A list of all carousels which have been created and initialized
   *
   *  @private
   *  @type {Array}
   */
  var initializedCarousels = [];

  /**
   *  A list of all carousels which have been created but have not been initialized
   *
   *  @private
   *  @type {Array}
   */
  var uninitializedCarousels = [];

  /**
   *  Keep track of whether DOM ready has fired yet
   *
   *  @private
   *  @type {Boolean}
   */
  var pageInitialized = false;

  /**
   *  A map of carousel names to their corresponding carousel.
   *
   *  @private
   *  @type {Object}
   */
  var namedCarousels = {};

  /**
   *  Keep a reference to the document here for ease of use.
   *
   *  @private
   *  @type {Object}
   */
  var $document = $(document);

  /**
   *  People can register init handlers for named carousels in the same way that they can register handlers for DOM
   *  ready.  This is a name -> callback hash which should execute whenever a carousel with that name initializes
   */
  var initHandlers = {};

  /**
   *  Auto-incrementing unique ID applied to each carousel.
   *
   *  @private
   *  @type {Number}
   */
  var id = 0;


  /************************* BEGIN PRIVATE METHODS *************************/

  /**
   *  Create a new carousel for the given DOM node with the modules and parameters listed.
   *
   *  @private
   *  @param {HTMLElement} $carouselContainer - The DOM node for the carousel
   *  @param {Carousel} CarouselClass - The constructor function for the carousel class
   *  @param {Object} carouselStrategies - A hash of strategy name to actual strategy Object
   *  @param {Object} options - A hash of options to pass to the carousel
   */
  function createCarousel($carouselContainer, CarouselClass, carouselStrategies, options) {
    //Return if the containe ris not fully loaded.
    if (!isCarouselRendered($carouselContainer)) {
        return;
    }

    // Create the carousel object
    var carousel;
    carousel = new CarouselClass($carouselContainer, carouselStrategies, options);
    carousel.__id = ++id;

    $carouselContainer.data(CAROUSEL_DATA_ATTRIBUTE, carousel);
    $carouselContainer.removeClass(CAROUSEL_STATIC_CLASS);

    // List the carousel as needing initialization or just initialize it if it's ready
    if (carouselContainerReady($carouselContainer)) {
      A.delay(initializeCarousel, 10, carousel);
    } else {
      uninitializedCarousels.push(carousel);
    }

    if (options.name) {
      namedCarousels[options.name] = carousel;
    }

    return carousel;
  }


  /**
   *  Check if a carousel is rendered fully
   *  
   *  @private
   *  @param {HTMLElement} $carouselContainer
   *
   *  @return {Boolean}
   */
  function isCarouselRendered($carouselContainer){
    //Check if the container is fully rendered by its a-begin, a-end pair.
    //For a container without a-begin, assume it follows legacy markup (pre 2017), assume carousel is rendered fully.
    var isLegacyMarkup = $carouselContainer.hasClass('a-begin');
    var ifCarouselHasAEnd = $carouselContainer.children('.a-end').length > 0;
    return isLegacyMarkup ? ifCarouselHasAEnd : true;
  }

  /**
   *  Initialize an individual carousel
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function initializeCarousel(carousel) {
    carousel.init();
    initializedCarousels.push(carousel);
    carousel.__initialized = true;
    carousel.dom.$container.addClass(CAROUSEL_INITIALIZED_CLASS);
    var name = carousel.getAttr("name");
    if (name && initHandlers[name]) {
      A.each(initHandlers[name], function (callback) {
        callback(carousel);
      });
    }
  }

  /**
   *  Given a strategy type and options hash, get the correct strategy off of the hash.
   *
   *  @private
   *  @param {String} type - The strategy type to fetch (display, transition, or ajax)
   *  @param {Object} options - The options hash placed on the carousel DOM node
   *
   *  @return {Object} strategy
   */
  function getStrategy(type, options) {
    var strategyName = options[type + "Strategy"];

    if (!strategyName) {
      strategyName = strategies[type]["default"];
    }

    return strategies[type][strategyName];
  }

  /**
   *  Search through an array of carousels, find any which have DOM nodes which aren't on
   *  the page any more, and remove them from the array.
   *
   *  @private
   *  @param {Array} arr - An array of carousel Objects
   */
  function findDeadCarousels(arr) {
    var i = arr.length;
    var carousel, name;
    while (i--) {
      carousel = arr[i];
      if (!(carousel.dom.$container.length && $document.find(carousel.dom.$container).length)) {
        name = carousel.getAttr("name");
        if (name) {
          delete namedCarousels[name];
        }
        arr.splice(i, 1);
      }
    }
  }

  /**
   *  Look for carousels whos DOM nodes have been removed from the page and delete the Objects.
   *
   *  @private
   */
  function removeDeadCarousels() {
    findDeadCarousels(uninitializedCarousels);
    findDeadCarousels(initializedCarousels);
  }

  /**
   *  Pull all possible attributes for carousel creation off of a DOM node.  If required attributes
   *  are missing, then this will return undefined.
   *
   *  @private
   *  @param {HTMLElement} $dom
   *
   *  @return {undefined|Object} Either an Object containing all the attributes found or undefined if required attributes were missing
   */
  function getAttributesFromDom($dom) {
    var attrs = {};
    var options = $dom.data("a-carousel-options") || {};

    options.displayStrategy = $dom.data("a-display-strategy");
    options.transitionStrategy = $dom.data("a-transition-strategy");
    options.ajaxStrategy = $dom.data("a-ajax-strategy");
    options.accessibilityStrategy = $dom.data("a-accessibility-strategy");
    options.carouselClass = $dom.data("a-class");

    var displayStrategy = getStrategy("display", options);
    var transitionStrategy = getStrategy("transition", options);
    var ajaxStrategy = getStrategy("ajax", options);
    var accessibilityStrategy = getStrategy("accessibility", options);

    var className = options.carouselClass;
    if (!className) {
      className = carouselClasses["default"];
    }

    var CarouselClass = carouselClasses[className];

    if (CarouselClass === undefined || displayStrategy === undefined || transitionStrategy === undefined || ajaxStrategy === undefined || accessibilityStrategy === undefined) {
      return;
    }

    var carouselStrategies = {
      display: displayStrategy,
      transition: transitionStrategy,
      ajax: ajaxStrategy,
      accessibility: accessibilityStrategy
    };

    return {
      carouselClass: CarouselClass,
      strategies: carouselStrategies,
      opts: options
    };
  }

  /**
   *  Determine if carousel container is ready for initialization. To be ready, a Carousel must be on screen with all
   *  child nodes rendered from server.
   *
   *  @private
   *  @param {HTMLElement} $carouselContainer - The DOM node for the carousel (actually a jQuery object, but this param
   *  definition is consistent with carousel framework.)
   *
   *  @return {boolean} Whether carousel represented by container is ready to proceed with initialization.
   */
  function carouselContainerReady($carouselContainer) {
    var carouselSupportsBeginEndDetection = $carouselContainer.hasClass('a-begin');
    if (carouselSupportsBeginEndDetection && $carouselContainer.children('.a-end').length === 0) {
      return false;
    }
    return A.onScreen($carouselContainer);
  }

  /************************* END PRIVATE METHODS *************************/



  /************************* BEGIN PUBLIC INTERFACE *************************/

  /**
   *  Scan to DOM to find carousels which haven't been created yet, then create them if possible.
   *
   *  @public
   */
  function createAllCarousels() {
    var $carousels = $("." + CAROUSEL_STATIC_CLASS);

    $carousels.each(function () {
      var $this = $(this);
      var attrs = getAttributesFromDom($this);
      if (attrs) {
        createCarousel($this, attrs.carouselClass, attrs.strategies, attrs.opts);
      }
    });
  }

  /**
   *  Scan the list of uninitialized carousels and initialize them if they're almost visible on the screen
   *  Simultaneously remove them from the uninitialized carousels list so we don't iterate over them again.
   *
   *  @public
   */
  function initializeAllCarousels() {
    var i = uninitializedCarousels.length;
    // We are decrementing from the end of the list which allows us to modify the list while iterating over it.
    while (i--) {
      var carousel = uninitializedCarousels[i];
      if (carouselContainerReady(carousel.dom.$container)) {
        uninitializedCarousels.splice(i, 1);
        initializeCarousel(carousel);
      }
    }
  }

  /**
   *  Wires up Carousel to be able to handle new strategies and allow for custom functionality on Carousels.
   *  If the page is already initialized, Carousel.initializeAll will be called for you; you should never
   *  have to call that method yourself.
   *
   *  @public
   *  @param {String} type - The strategy type being registered (display, transition, etc)
   *  @param {String} name - The unique name of this strategy
   *  @param {Object} strategy - The actual strategy Object
   *
   */
  function registerStrategy(type, name, strategy) {
    if (!strategies[type]) {
      strategies.type = {};
    }

    if (strategies[type][name]) {
      P.error("Attempted to register a " + type + " strategy which already exists: " + name, "a-carousel-framework", "registerStrategy");
    }

    strategies[type][name] = strategy;

    if (pageInitialized) {
      createAllCarousels();
    }
  }

  /**
   * If the  default Carousel class can not meet your needs by simply changing a strategy, you can register
   *  a new class here.
   *
   *  @public
   *  @param {String} name - The carouselClassName which is passed into the carouselOptions parameter
   *  @param {Function} constructor - The constructor function used for the carousel
   */
  function registerCarouselClass(name, constructor) {
    if (carouselClasses[name]) {
      P.error("Attempted to register a carousel class which already exists: " + name, "a-carousel-framework", "registerCarouselClass");
    }

    if (!$.isFunction(constructor)) {
      P.error("Attempted to register carousel class " + name + " without a constructor function.", "a-carousel-framework", "registerCarouselClass");
    }

    carouselClasses[name] = constructor;

    if (pageInitialized) {
      createAllCarousels();
    }
  }

  /**
   * Convenience function. Returns the carousel Object from any DOM element inside the carousel.
   *
   *  @public
   *  @param {HTMLElement} $dom - Node representing an element inside the carousel, or the carousel node itself.
   *
   *  @return {Carousel} A Carousel Object or undefined
   */
  function getCarousel($dom) {
    if (!$dom.jquery) {
      $dom = $($dom);
    }
    var carousel = $dom.closest("." + CAROUSEL_CONTAINER_CLASS).data(CAROUSEL_DATA_ATTRIBUTE);
    if (!carousel) {
      var attrs = getAttributesFromDom($dom);
      if (attrs) {
        carousel = createCarousel($dom, attrs.carouselClass, attrs.strategies, attrs.opts);
      }
    }
    return carousel;
  }

  /**
   *  Convenience function.  Returns the carousel Object with the given Object or undefined.
   *
   *  @public
   *  @param {HTMLElement} $dom - Node representing an element inside the carousel, or the carousel node itself.
   *
   *  @return {Carousel|undefined} A Carousel object or undefined
   */
  function getCarouselByName(name) {
    return namedCarousels[name];
  }

  /**
   *  Get rid of all references to the carousel at the specific DOM node and get rid of the associated DOM elements
   *
   *  @public
   *  @param {HTMLElement} $dom - The DOM node representing the carousel container or one of its decentendents, optionally wrapped in a jQuery call
   */
  function killCarousel($dom) {
    if (!$dom.jquery) {
      $dom = $($dom);
    }

    if ($dom.length) {
      var $container = $dom.closest("." + CAROUSEL_CONTAINER_CLASS);
      if ($container.length) {
        var carousel = $container.data(CAROUSEL_DATA_ATTRIBUTE);
        if (carousel) {
          var i = A.indexOfArray(initializedCarousels, carousel);
          if (i > -1) {
            if (initializedCarousels[i].name) {
              delete namedCarousels[initializedCarousels[i].name];
            }
            initializedCarousels.splice(i, 1);
          } else {
            i = A.indexOfArray(uninitializedCarousels, carousel);
            if (i > -1) {
              if (uninitializedCarousels[i].name) {
                delete namedCarousels[uninitializedCarousels[i].name];
              }
              uninitializedCarousels.splice(i, 1);
            }
          }
        }
        $container.remove();
      }
    }
  }

  /**
   *  Return all the carousels that we know about
   *
   *  @public
   *
   *  @return {Array}
   */
  function getAll() {
    return initializedCarousels.concat(uninitializedCarousels);
  }

  /**
   *  This allows people to register an onInit handler for carousels which behaves similarly to the
   *  DOM ready handler.  If initialziation hasn't happened yet, wait till it does.  If it has happened,
   *  then execute immediately.  Unlike DOM ready, since carousels can be reloaded via AJAX, we don't
   *  destructively iterate of the callback array, and we add to the array regardless.  This way, if the RHF
   *  carousel has one of these handlers and gets AJAX'd in on top of itself, the callback still fire.
   */
  function onInit(name, callback) {
    if (name) {
      if (!initHandlers[name]) {
        initHandlers[name] = [];
      }
      if ($.isFunction(callback)) {
        initHandlers[name].push(callback);
        var carousel = getCarouselByName(name);
        if (carousel && carousel.__initialized) {
          callback(carousel);
        }
      }
    }
  }

  /************************* END PUBLIC INTERFACE *************************/


  /******* Bind to the requisite DOM events for the framework to function *******/

  // Trigger resize events on each carousel when the window has the potential to resize
  A.on("resize orientationchange", function (viewport, changed) {
    removeDeadCarousels();
    if (changed.height || changed.width) {
      A.delay(function () {
        A.each(initializedCarousels, function (carousel) {
          carousel.resize();
        });
      }, A.capabilities.mobile || A.capabilities.tablet ? 100 : 0);
    }
  });

  // If the orientation changed while the secondary view was open, carousels could be in a very odd state, so
  // we need to call the resize handler to ensure that the carousel will be the correct size after the secondary view
  // is gone.
  A.on("a:popover:afterSlideOut", function () {
    A.each(initializedCarousels, function (carousel) {
      carousel.resize();
    });
  });

  // If a carousel's name changes, we'll want to keep track of that so that the
  // getCarouselsByName() API actually works.
  A.on("a:carousel:change:name", function (data) {
    if (data.newValue) {
      namedCarousels[data.newValue] = data.carousel;
    }
    if (data.oldValue) {
      delete namedCarousels[data.oldValue];
    }
  });

  // Create carousels on key DOM events
  A.on(constants.INIT_EVENTS, function () {
    initializeAllCarousels();
    createAllCarousels(); // createAllCarousels initializes new carousels also

    // The callback will be potentially called more than once
    // (e.g. after ajax responses complete)
    // We'd like to track the timing of first creation;
    // `stopWidgetLogging` method should have no side effect
    // by calling multiple times individually. But we still put a safe net here.
    A.once(function () {
      timingAnalytics.stopWidgetLogging('carousel');
    })();
  });

  // Ensure dead carousels don't stay in memory when someone uses our pageUpdate API
  A.on("a:pageUpdate", removeDeadCarousels);

  // Check to see if carousels need to be initialized on certain DOM events
  A.on("scroll", function () {
    initializeAllCarousels();
    createAllCarousels(); // createAllCarousels initializes new carousels also
  });

  // When the user switches tabs, see if there's a carousel which needs to be initialized or resized
  A.declarative("a-tabs", "click", function (event) {
    A.delay(function() {
      initializeAllCarousels();
      A.each(initializedCarousels, function(carousel) {
        if(carousel.getAttr('isInTab')) {
          carousel.resize();
        }
      });
    }, 50);
  });

  // If there's a carousel inside of a popover, see if it needs to be initialized.
  A.on("a:popover:afterShow", function () {
    A.delay(initializeAllCarousels, 50);
  });

  // When the AJAX request for a popover completes, see if the new HTML has a carousel in it
  A.on("a:popover:ajaxContentLoaded", function () {
    A.delay(function () {
      removeDeadCarousels();
      createAllCarousels();
    }, 50);
  });

  // Record when DOM ready has fired
  A.on.ready(function () {
    pageInitialized = true;
  });

  // Create the framework Object which will be returned and make immutable, if possible
  var carouselFramework = {
    getCarousel: getCarousel,
    getCarouselByName: getCarouselByName,
    createAll: function () {
      // If the user has replaced a carousel via AJAX (RHF does this), we'll need to check for dead
      // carousels before creating new ones.
      removeDeadCarousels();
      createAllCarousels();
    },
    initializeAll: function () {
      removeDeadCarousels();
      initializeAllCarousels();
    },
    kill: killCarousel,
    registerStrategy: registerStrategy,
    registerCarouselClass: registerCarouselClass,
    getAllCarousels: getAll,
    onInit: onInit
  };

  if (Object.freeze !== undefined) {
    Object.freeze(carouselFramework);
  }

  return carouselFramework;
});
/////////////////////////
// END FILE js/carousel_framework.js
/////////////////////////

// END ASSET AmazonUICarousel-3.2.16640.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIComponents", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIComponents-3.2.16867.0
/////////////////////////
// BEGIN FILE js/controls_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls Handlers
 */

'use strict';

P.when('A', 'a-form-controls-api').register('a-form-controls-handlers', function (A, controlsAPI) {
    var $ = A.$,
        BOX_INPUT_FOCUS_CLASS = 'a-form-focus',
        HOVER_DISABLE_CLASS = 'a-hover-disable',
        RESET_EVENT = 'reset.a-form-controls-reset';

    /**
     * (mobile only)
     * When "box input" (aka multi-select, input and textarea) gets focused,
     * we set focus class on ALL "AUI wrapping ancestors" (see TOUCH_SELECT_INPUT
     * in controls_touch.js). It's possible one "box input" has multiple
     * "AUI wrapping ancestors", for example, in the "input group" use case :
     *    input_group > n * ( input_group_row > text_input ).
     * The redundant nested style will be removed by default.
     *
     * @public
     */
    var handleBoxInputMobileFocus = function() {
        $(this).addClass(BOX_INPUT_FOCUS_CLASS);
    };

    /**
     * Same as handleBoxInputMobileFocus, except this is a class remover.
     *
     * @public
     */
    var handleBoxInputMobileBlur = function() {
        $(this).removeClass(BOX_INPUT_FOCUS_CLASS);
    };

    /**
     *  Removes the hover disable class used to override the hover state on checkboxes after they have been clicked
     *
     *  @private
     */
    var _hoverDisableHandler = function() {
        /*jshint validthis:true */
        $(this).removeClass(HOVER_DISABLE_CLASS);
    };

    /**
     *  When you uncheck a checkbox, the hover state becomes active, which may make it appear that the checkbox is still checked
     *  on low contrast displays. This handler will suppress the hover effect until the cursor leaves the label.
     *
     *  @public
     */
    var handleCheckboxClick = function() {
        /*jshint validthis:true */
        if (!A.capabilities.mobile && !A.capabilities.tablet) {
            $(this)
                .addClass(HOVER_DISABLE_CLASS)
                .one('mouseleave', _hoverDisableHandler);
        }
    };

    /**
     *  Some browsers need this canceling behavior in order to keep the page from moving when the space bar is pressed
     *
     *  @param {object} event - The event corresponding to the keypress
     */
    var accessibilityKeyPress = function(event) {
        if (event.keyCode === A.constants.keycodes.SPACE) {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    /**
     *  Browsers handle form resetting in various ways. Unfortunately, the reset button simply blanks out the checked attr
     *  on form elements without necessarily dispatching change events we could potentially listen to (Chrome is a culprit).
     *
     *  We capture the reset event on any given form tag and then re-normalize the visual icons for all elements that we
     *  care about in that form.
     *
     *  @param {object} form - The DOM element of the form
     *  @param {string} selector - The selectors for our image-enhanced elements (changes based on device type)
     */
    var formReset = function(form, selector) {
        var $context = controlsAPI.findFormElementContainer(form);

        // Without a delay, form elements weren't always ready to be normalized and would retain the image set the way it was
        // and then immediately after the underlying form element would change and the state would be set incorrectly.
        A.delay(function() {
            $context.find(selector).each(controlsAPI.normalizeElement);
        }, 0);
    };

    /* The reset event does not bubble up to the document in Safari: https://jsbin.amazon.com:443/tuqakusax/1/
     * Therefore we cannot listen for this event delegated off of the document... :(
     *
     * Remove existing bindings first on pageUpdate then add new bindings to catch new additions to the page
     * and don't keep track of specific elements in case they've been removed somewhere in between as it is
     * beyond our scope to track the various ways elements may be removed from the DOM.
     */
    var normalizeFormControls = function() {
        $('form')
            .unbind(RESET_EVENT)
            .bind(RESET_EVENT, function (event) {
                formReset(event.currentTarget, 'li .a-touch-multi-select');
            });
    };

    /**
     *  Update the UI for the touch multi select component when it is clicked
     *
     *  @private
     *  @param {object} event The event which triggered the change
     */
    var touchMultiSelectHandler = function(event) {
        controlsAPI.toggleCheckboxState(event.currentTarget);
    };

    return {
        handleBoxInputMobileFocus: handleBoxInputMobileFocus,
        handleBoxInputMobileBlur: handleBoxInputMobileBlur,
        accessibilityKeyPress: accessibilityKeyPress,
        formReset: formReset,
        handleCheckboxClick: handleCheckboxClick,
        normalizeFormControls: normalizeFormControls,
        touchMultiSelectHandler: touchMultiSelectHandler
    };
});
/////////////////////////
// END FILE js/controls_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/controls.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls
 */

'use strict';

P.when('A', 'a-form-controls-handlers', 'ready').register('a-form-controls', function (A, controlsHandlers) {
    var $ = A.$,
        CHECKS = '.a-checkbox-fancy';

    $(document)
        .delegate(CHECKS, 'click', controlsHandlers.handleCheckboxClick)
        .delegate(CHECKS + ', .a-radio-fancy', 'keypress', controlsHandlers.accessibilityKeyPress);

    /*
    On DOM ready, we want to double check to make sure that the state of the UI matches the state of the underlying form
    controls. The browser may autocomplete or change the value provided by the server to match what the user had on the
    previous page view.
    */
    A.on('a:pageUpdate beforeReady', controlsHandlers.normalizeFormControls);
});
/////////////////////////
// END FILE js/controls.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/buttons.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Toggle Button JS
 */

"use strict";

/**
 *  Set up default behavior for toggle button groups.
 */
P.when("A").register("a-buttons", function (A) {

  /**
   * Button groups have default functionality wherein clicking one button in a group
   * gives it the selected state and removes the selected state from other buttons.
   *
   * trigger "a:button-group:[button-group-name]:toggle"
   * trigger "a:button-group:[button-group-name]:[button-name]:toggle"
   */

  var $ = A.$;
  var idCount = 0;

  function handleToggleButtons(event) {

    // Make sure we clicked on a button
    var $target = event.$target;
    var $button = $target.closest(".a-button:not(.a-button-disabled)");
    if ($button.length) {
      var $buttons = event.$declarativeParent.find(".a-button");
      var buttonGroupName = event.data && event.data.name ? event.data.name : false;

      // depending on where the user clicked in the button, the button input could be up or down the dom tree
      // {@see AUI-12009, AUI-14936}
      var buttonSelector = "input[type=submit], button";
      var buttonName = $target.closest(buttonSelector).attr("name") || $target.find(buttonSelector).attr("name");

      $buttons.removeClass("a-button-selected").attr("aria-checked", "false");
      $button.addClass("a-button-selected").attr("aria-checked", "true");

      // Broadcast events if we can
      if (!(buttonName || buttonGroupName)) {
        return;
      }

      var button = {
        $button: $button,
        buttonName: buttonName,
        buttonGroupName: buttonGroupName
      };

      if (buttonGroupName) {
        A.trigger("a:button-group:" + buttonGroupName + ":toggle", {
          selectedButton: button
        });

        if (buttonName) {
          A.trigger("a:button-group:" + buttonGroupName + ":" + buttonName + ":toggle", {
            selectedButton: button
          });
        }
      }
    }
  }

  // Bind the declarative event
  A.declarative("a-button-group", ["click"], handleToggleButtons);

  //This is being done just for accesibility reasons, we want the screen reader to
  //read the text in the innermost span and this mapping can only be done with ad ID
  //this is taken care of in MarkupTemplates if ID is provided, if not we need to
  //assign a manual ID.
  A.on("a:pageUpdate beforeReady", function () {
    var $buttons = $(".a-button:not([id])");
    var $toggles = $(".a-button-group,.a-button-toggle-group");

    // Add auto IDs to buttons that does not have a default ID
    $buttons.each(function () {
      var $button = $(this);
      var $buttonText = $button.find(".a-button-text");
      var $buttonInput = $button.find(".a-button-input"); // It is okay for $buttonInput to be []
      var id = "a-autoid-" + idCount++;
      var innerId;
      var originalId;

      // Add ID to buttons anyways to avoid re-accessing later
      $button.attr("id", id);

      // Only add aria labels if the text anchor DOM exists
      if ($buttonText.length) {
        originalId = $buttonText.attr('id');
        innerId = originalId ? originalId : id + "-announce";
        $buttonInput.attr("aria-labelledby", innerId);
        $buttonText.attr("id", innerId);
      }
    });

    // Add aria-posinset and aria-setsize to toggle buttons in toggle button group for better screen reader accessibility
    $toggles.each(function () {
      var $toggle = $(this);
      var $toggleButtons = $toggle.find(".a-button[role='radio']");
      var buttonCount = $toggleButtons.length;
      var count = 1;
      $toggleButtons.each(function(){
        $(this).attr({
          "aria-posinset": count++,
          "aria-setsize": buttonCount
        });
      });
    })
  });

  // When the focusable element of a button gets focus, it usually doesn't affect the visual style of the button.
  // Add a class to the outer node to ensure that it looks legit.
  // Internet Explorer doesn't dispatch focusout when a scroll takes over. Listen for cancel as well.
  $(document).delegate(".a-button-input, .a-button-text", "focusin", function () {
    var $button = $(this).closest(".a-button");
    if (!$button.hasClass("a-button-disabled")) {
      $button.addClass("a-button-focus");
    }
  }).delegate(".a-button-input, .a-button-text", "focusout " + A.action.cancel, function () {
    $(this).closest(".a-button").removeClass("a-button-focus");
  });
});
/////////////////////////
// END FILE js/buttons.js
/////////////////////////

// END ASSET AmazonUIComponents-3.2.16867.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUITabs@jsAssets", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUITabs@jsAssets-3.2.16667.0
/////////////////////////
// BEGIN FILE js/tabs.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Tabs

'use strict';

P.when('A').register('a-tabs', function(A){
  var $ = A.$;

  function handleTabSelection(event){
    var $tab = event.$target.closest('li');
    var tabSetName = event.data.name;
    var tabName = $tab.data('a-tab-name');
    var $tabContainer = $tab.closest('.a-tab-container');
    var $tabContents = $tabContainer.find('.a-box-tab').not($tabContainer.find('.a-box-tab .a-box-tab'));
    
    if (tabName === undefined) {
      return;
    }

    //Toggle active state
    $('li.a-active', $tab.closest('.a-tabs')).removeClass('a-active');
    $tab.addClass('a-active');

    $.each($tabContents, function (i, content) {
      $(content).toggleClass('a-hidden', $(content).data('a-name') !== tabName);
    });

    //Broadcast events
    var tab = {
      $tab : $tab,
      tabName : tabName,
      tabSetName : tabSetName
    }

    A.trigger('a:tabs:' + tabSetName + ':select', {
      selectedTab : tab
    });

    A.trigger('a:tabs:' + tabSetName + ':' + tabName + ':select', {
      selectedTab : tab
    });

    event.$event.preventDefault();
  }

  A.declarative('a-tabs', ['click'], handleTabSelection);
});
/////////////////////////
// END FILE js/tabs.js
/////////////////////////
// END ASSET AmazonUITabs@jsAssets-3.2.16667.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIAccordion@jsAssets", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIAccordion@jsAssets-3.2.16602.0
/////////////////////////
// BEGIN FILE js/accordion.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Accordion Event Handler
 */

'use strict';

P.when('A').register('a-accordion-a11y', function(A) {
  var $ = A.$;
  var $focusHolder;

  // Some screen readers won't announce aria changes on the focused element.
  // A explicit re-focusing could fix it. We need this for JAWS with IE.
  function refreshFocus($target, delay) {
    delay = delay || 600; // milli seconds

    // Create a persistent focusHolder (if none exists) so that we
    // can momentarily move focus in and out of this element.
    if (!$focusHolder) {
      $focusHolder = $('<b />', {
        "class": "a-accordion-a11y",
        tabIndex: -1,
        style: 'position: absolute'
      }).appendTo('body');
    }

    // Focus in on the focusHolder. We will only display the focusHolder
    // when momentarily needed, otherwise it will be display: none.
    // We need it close to target so that window scroll position doesn't jump.
    $focusHolder
      .css({display: 'block'})
      .offset($target.offset());
    A.delay(function() {
      $focusHolder.focus();
    }, 50);


    // Focus out of the focusHolder after short delay (JAWS will now read aria)
    A.delay(function resetFocus() {
      $target.focus();
      $focusHolder.css({display: 'none'});
    }, delay);
  }
  return {
    refreshFocus: refreshFocus
  };
});

/**
 *  Bind event handlers which allows the accordion to function.
 */

P.when('A', 'a-accordion-a11y', 'prv:a-capabilities').register('a-accordion', function (A, a11y, privateCapabilities) {
  /**
   *  The name of the function we're using the show accordion content.
   *
   *  @private
   *  @type {string}
   */
  var showFunction = "slideDown";

  /**
   *  The name of the function we're using the hide accordion content.
   *
   *  @private
   *  @type {string}
   */
  var hideFunction = "slideUp";

  /**
   *  The amount of time the accordion show/hide animation should take.
   *
   *  @private
   *  @type {number}
   */
  var duration = 300;

  if (A.capabilities.mobile || A.capabilities.tablet) {
    showFunction = "show";
    hideFunction = "hide";
    duration = 0;
  }

  /**
   *  String constants to aid in minification.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ACTIVE_ROW_CLASS = "a-accordion-active";
  var ICON_SELECTOR = ".a-icon.a-accordion-radio";

  var shouldRefreshFocus = !A.capabilities.touch && privateCapabilities.isFirefox;

  /**
   * Event handler for accordions which will show/hide the relevant divs,
   * update icons, and update ARIA attributes.
   *
   * @private
   * @param {object} event
   *
   * triggers a:accordion:select
   * triggers a:accordion:<accordionName>:select
   * triggers a:accordion:<accordionName>:<rowName>:select
   */

  function handleAccordionSelection(event) {
    var $container = event.$target.closest(".a-accordion");
    var $row = event.$target.closest('.a-box');
    var $otherRows = $container.find('.a-box').not($row);
    var $trigger = $row.find('.a-accordion-row');
    var accordionName = $container.data('a-accordion-name');
    var rowName = $row.data('a-accordion-row-name');
    var collapseAll = $container.hasClass("a-accordion-collapse");
    var textHeader = $row.find('a.a-accordion-row');

    var $rowA11y = event.$target.closest('.a-accordion-row-a11y');
    var $otherRowsA11y = $container.find('.a-accordion-row-a11y').not($rowA11y);

    if (rowName) {
      // Toggle if needed
      var $inner = $row.find('.a-accordion-inner');
      var hasToggled = true;
      if (!$row.hasClass(ACTIVE_ROW_CLASS)) {
        // Toggle active state
        $otherRows.find(".a-accordion-inner")[hideFunction]({
          duration: duration,
          complete: function () {
            $otherRows.removeClass(ACTIVE_ROW_CLASS);
          }
        });
        $inner[showFunction]({
          duration: duration,
          complete: function () {
            // Toggle radio button
            $row.addClass(ACTIVE_ROW_CLASS);
            $otherRows.find(ICON_SELECTOR).removeClass('a-icon-radio-active').addClass('a-icon-radio-inactive');
            $row.find(ICON_SELECTOR).removeClass('a-icon-radio-inactive').addClass('a-icon-radio-active');
          }
        });

        // accessibility
        $otherRowsA11y.attr('aria-checked', 'false').attr("aria-expanded", "false");
        $rowA11y.attr('aria-checked', 'true').attr("aria-expanded", "true");

      } else if (collapseAll) {
        $inner[hideFunction]({
          duration: duration,
          complete: function () {
            $row.removeClass("a-accordion-active");
            $row.find(ICON_SELECTOR).removeClass('a-icon-radio-active').addClass('a-icon-radio-inactive');

            // accessibility
            $rowA11y.attr('aria-checked', 'false').attr("aria-expanded", "false");
          }
        });
      } else {
        hasToggled = false;
      }

      if (hasToggled && shouldRefreshFocus) {
        a11y.refreshFocus($trigger); // $trigger is focusable; $row is not
      }

      // Only broadcast events if something happened.
      if (hasToggled) {
        var accordionRow = {
          $row: $row,
          rowName: rowName,
          accordionName: accordionName
        };

        A.trigger("a:accordion:select", {
          selectedRow: accordionRow
        });

        A.trigger('a:accordion:' + accordionName + ':select', {
          selectedRow: accordionRow
        });

        A.trigger('a:accordion:' + accordionName + ':' + rowName + ':select', {
          selectedRow: accordionRow
        });
      }
    }
    // If the accordion header is rendered as a text container which is a link, we don't want to navigate by default.
    // However, in the container case, we don't want to swallow all clicks
    if (textHeader.length) {
      event.$event.preventDefault();
    }
  }


  /**
  * Handles ENTER/SPACE keypress to show/hide accordion
  * @param  {[Object]} event
  */
  function handleSpaceEnter(event) {
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;
    if (key === keycodes.ENTER || key === keycodes.SPACE) {
        handleAccordionSelection(event);
    }
  }

  A.declarative('a-accordion', ['click'], handleAccordionSelection);
  A.declarative('a-accordion', ['keypress'], handleSpaceEnter);
});

/* Importing js/accordion_accessibility.js */
/**
 *  AmazonUI Accordion Accessibility
 */
/* Done importing js/accordion_accessibility.js */

/////////////////////////
// END FILE js/accordion.js
/////////////////////////
// END ASSET AmazonUIAccordion@jsAssets-3.2.16602.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIExpander", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIExpander-3.2.16725.0
/////////////////////////
// BEGIN FILE js/constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
P.declare('prv:a-expander-constants', {
  classNames : {
    inline: {
      expand: "a-icon-expand",
      collapse: "a-icon-collapse"
    },
    section: {
      expand: "a-icon-section-expand",
      collapse: "a-icon-section-collapse"
    },
    extender: {
      expand: "a-icon-extender-expand",
      collapse: "a-icon-extender-collapse"
    }
  },
  elementClasses : {
    container: "a-expander-container",
    content: "a-expander-content",
    header: "a-expander-header",
    fadeDiv: "a-expander-content-fade"
  }
});
/////////////////////////
// END FILE js/constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/partialExpander.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
P.when("A", "jQuery", "prv:a-expander-constants").register("a-partial-expander", function (A, $, expanderConstants) {
  var elementClasses = expanderConstants.elementClasses;

  // If the height of the content is too short, hide the expander.
  function initializePartialExpanders() {
    $('.a-expander-partial-collapse-container').each(function () {
      // Check to see if our expander should be fully gone when gone or only partially
      var $container = $(this);
      var $content = $container.children('.' + elementClasses.content);
      var collapsedHeight = $container.data('a-expander-collapsed-height');
      var $expanderHeader = $container.children('.' + elementClasses.header);

      if ($content.height() <= collapsedHeight) {
        $expanderHeader.css({
          'opacity': '0',
          'display': 'none'
        });
      } else {
        $expanderHeader.css({
          'opacity': '1',
          'display': 'block'
        });
        // Make enough space at the bottom of the content div to show the heading. Note
        // that this is done using JS to allow for different heights of headers.
        $content.css('padding-bottom', $expanderHeader.height());

        // Move away from using max-height and replace it with height
        // that can be toggled for future interactions. max-height doesn't work in old IE).
        if ($content.attr("aria-expanded") !== "true") {
          $container.css({
            "height": collapsedHeight
          });
        }
        // Ideally max-height is only set when expander is in collapsed state.
        // But we reset the attribute for non collapsed usecases as well, since there may be
        // instances of a client hitting expander when `a-expander` is ready but the page isn't.
        $container.css({
            "max-height": "none"
        })
      }
    });
  }

  // Make sure we initialze at all the right times, over and over again.
  A.on("load ready resize orientationchange a:popover:afterShow a:popover:ajaxContentLoaded", initializePartialExpanders);

  return initializePartialExpanders;
});
/////////////////////////
// END FILE js/partialExpander.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/expander.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Expander
 */

"use strict";

/**
 *  JS for the toggle expander component.
 */
P.when("A", "jQuery", "prv:a-expander-constants", "a-partial-expander").register("a-expander", function (A, $, expanderConstants, initializePartialExpanders) {
  var undefined;
  var elementClasses = expanderConstants.elementClasses;
  var classNames = expanderConstants.classNames;

  /**
   *  Regular expressions used in the removal of classes from icons.  Generated from classNames.
   *
   *  @private
   *  @type {object}
   *  @constant
   */
  var classRegex = {};
  A.each(classNames, function (classes, type) {
    classRegex[type] = {};
    A.each(classes, function (className, state) {
      classRegex[type][state] = new RegExp("\\b" + className + "\\b", "g");
    });
  });

  /**
   *  A toggle function that supports a fixed collapsed height as well as
   *  showing/hiding the expander content.
   *
   *  @private
   *  @param {jQuery element} $element
   *  @param {function} callback
   */
  function expanderToggle($element, callback) {
    var $expanderContainer = $element.closest('.' + elementClasses.container);
    var collapsedHeight = $expanderContainer.data('a-expander-collapsed-height');
    var isExpanded = $element.attr("aria-expanded") === "true";

    var onComplete = function() {
      //Toggle aria attributes / classes
      $element.toggleClass(elementClasses.content + '-expanded');
      $element.attr("aria-expanded", isExpanded ? "false" : "true");

      callback();
    }

    //Support a fixed collapsed height
    if (collapsedHeight) {
      $expanderContainer.css('height', isExpanded ? collapsedHeight : 'auto');
      onComplete();
    } else {
      $element.toggle(0, function () {
        onComplete();
      });
    }
  }

  /**
   *  Show/hide toggle expander content and update the icon and text for the header
   *
   *  @param {object} event
   */
  function toggleExpanderContent(event) {
    var $container = event.$target.closest('.' + elementClasses.container);
    var $subContainers = $container.find('.' + elementClasses.container);
    var expanderName = $container.data('a-expander-name');
    var $header;
    if (event.$currentTarget.hasClass(elementClasses.header)) {
      $header = event.$currentTarget;
    } else {
      $header = $container.find('.' + elementClasses.header).not($subContainers.find('.' + elementClasses.header));
    }
    var $content = $container.find('.' + elementClasses.content).not($subContainers.find('.' + elementClasses.content));

    var onToggleContentComplete = function() {
      var icon = $header.find(".a-icon")[0],
        prompt = null,
        $fadeDiv = $header.children('.' + elementClasses.fadeDiv),
        expanderAction;

      if ($content.attr("aria-expanded") === "false") { // Switch to the content hidden class names ('expand')
        if (icon) {
          icon.className = icon.className.replace(classRegex.inline.collapse, classNames.inline.expand)
            .replace(classRegex.section.collapse, classNames.section.expand)
            .replace(classRegex.extender.collapse, classNames.extender.expand);
        }
        if (event.data && event.data["expand_prompt"]) {
          prompt = event.data["expand_prompt"];
        }

        $fadeDiv.show();

        expanderAction = "collapse";
      } else { // Switch to the content visible class names ('collapse')
        if (icon) {
          icon.className = icon.className.replace(classRegex.inline.expand, classNames.inline.collapse)
            .replace(classRegex.section.expand, classNames.section.collapse)
            .replace(classRegex.extender.expand, classNames.extender.collapse);
        }
        if (event.data && event.data["collapse_prompt"]) {
          prompt = event.data["collapse_prompt"];
        }

        $fadeDiv.hide();


        expanderAction = "expand";
      }

      // Swap out text, if required
      if (prompt && prompt !== "") {
        $header.find(".a-expander-prompt").not($subContainers.find(".a-expander-prompt")).html(prompt);
      }

      // Publish events
      var expanderObj = {
        expander : {
          $expander: $container,
          expanderName: expanderName
        }
      };

      A.trigger('a:expander:toggle', expanderObj);

      A.trigger('a:expander:toggle:' + expanderAction, expanderObj);

      if (expanderName) {
        A.trigger('a:expander:' + expanderName + ':toggle', expanderObj);
        A.trigger('a:expander:' + expanderName + ':toggle:' + expanderAction, expanderObj);
      }
    };

    // Show/hide content
    expanderToggle($content, onToggleContentComplete);
  }

  // Bind to the correct events
  A.declarative("a-expander-toggle", "click", toggleExpanderContent);


  // Make "initializeExpanders" a public API so that people can call it manually if they
  // ajax in an expander
  return {
    initializeExpanders: initializePartialExpanders
  };
});
/////////////////////////
// END FILE js/expander.js
/////////////////////////

// END ASSET AmazonUIExpander-3.2.16725.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUISwitch@jsAssets", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUISwitch@jsAssets-3.2.16612.0
/////////////////////////
// BEGIN FILE js/switch.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* AUI Switch Component API
  Author: @tuanvo & @jordanw

  API for switch Component. This component depends on "a-switch-framework" for
  certain functions affecting the -switch-, in addition to some constant values defined in
  "a-switch-framework". "a-switch-framework" handles the interaction logic aswell.

  Functions defined here are accesible from client code.
*/

  "use strict";

P.when("a-switch-framework", "jQuery").register("a-switch", function(switchFramework, $) {

  // Globals Defined in "a-switch-framework"
  var SWITCH_STATE = switchFramework.SWITCH_STATE;
  var SWITCH_CONTAINER_CLASS = switchFramework.SWITCH_CONTAINER_CLASS;
  var SWITCH_CLASS = switchFramework.SWITCH_CLASS;

  /**
   * Allows client to retrieve a -switch- object, with API functions to interact with
   * a particular switch. Namely, this object references $switch associated with the $dom
   * parameter. The $switch's switchState data attribute will be initialized if an API call occurs,
   * and that -switch- has not been initialized yet.
   *
   * @param $dom Must not be null
   *   Note: if $dom is an jQuery array, only the first element will be processed and checked for $switch
   * @returns switchComponent [object]
   *   has API functions affecting a $switch associated with $dom
   *   null returned for invalid $dom as described in @param, or if $dom is empty
   */
  function getSwitch($dom) {

    /******** Begin "Constructor" ********/

    // cast to jQuery
    if (!$dom.jquery) {
      $dom = $($dom);
    }

    // empty object
    if ($dom.length === 0) {
      return null;
    }

    // Only retrieves switch for first element, where $dom is a jQuery array
    $dom = $dom.eq(0);

    var $switchContainer = $dom.closest("." + SWITCH_CONTAINER_CLASS);

    // no matched elements
    if ($switchContainer.length === 0) {
      return null;
    }

    // $switch which API functions reference
    var $switch = $switchContainer.find("." + SWITCH_CLASS);
    switchFramework.ensureInitialized($switch);

    /******** API Functions ********/

    /**
     * Mutator
     * toggles the -switch- if possible
     *
     * @returns success [boolean]
     *   true if -switch- was successfully toggled
     *   false otherwise (dragging / disabled)
     */
    function toggle() {
      return isOn(!$switch.data(SWITCH_STATE).isOn);
    }

    /**
     * getter: isOn()
     *   @returns isOn [boolean]
     *     current -on/off- state of the -switch-
     *
     * setter: isOn(isOn)
     *   @param isOn [boolean]
     *     -on/off- state to set -switch- to
     *   @returns success [boolean]
     *     true if -switch- was successfully switched ON
     *     false otherwise (dragging / disabled)
     */
    function isOn(isOn) {
      var switchState = $switch.data(SWITCH_STATE);

      /* Getter */
      if (isOn === undefined) {
        return switchState.isOn
      }

      /* Setter */

      // cannot set state
      if (!switchState.isEnabled || isDragging($switch)) {
        return false;
      }

      switchFramework.setOnState($switch, isOn);

      return true;
    }

    /**
     * getter: enabled()
     *   @returns isEnabled [boolean]
     *     current -enabled- state of the -switch-
     *
     * setter: enabled(isEnabled)
     *   @param isEnabled [boolean]
     *     -enabled- state to set -switch- to
     *   @returns changedState [boolean]
     *     true if the -enabled- state different from the original
     *     false if the switch is already in the desired -enabled-
     */
    function enabled(isEnabled) {
      var switchState = $switch.data(SWITCH_STATE);

      /* Getter */
      if (isEnabled === undefined) {
        return switchState.isEnabled;
      }

      /* Setter */

      // Check if the desired -enabled- state is same as prior -enabled- state
      if (switchState.isEnabled === isEnabled) {
        return false;
      }

      // State is different
      switchFramework.setEnabled($switch, isEnabled);

      return true;
    }

    /**
     * getter: label()
     *   @return label [string]
     *     -label- associated with the -switch-
     *
     *
     * setter: label(value)
     *   sets -label- of -switch- to the desired text
     *
     *   @param label [string]
     *     desired label text
     */
    function label(value) {
      var $label =  $switch.data(SWITCH_STATE).label,
        textNode = $label[0].childNodes[0];

      /* Getter */
      if(value === undefined) {
        return $label.text();
      }

      // If it's not a text node, short circuit
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      if(textNode.nodeType !== 3) {
        return;
      }

      /* Setter */
      textNode.textContent = value;
    }

    /**
     * Getter
     *    @returns isDragging [boolean]
     *      whether or not the -switch- is currently being dragged
     */
    function isDragging() {
      return $switch.data(SWITCH_STATE).isDragging;
    }

    // API Functions Targetting referencing this $switch
    return {
      toggle: toggle,
      isOn: isOn,
      enabled: enabled,
      isDragging: isDragging,
      label: label
    }
  }

  // Public function to retrieve -switch- object
  return {
    getSwitch: getSwitch
  };

});
/////////////////////////
// END FILE js/switch.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/switch_framework.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* AUI Switch Component Framework
  Author: @tuanvo & @jordanw

  This switch component is the UI equivalent of a light switch in the "real world".
  It has two states on/off. The user can click the switch to toggle on/off, in addition
  to be able to drag the switch and it will snap to the closest edge.

  This component handlers user interaction, and the switch implementation.
  The switch API, depends on this and is in a seperate module "a-switch". Clients shouldn't need to
  access functions from this component.

  The switch has an -enabled- state, which is not to be confused with -on/off-. This locks the switch from being turned -on/off-
  or dragged, both by the API and user interaction. Still, the -enabled- state can be toggled via the API. Currently,
  the -enabled- state couples both user interaction and API interaction together. It's possible that
  we want to lock the user, but not client code via the API, which will necessitate two seperate locks; this is a possible
  feature to add.

  ***** For Implementors *****
  User Interaction Handlers
    initSwitch()
    dragSwitch()
    clearSwitch()

  Mobile/Desktop Interface
    These abstract out desktop/mobile implementation.
    The code calls these functions agnostically, where the appropriate implementation
    will already be associated to these interfaces.

      bindInteraction()
      unbindInteraction()
      getCurrentX()

    This is not to say all implementation details about desktop/mobile are abstracted in the entirety of the code.
    There are parts with remnants that check for certain mobile/desktop values, and are not part of these
    functions, e.g. initially binding initSwitch based on mobile or desktop.

    Events Namespaced
      Events are namespaced (defined by the var SWITCH_EVENT_NAMESPACE), such that we won't interfere with client code.
      Still, the client code can interfere with us... they have great power, so they also have the great responsibility
      of namespacing their events aswell.

    Convention of Comments
      I write "-thing-" in the comments to talk about the thing in the abstract,
      not a particular object or variable. E.g. -switch state-.

  ****** Frequently Used Variable Names *****
  $switch [jQuery] (see Dom Structure)
  $container [jQuery] (see Dom Structure)
  $control [jQuery] (see Dom Structure)
  switchState [object] data attribute of $switch

  Look inside initializeSwitchData() for info on variables inside switchState

  ****** Assumptions *****
  ON/OFF --> Left/Right
    Currently, ON/OFF are coupled with ON being the right side of the switch, and OFF being the left side of the switch.
    This is an assumption pervasive in the code. While it's possible to define left/right as a function of ON/OFF, and
    have the code access this mapping, we still don't want client code to set this themselves. We want AUI to be consistent across
    devices/pages, and it would be confusing to end users if the switch had inconsistent convention.
    What if a nation was inconsistent in whether cars should drive on the left or right side of the road?
  -switch state- Data attribute not encapsulated
    State data of each -switch- element stored in a data attribute, under the key: (var SWITCH_STATE). This is part of the dom,
    and client code access if they wanted to. Ofcourse, they'd have to try to do it on purpose.
  Dom structure
    The code has an assumed dom structure. Meaning, client doesn't alter this.
    Dom traversal in the code reflects this given structure:

      <div class="a-switch-row"> <!-- container -->
        <span class="a-switch-label">Default Label</span> <!-- Label -->
        <input type="checkbox"> <!-- checkbox -->
        <div class="a-switch a-declarative" data-action="a-switch"> <!-- switch -->
          <a class="a-switch-control" style="-webkit-transform: translateX(-1px) translateZ(0px);"></a> <!-- switch control -->
        </div>
      </div>

  ON/OFF
    class "a-active" applied to the -container- for on, class is absent for off (default).
    This is applied on -container- not the -switch-, because we want to stylize the -label- aswell.
  Enabled/Disabled
    class "a-disabled" applied to the -container- for -disabled-, class is absent for -enabled- (default)
    This is applied on -container- not the -switch-, because we want to stylize the -label- aswell.
  Left vs right offset
    Chosen to be left, for CSS3 Translate. The css left property applied if no css3 translate, otherwise
    translateX() used.
*/

"use strict";

P.when("A", "jQuery").register("a-switch-framework", function (A, $) {

  var undefined;

  /**
   *  If the user clicks on the switch or the state is changed via an API, this is the duration
   *  of the animation.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ANIMATION_TIME = 300;

  /**
   *  If the user clicks on the switch or the state is changed via an API, this is the easing function
   *  of the animation.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ANIMATION_EASING = "ease-out";

  /**
   *  Various strings who are used repeatedly.  They've been made constants in order to improve
   *  the compression of this file and to prevent us from misspelling these things...
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var SWITCH_EVENT_NAMESPACE = "a-switch-component";
  var SWITCH_CONTROL_CLASS = "a-switch-control";
  var SWITCH_LABEL_CLASS = "a-switch-label";

  /**
   *  The name of the data attribute which contains the state of a swtich for a particular DOM node
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_STATE = "a-switch-state";

  /**
   *  The class name for <div> which contains the "fancy" UI portion of the switch.  This includes the
   *  moving block and the color changing background.  It also defines the draggable area of the switch
   *  block.
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_CLASS = "a-switch";

  /**
   *  The class name for the <div> which contains ALL components of a switch, including the label and
   *  checkbox.
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_CONTAINER_CLASS = "a-switch-row";

  /********************************** EVENT HANDLERS **********************************/

  // Event Handlers for User Interaction
  var handlers = {
    mobile: {
      bind: function ($switch) {
        $switch.bind("touchmove." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, dragSwitch);
        $switch.bind("touchend." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
        $switch.bind("touchcancel." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);

        // Some mobile browsers occasionally fire mouseup
        $switch.bind("mouseup." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
      },
      unbind: function ($switch) {
        $switch.unbind("touchmove." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("touchend." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("touchcancel." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("mouseup." + SWITCH_EVENT_NAMESPACE);
      },
      getX: function ($event) {
        var touch = $event.originalEvent.touches[0] || $event.originalEvent.changedTouches[0];
        return touch.pageX;
      }
    },
    desktop: {
      bind: function ($switch) {
        // bind to body because we want interaction to continue even when
        //   we move mouse out of switch,
        $("body").bind("mousemove." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, dragSwitch);
        $("body").bind("mouseup." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
      },
      unbind: function ($switch) {
        $("body").unbind("mousemove." + SWITCH_EVENT_NAMESPACE, dragSwitch);
        $("body").unbind("mouseup." + SWITCH_EVENT_NAMESPACE, clearSwitch);
      },
      getX: function ($event) {
        return $event.pageX;
      }
    }
  };

  /**
   *  User Interaction Handler
   *    Initialize -switch- for dragging/toggling
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function initSwitch(event) {
    var $event = event.$event; // jQuery event obj, as opposed to AUI declarative event obj
    $event.preventDefault();

    // mouse/desktop interaction, but not left mousedown
    if (!A.capabilities.touch && $event.which !== 1) {
      return;
    }

    var $switch = event.$declarativeParent;

    // (re)initialize switchState
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    switchState.dragCount = 0;
    switchState.clicked = true;  // TODO: remove after 3.15.6 - for backward compatibility

    // redundant with statement in clearSwitch, but Chrome on Android is dumb and doesn't fire end events
    switchState.isDragging = false;

    // Interaction allowed only for -enabled switches-
    if (switchState.isEnabled) {
      switchState.initialX = getCurrentX($event);

      bindInteraction($switch);
    }
  }

  /**
   *  User Interaction Handler
   *    moves -switch control- with user dragging
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function dragSwitch($event) {
    /* Some browser/os combinations allow dragging/dropping of browser content into OS inteface*/
    $event.preventDefault();

    var $switch = $event.data.$switch;
    var switchState = $switch.data(SWITCH_STATE);
    var $control = switchState.control;

    // -switch- could be moving to an edge, with nonzero (see global var ANIMATION_TIME) animation time
    if (A.isAnimated($control)) {
      return;
    }

    // compute updated leftOffset
    var currentX = getCurrentX($event);
    var leftOffset = computeLeftOffset(currentX, switchState);

    // position hasn't changed
    if (leftOffset === switchState.leftOffset) {
      return;
    }

    // Update Position
    A.animate($control, {
      left: leftOffset
    }, 0);
    switchState.leftOffset = leftOffset;

    switchState.isDragging = true;
    switchState.dragCount++;
  }

  /**
   *  User Interaction Handler
   *    rests the -switch control- at an edge
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function clearSwitch($event) {
    $event.preventDefault();

    // desktop interaction, and not being cleared with left mouseout
    if (!A.capabilities.touch && $event.which !== 1) {
      return;
    }

    var $switch = $event.data.$switch;
    var switchState = $switch.data(SWITCH_STATE);

    // Decides to snap or toggle, then update -on/off- state of -switch state-
    setOnState($switch, shouldToggle($switch, switchState));

    switchState.isDragging = false;

    unbindInteraction($switch);
  }

  /********************************** END EVENT HANDLERS **********************************/

  /********************************** PRIVATE HELPER FUNCTIONS **********************************/

  // Default switch slider boundaries.
  var bounds = {
    left: (A.capabilities.rtl) ? 1 : -1 ,
    right: -1
  };

  // switch Direction
  var switchDirection = (A.capabilities.rtl) ? -1 : 1 ;

  // If a skin is present, override base vars with skin vars
  P.when('prv:skin-vars').execute(function(vars) {
    bounds = vars.toggle.bounds;
  });

  /**
   * Helper
   *    Initializes the -switch state- data attribute
   *
   *  @private
   *  @param {HTMLElement} $switch
   */
  function initializeSwitchData($switch) {
    // cache dom relationships
    var $container = $switch.closest("." + SWITCH_CONTAINER_CLASS);
    var $control = $switch.children("." + SWITCH_CONTROL_CLASS);
    var $label = $container.find("." + SWITCH_LABEL_CLASS);  // TODO: change back after 3.15.6 - $switch.closest
    var $input = $label.siblings("input"); // TODO: change back after 3.15.6  - $label.prev

    var name = $input.attr("name");

    var isOn = $container.hasClass("a-active");
    var isEnabled = !$container.hasClass("a-disabled");

    var leftBoundary = bounds.left;
    var rightBoundary =  (($switch.width() - $control.width()) + bounds.right) * switchDirection;
    var midPoint = (rightBoundary / 2);
    var leftOffset = isOn ? rightBoundary : leftBoundary; // initial position
    var maxLeftOffset = bounds.maxLeftOffset; // can be set by skin vars (or undefined in beacon)

    $switch.data(SWITCH_STATE, {
      input: $input, // [jQuery dom]
      container: $container, // [jQuery dom]
      control: $control, // [jQuery dom]
      label: $label, // [jQuery dom]
      isDragging: false, // [boolean]
      rightBoundary: rightBoundary, // [int], pixels or rems
      leftBoundary: leftBoundary, // [int], pixels or rems
      midPoint: midPoint, // [int], pixels or rems
      initialX: null, // [int] mouse/touch coordinate at initSwitch call
      leftOffset: leftOffset, // [int] position of switch control from left edge
      maxLeftOffset: maxLeftOffset, // [int or undefined] if defined, control will not move beyond
      isOn: isOn, // [boolean]
      isEnabled: isEnabled, // [boolean]
      name: name, // [string] name of input element
      dragCount: 0, // [int] threshold marker for snap / toggle
      clicked: false // [boolean] TODO: remove after 3.15.6
    });
  }

  /**
   * Helper
   *    snaps to closest side (associated with on/off), if -switch- has been dragged.
   *    toggles between on/off otherwise.
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   *  @returns {boolean} isOn
   */
  function shouldToggle($switch, switchState) {
    // (switchState.dragCount > 1) defines a threshold for if user meant to toggle, but drags 1px
    // this also address MS surface bug, that fires ATLEAST one mousemove, even if you havn't moved
    var snap = switchState.isDragging && (switchState.dragCount > 1);

    return snap ? (switchState.leftOffset > switchState.midPoint) : !switchState.isOn;
  }

  /**
   * Helper
   *    Syncs -control- with -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateControl($switch, switchState) {
    var $control = switchState.control;
    var maxLeftOffset = switchState.maxLeftOffset;

    // Moves -control- to edge based on updated -switch state-
    var leftOffset = switchState.isOn ? switchState.rightBoundary : switchState.leftBoundary;
    leftOffset = (maxLeftOffset && leftOffset > maxLeftOffset) ? maxLeftOffset : leftOffset;

    A.animate($control, {
      left: leftOffset
    }, ANIMATION_TIME, ANIMATION_EASING);

    switchState.leftOffset = leftOffset;
  }

  /**
   *  Helper
   *    Syncs -switch container- and -switch label- with -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateContainer($switch, switchState) {
    var $container = switchState.container;

    switchState.isOn ? $container.addClass("a-active") : $container.removeClass("a-active");
  }

  /**
   *  Helper
   *    Syncs -checkbox- with value in -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateCheckbox($switch, switchState) {
    var $checkbox = switchState.input;

    switchState.isOn ? $checkbox.attr("checked", "checked") : $checkbox.removeAttr("checked");
  }

  /**
   *  Helper
   *    Fires -switch- events, with the given action
   *      'a:switch:[switchName]:action' // specify the particular -switch-
   *      'a:switch:action' // generic for all toggle -switches-
   *    ( where switchName is the name of the input element associated with the -switch-)
   *
   *  @private
   *  @param {object} switchState
   *  @param {string} action - The name of the action, e.g. ('on', 'off', 'flipped')
   *  @param {boolean} [previousState] - The previous state of the control.  Can be undefined...
   */
  function triggerSwitchEvent(switchState, action, previousState) {
    var callbackData = {
      switchState: switchState,
      previousState: previousState
    };
    A.trigger("a:switch:" + action, callbackData);
    if (switchState.name) {
      A.trigger("a:switch:" + switchState.name + ":" + action, callbackData);
    }
  }

  /**
   *  Helper
   *    Computes new leftOffset value
   *    (does not affect -switch state-, e.g. mutate switchState.leftOffset)
   *
   *  @private
   *  @param {number} currentX - The current mouse position
   *  @param {object} switchState
   *
   *  @returns {number} leftOffset
   */
  function computeLeftOffset(currentX, switchState) {
    // Difference in mouse position
    var leftOffset = currentX - switchState.initialX;

    // accounts for initial side being "right"
    if (switchState.isOn) {
      leftOffset += switchState.rightBoundary;
    }

    // bounds -switch control- inside -switch container-
    leftOffset = checkDragBoundary(leftOffset,
      switchState.leftBoundary,
      switchState.rightBoundary
    );

    return leftOffset;
  }

  /**
   *  Helper
   *    Computes leftOffset bounded by upper/lower bounds, associated with left/right edges respectively
   *    (prevents -switch control- from being dragged outside the -switch-)
   *
   *  @private
   *  @param {number} leftOffset
   *  @param {number} lowerBound - Left edge of the switch UI
   *  @param {number} upperBound - Right edge of the switch UI
   *
   *  @returns {number} boundedLeftOffset
   */
  function checkDragBoundary(leftOffset, lowerBound, upperBound) {
    if (leftOffset < lowerBound) {
      return lowerBound;
    } else if (leftOffset > upperBound) {
      return upperBound;
    }

    return leftOffset;
  }

  /********************************** END PRIVATE HELPER FUNCTIONS **********************************/

  /********************************** PUBLIC APIS **********************************/

  /**
   *  Helper
   *    initialize -switch- if it isn't already initialized
   *
   *  @public
   *  @param {HTMLElement} $switch
   */
  function ensureInitialized($switch) {
    if (!$switch.data(SWITCH_STATE)) {
      initializeSwitchData($switch);
    }
  }

  /**
   * Helper
   *    Sets -on/off- state of the -switch-, updating components (-control-, -container-, -checkbox-) aswell
   *
   *  @public
   *  @param {HTMLElement} $switch
   *  @param {boolean} isOn - State to set the switch to
   */
  function setOnState($switch, isOn) {
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    var prevState = switchState.isOn;

    var flipped = (isOn !== switchState.isOn); // -switch- changed states

    switchState.isOn = isOn;

    // Syncs components of the -switch- with the -switch state-
    updateControl($switch, switchState);
    updateContainer($switch, switchState);
    updateCheckbox($switch, switchState);

    // Trigger Events
    if (flipped) {
      triggerSwitchEvent(switchState, "flip", prevState);
    }
    if (isOn) {
      triggerSwitchEvent(switchState, "on", prevState);
    } else {
      triggerSwitchEvent(switchState, "off", prevState);
    }
  }

  /**
   * Helper
   *    Sets -enabled- state of the -switch-
   *
   *  @public
   *  @param {HTMLElement} $switch
   *  @param {boolean} isEnabled
   */
  function setEnabled($switch, isEnabled) {
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    var $container = switchState.container;

    isEnabled ? $container.removeClass("a-disabled") : $container.addClass("a-disabled");

    switchState.isEnabled = isEnabled;
  }

  /********************************** END PUBLIC APIS **********************************/

  /********************************** MOBILE/DESKTOP ABSTRACTION **********************************/


  /*
   * These helper functions are interfaces that abstract out touch/mouse implementation.
   * This allows the invoker to be agnostic about touch/mouse.
   */

  /**
   *  Interface (details about touch/mouse implementation left out)
   *  bind user interaction event (drag/clear) handlers for the -switch-.
   *
   *  @private
   *  @param $switch [jQuery]
   */
  var bindInteraction = null;

  /**
   *  Interface (details about touch/mouse implementation left out)
   *  unbind user interaction event (drag/clear) handlers for the -switch-.
   *
   *  @private
   *  @param {HTMLElement} $switch
   */
  var unbindInteraction = null;

  /**
   *  Interface (details about touch/mouse implementation left out)
   *
   *  @private
   *  @param {jQuery.event} $event
   *  @returns {number} currentX - Current mouse or touch x-coordinate
   */
  var getCurrentX = null;

  // Instantiates the appropriate implementation
  if (A.capabilities.touch) {
    bindInteraction = handlers.mobile.bind;
    unbindInteraction = handlers.mobile.unbind;
    getCurrentX = handlers.mobile.getX;
  } else {
    bindInteraction = handlers.desktop.bind;
    unbindInteraction = handlers.desktop.unbind;
    getCurrentX = handlers.desktop.getX;
  }

  /********************************** END MOBILE/DESKTOP ABSTRACTION **********************************/

  /********************************** INITIALIZE SWITCH INTERACTION **********************************/

  var initEvent = A.capabilities.touch ? "touchstart" : "mousedown";
  A.declarative("a-switch", initEvent, initSwitch);

  /* Changing of -input- toggles the -switch-. */
  A.declarative("a-switch-input", "change", function (event) {
    var $event = event.$event;
    $event.preventDefault();

    var $input = event.$target;
    var $container = $input.closest("." + SWITCH_CONTAINER_CLASS); // TODO: change back after 3.15.6 - $label = $input.next
    var $switch = $container.find("." + SWITCH_CLASS); // TODO: change back after 3.15.6 - $label.children

    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);

    setOnState($switch, !switchState.isOn);

  });

  /* TODO: remove after 3.15.6 - Clicking of -label- toggles the -switch-. */
  A.declarative("a-switch-label", "click", function (event) {
    var $event = event.$event;
    $event.preventDefault();

    var $label = event.$target;
    var $container = $label.closest("." + SWITCH_CONTAINER_CLASS);
    var $switch = $container.find("." + SWITCH_CLASS);

    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);

    // If we are using the templates from 3.15.6
    if (switchState.clicked) {
      switchState.clicked = false;
      return;
    }

    if(switchState.isEnabled){
      setOnState($switch, !switchState.isOn);
    }

  });

  // Normalize visible switch state with underlying checkbox
  P.when('ready').execute('a-switch-normalization', function() {
    
    $('.a-switch-input').each(function() {
      var $input = $(this),
        $switch = $input.next().children('.' + SWITCH_CLASS);
      setOnState($switch, $input.prop('checked'));
    });
  });

  /********************************** END INITIALIZE SWITCH INTERACTION **********************************/

  /********************************** EXPOSE SWITCH FRAMEWORK **********************************/

  return {
    ensureInitialized: ensureInitialized,
    setOnState: setOnState,
    setEnabled: setEnabled,
    SWITCH_STATE: SWITCH_STATE,
    SWITCH_CONTAINER_CLASS: SWITCH_CONTAINER_CLASS,
    SWITCH_CLASS: SWITCH_CLASS
  };

});
/////////////////////////
// END FILE js/switch_framework.js
/////////////////////////

// END ASSET AmazonUISwitch@jsAssets-3.2.16612.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIProgressBar", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIProgressBar-3.2.16589.0
/////////////////////////
// BEGIN FILE js/progress.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
P.when("A", "ready").register("a-progress", function(A) {

  var $ = A.$;

  // Class name constants that interface with javascript.
  var PROGRESS_CLASS = ".a-js-progress-bar",
      TOOLTIP_CLASS  = ".a-js-progress-tooltip",
      ARROW_CLASS    = ".a-js-tooltip-arrow",

      // Tooltip animation classes
      REVEALED_CLASS = "a-progress-tooltip-revealed",
      HIDDEN_CLASS   = "a-progress-tooltip-hidden",

      // Hardcoded width because .width() doesn't grab border-width.
      TOOLTIP_ARROW_WIDTH = 18,
      TOOLTIP_ARROW_DISPLAY_THRESHOLD = (TOOLTIP_ARROW_WIDTH / 2) + 3;

  /*
    init - The function most pertinent to the event listeners, it runs
    every single time there's a resize or scroll, and a single
    time to accomodate the "ready" event.
  */
  function init(component) {

    var components = component ? $(component) : $(PROGRESS_CLASS);


    components.each(function() {
      var progress = $(this);

      if(A.onScreen(progress, 0)) {
        update(progress);
        reveal(progress.find(TOOLTIP_CLASS));
      }

    });
  }

  /*
    update - a driver function that updates a single progress component
    component: a DOM node representing the root of the component
  */
  function update(component) {
    var state = {};

    // Grab the current state of this component.
    // Unary plus (+) casts a string into an integer.
    state.percentage = +(component.attr('data-progress-percentage'));
    state.complement = -(state.percentage - 100);
    state.bounds     = component.width();
    state.remainder  = state.bounds * (state.complement / 100);
    state.tooltip    = component.find(TOOLTIP_CLASS); // $

    _update_tooltip(state);
  }

  /*
    reveal - it just... it adds a class that has animation props.
  */
  function reveal(tooltip) {
    $(tooltip).removeClass(HIDDEN_CLASS).addClass(REVEALED_CLASS)
  }

  /*
    _update_tooltip - A helper function that is responsible for modifying a tooltip
                      based on state.

    state: An object that contains three properties relating to the state
           of the parent tooltip

          percentage: the percentage of meter that's filled
          complement: the percentage of meter that's empty
          bounds    : the 'bounds' that the tooltip must stay in.
                      typically the width of the progress component
          remainder : the width of the part of the meter that's empty'
          tooltip   : the tooltip that belongs to this progress component
  */
  function _update_tooltip(state) {
    var tooltip   = state.tooltip,
        tipwidth  = tooltip.width(),
        arrow     = tooltip.find(ARROW_CLASS),
        at        = state.percentage + (state.complement / 2),
        position  = state.bounds * (at/100) - (tipwidth / 2),
        fullwidth = tipwidth + position,
        bounded   = (fullwidth < state.bounds);


    if(!bounded) {
      position -= (fullwidth - state.bounds);
    }

    _align(tooltip, position, 0);
    _update_arrow({
      tooltip   : tooltip,
      remainder : state.remainder,
      bounded   : bounded
    });
  }

  /*
    _update_arrow - A helper function that aligns a tooltip arrow to its parent

    state: An object that contains three properties relating to the state
           of the parent tooltip

           tooltip: the parent tooltip
           remainder: the remaining dead space in the meter
           bounded: whether or not the tooltip went past the meter in width
  */
  function _update_arrow(state) {
    var tooltip  = state.tooltip,
        tipwidth = tooltip.width(),
        arrow    = state.tooltip.find(ARROW_CLASS);

    // Reset state
    arrow.removeClass('aok-hidden');

    // if the tooltip was out of bounds,
    if(!state.bounded) {
      _align(arrow, tipwidth, -TOOLTIP_ARROW_WIDTH * 1.5);
    }
    else {
      _align(arrow, tipwidth / 2, -TOOLTIP_ARROW_WIDTH / 2)
    }

    // if the tooltip arrow is greater than 'half the arrow width plus three'
    if(state.remainder < TOOLTIP_ARROW_DISPLAY_THRESHOLD) {
      arrow.addClass('aok-hidden')
    }

  }

  /*
    _align - A help function that aligns a child element horizontally to its parent

    child:  a DOM reference to the child element
    to:     a number within the bounds of the parent to align to
    offset: a number to add or subtract to the final alignment location

  */
  function _align(child, to, offset) {
      $(child).css('left', to + offset);
  }

  // Initialize
  init();
  A.on("resize scroll", function(e) {
    init();
  });

  // Returning API so progress bars can be reinitialized at runtime
  return {
    init: init
  }

});
/////////////////////////
// END FILE js/progress.js
/////////////////////////
// END ASSET AmazonUIProgressBar-3.2.16589.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPopover@base", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPopover@base-3.2.17177.0
/////////////////////////
// BEGIN FILE js/base/popover_base_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  @deprecated
 *  Popover API class
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory').register('a-popover-base-apis', function (A, factory) {
  var undefined,
    $ = A.$,
    LOCK_SYSTEM = 1;

  /**
   *  @deprecated
   *  Please use popover.get(id).show()
   *
   *  Show a popover customized with an options hash.  Popovers are created if
   *  necessary (first user interaction, DOM changes, etc), and the state of
   *  other popovers is changed if necessary.
   *
   *  @public
   *  @param {object} options  A hash of customizations to the popover
   *
   *  @return {object} popover
   */

  function show(options) {
    var $trigger = options.$trigger ? options.$trigger : options; //now $trigger is moved away from options in popover/modal etc class,
    //this is for backward compatibility
    //if option.$trigger is not set, will treat the first argument as id
    var popover = factory.get($trigger);
    if (popover) {
      return popover.show.apply(popover, arguments);
    }
  }

  /**
   *  @deprecated
   *  Please use popover.get(id).hide();
   *
   *  Hide the popover with the given ID
   *
   *  @public
   *  @param {string|number|object} id
   *
   *  @return {object} popover
   */

  function hide(id) {
    var popover = factory.get(id);
    if (popover) {
      // Unlock the popover as it is explicitly called to be hidden
      popover.unlock(LOCK_SYSTEM);
      return popover.hide.apply(popover, arguments);
    }
  }

  /**
   *  @deprecated
   *  Please use popover.get(id);
   *
   *  Get a popover by passing its ID, name, or the $trigger element
   *
   *  @public
   *  @param {string|number|object} id  The popover ID, name, or $trigger
   *
   *  @return {object}  Popover instance
   */

  function get(id) {
    return factory.get(id);
  }

  /**
   *  @deprecated
   *  Please use popover.remove(id);
   *
   *  Remove the popover DOM elements with the associated ID/name/$trigger
   *
   *  @public
   *  @param {string|number|object} id  The popover ID, name, or $trigger
   */

  function remove(id) {
    return factory.remove(id);
  }

  /**
   * APIs in popover_base are not meant to be public; it should only be consumed by leave classes
   * such as popover/modal/tooltip
   *
   * Keeping the show/hide/get/remove method just to keep back compatibility
   *
   * Now popover will auto refresh upon updates, making the remove() method unnecessary
   */
  return {
    show: show, // deprecated, please use popover.get(id).show();
    hide: hide, // deprecated, please use popover.get(id).hide();
    get: get, // deprecated, please use popover.get(id);
    remove: remove // deprecated, please use popover.remove(id);
  }
});
/////////////////////////
// END FILE js/base/popover_base_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base factory for popovers.
 *
 */

'use strict';

/**
 *  All the CRUD functionality for a default popover is in this module.
 */
P.when('A', 'a-popover-util', 'a-popover-objectclass', 'a-popover-data').register('a-popover-base-factory', function (A, util, objectclass, data) {
  var $ = A.$;

  /**
   *  The name of the data attribute which contains the popover's ID.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var POPOVER_ID_DATA_ATTR = "a-popover-id";

  /**
   *  The class defined as a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1;

  /**
   *  This will contain the ID of the next popover which will be created and is incremented after each create.
   *
   *  @private
   *  @type {number}
   */
  var popoverId = 1;

  /**
   *  A name -> popover hash useful when reusing named popover DOM nodes.
   *
   *  @private
   *  @type {object}
   */
  var named = {};

  /**
   *  An ID -> object hash containing all popovers which currently exist on the page.
   *
   *  @private
   *  @type {object}
   */
  var existing = {};

  /**
   *  The "fake" DOM node which acts as the trigger and popover of the root popover
   *
   *  @private
   *  @type {DOM Node}
   */
  var ROOT_POPOVER_NODE = $("<div id='a-popover-root' style='z-index:-1;position:absolute;' />").appendTo('body');

  /**
   *  The ID of the root popopver.  Constant used for self-documenting some code.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ROOT_POPOVER_ID = -1;

  /**
   *  The fake parent popover of all popovers who wouldn't otherwise have a parent.
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var ROOT_POPOVER;

  /**
   * Insert a popover that current exist in the page
   *
   * @private
   * @param {object} popover  popover instance
   */

  function _addExisting(popover) {
    existing[popover.id] = popover;
  }

  /**
   *  Get an existing popover by ID
   *
   *  @private
   *  @param {number} id
   *
   *  @return {object} popover
   */
  function _getPopoverById(id) {
    return existing[id] ? existing[id] : null;
  }

  /**
   * Setter for named array
   *
   * @private
   * @param {object} popover  Popover instance to set
   */
  function _setNamedPopover(popover) {
    if (popover.name) {
      named[popover.name] = popover;
    }
  }

  /**
   * Getter for named array
   *
   * @private
   * @param {string} name  Name of the popover to fetch
   *
   * @return {object}  popover instance
   */
  function _getNamedPopover(name) {
    return named[name] ? named[name] : null;
  }

  /**
   * Create popover instance
   *
   * @param {object} attribute              Hash of attributes for popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *
   * @return {object}  popover instance
   */
  function _createInstance(attributes, typeSpecificFunctions) {
    return new objectclass.PopoverClass(attributes, typeSpecificFunctions);
  }

  /**
   * Create a new popover with the given customization options.
   *
   * @private
   * @param {object} trigger                DOM of the trigger
   * @param {object} attribute              Hash of attributes for popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *
   * @return {object} popover
   */
  function _doCreate(trigger, attributes, typeSpecificFunctions) {
    /*jshint validthis:true */
    var $trigger = $(trigger),
      type = attributes.type,
      $triggerWrapper = null,
      popover = null;

    // Require type to continue
    if (!type) {
      return null;
    }

    // Gotta have a trigger
    if (!$trigger || !$trigger.length) {
      return null;
    }

    // Create a new popover
    var attributes = A.extend({
      id: popoverId++,
      $trigger: $trigger,
      $triggerWrapper: $triggerWrapper
    }, attributes),
      typeSpecificFunctionsCopy = A.copy(typeSpecificFunctions),
      popover = _createInstance(attributes, typeSpecificFunctionsCopy);

    // Add and register popover
    _addExisting(popover);
    _setNamedPopover(popover);
    $trigger.data(POPOVER_ID_DATA_ATTR, popover.id);

    // Put this popover in the correct place in the popover tree.
    var $parent = popover.$trigger.closest(".a-popover");
    var parentPopover;
    if (!popover.attrs("immersive") && $parent.length) {
      parentPopover = _getPopoverById($parent.data(POPOVER_ID_DATA_ATTR)) || getRoot();
    } else {
      parentPopover = getRoot();
    }
    popover.parent = parentPopover;
    parentPopover.children.push(popover);

    return popover;
  }

  /**
   *  Get a popover by passing its ID, name, or the $trigger element
   *
   *  @public
   *  @param {string|number|object|popover} id  The popover ID, name, or $trigger
   *  @param {string} type  Popover type
   *
   *  @return {object|null}  popover instance
   */

  function _doGet(id, type) {
    var popover = null;

    // If id is number, get by checking existing indexes
    if (typeof id === 'number') {
      popover = _getPopoverById(id);
    }
    // If 'id' is a name, then get by name
    // else get by ID
    else if (typeof id === 'string') {
      popover = _getNamedPopover(id);
      if (!popover) {
        popover = _getPopoverById(id);
      }
    }
    // We also allow people to pass in the $trigger and get the popover,
    // so pull the ID off of the $trigger
    else if (typeof id === 'object') {
      if (id.$popover) {
        // The input itself is a popover object
        popover = id;
      } else {
        // If all of the above failed, there are three possibilites:
        // 1. id is $trigger
        // 2. id is a $popover
        // 3. the user might have created declarative action from create() method
        // and do not know the declarative action is actually inside the original DOM.
        var $id = $(id),
          pid = $id.data(POPOVER_ID_DATA_ATTR);
        if (!pid) {
          var $trigger = $id.find("." + DECLARATIVE_CLASS).eq(0),
            pid = $trigger.length ? $trigger.data(POPOVER_ID_DATA_ATTR) : null;
        }
        popover = _getPopoverById(pid);

        // For the case of people triggering different popover with the same name,
        // we give them the popover if the name is the same
        if (!popover) {
          var action = $id.data("action"),
            actionParams = action ? $id.data(action) : null;
          if (actionParams && actionParams.name) {
            //allow popover reuse if the type is the same and the data strategy allows it
            popover = _getNamedPopover(actionParams.name);
            if (popover && (!type || popover.type === type)) {
              var currentDataStrategyName = popover.attrs("currentDataStrategy");
              var currentDataStrategy =  currentDataStrategyName ? data.getStrategyByName(currentDataStrategyName) : data.guessStrategyByAttrs(popover.attrs());

              if (currentDataStrategy && currentDataStrategy.reusePopover){
                //since there is a possibility that different triggers are sharing the same name
                //we change $trigger and a-popover-id here just to make sure
                if (popover.$trigger[0] !== $id[0]) {
                  popover.$trigger.data(POPOVER_ID_DATA_ATTR, null);
                  popover.$trigger = $id;
                }
              } else {
                popover = null;
              }
            } else {
              popover = null;
            }
          }
        }
      }
    }
    return popover;
  }

  /**
   *  Destroy a popover with the given ID as well as its associated DOM nodes
   *
   *  @public
   *  @param {object} popover  popover instance
   *
   *  @return {boolean}  if operation succeed
   */

  function _doRemove(popover) {
    var id = popover.id;

    if (popover && id > ROOT_POPOVER_ID) {
      var idx = A.indexOfArray(popover.parent.children, popover),
        $container = popover.$container,
        $trigger = popover.$trigger,
        $triggerWrapper = popover.$triggerWrapper;

      popover.parent.children.splice(idx, 1);

      popover.unlock().hide(); // Hide popover and its children
      popover.update({
        content: ""
      });

      // Remove content if popover has been shown before
      if ($container) {
        popover.$container.remove();
      }

      // Unsetting id from $trigger
      $trigger.data(POPOVER_ID_DATA_ATTR, "");

      // Remove object
      if (popover.name) {
        delete named[popover.name];
      }
      delete existing[id];
      popover = null;

      return true;
    } else {
      return false;
    }
  }

  /**
   *  Get the root popover node
   *
   *  @public
   *
   *  @return {object} ROOT_POPOVER
   */

  function getRoot() {
    //lazy initization
    if (!ROOT_POPOVER) {
      ROOT_POPOVER = _createInstance({
        id: ROOT_POPOVER_ID,
        $popover: ROOT_POPOVER_NODE,
        $trigger: ROOT_POPOVER_NODE,
        immersive: true
      }, {
        isActive: function () {
          return true;
        },
        hideMethod: function () {
          this.hideChildren();
        },
        showMethod: A.constants.NOOP
      });
    }
    return ROOT_POPOVER;
  }

  /**
   *  Get a popover by passing its ID, name, or the $trigger element
   *  Will return null if obtained instance's type does not match with API popover type
   *
   *  @public
   *  @param {string|number|object|popover} id  The popover ID, name, or $trigger
   *  @param {string} type                      Popover type
   *
   *  @return {object|undefined}  The popover or undefined
   */

  function get(id, type) {
    /*jshint validthis:true */
    var type = type ? type : (this ? this.type : null),
      popover = _doGet(id, type);

    // Sanity check, see if the popover is of the same type as requested if the request is popover type factory
    if (popover && type && popover.type !== type) {
      return null;
    } else {
      return popover;
    }
  }

  /**
   * Create a new popover with the given customization options.
   * Will return null if the $trigger's declaration action does not match with API popover type
   *
   * @private
   * @param {object} trigger  DOM of the trigger
   * @param {object} options  Hash of options
   *                 {object} attribute     Hash of attributes for popover
   *                 {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *                 {object} actionCheck   Whether to check if action type matches
   *
   * @return {object} popover
   */
  function create(trigger, options) {
    var $trigger = $(trigger),
      attributes = options.attributes || {},
      typeSpecificFunctions = options.typeSpecificFunctions || options.variant || {}, // options.variant is for back-compat from previous name
      actionCheck = options.actionCheck || false,
      id = $trigger.data('a-popover-id'),
      type = attributes.type,
      popover = null;

    // If the user is passing in a DOM without declarative action, create one for them
    if (type && (!$trigger.hasClass(DECLARATIVE_CLASS) || !$trigger.data("action") || $trigger.data("action").indexOf(type) === -1)) {
      $trigger = A.declarative.create($trigger, "a-" + type);
      trigger = $trigger[0];
    }

    // Action type matching check
    if (actionCheck && $trigger.data("action") && $trigger.data("action").indexOf(type) === -1) {
      return null;
    }

    // If there is $trigger, see if there is already a valid instance created
    if (type && $trigger) {
      popover = _doGet($trigger);
    }

    // Return a popover
    if (!popover) {
      return _doCreate(trigger, attributes, typeSpecificFunctions);
    } else if (popover.type !== type) {
      return null;
    } else {
      return popover;
    }
  }

  /**
   *  Destroy a popover with the given ID as well as its associated DOM nodes.
   *  Will not remove if the id does not match with API popover type.
   *  Will also remove the associated declarative actions if the second parameter is truthy.
   *
   *  @public
   *  @param {number} id  The popover's ID
   *  @param {string} action  (optional) If you would like to remove a declarative action from the DOM node, pass the action name here
   *
   *  @return {boolean}  if operation succeed
   */

  function remove(id, action) {
    /*jshint validthis:true */
    var popover = this.get(id),
      isSuccess = false;

    // Remove popover is a valid popover is found
    if (popover) {
      isSuccess = _doRemove(popover);
      if (action) {
        A.declarative.remove(popover.$trigger[0], "a-" + action);
      }
    }

    return isSuccess;
  }

  return {
    getRoot: getRoot,
    get: get,
    create: create,
    remove: remove
  };
});
/////////////////////////
// END FILE js/base/popover_base_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Common delegates AUI Popover framework
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-base-factory', 'prv:a-capabilities').register('a-popover-base-handlers', function (A, util, factory, privateCapabilities) {
  var undefined,
    $ = A.$;

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */

  var LOCK_SYSTEM = 1;

  var START_ANCHOR_CLASSNAME = "a-popover-start";
  var END_ANCHOR_CLASSNAME   = "a-popover-end";

  /**
   *  When clicking anywhere in the DOM, we may need to close open popovers.  Search through
   *  the popover tree and close all popovers which didn't get clicked.
   *  Click for mice in Old-IE and Win 7 IE10/11, A.action.start for IE10/11 in Win 8 / devices
   */
  $(document).bind('click ' + A.action.start, function (event) {
    var $target = $(event.target);
    var oe = event.originalEvent;

    /*
     * Ignore click events that originate from a touch-based input, but not a mouse-based click. Sometimes (~1 in 20ish taps) event timing
     * results in mouseenter (tooltip opens), pointerdown, close check (pointerdown), mouseleave, close check (click, tooltip closes)
     * and not mouseenter (tooltip opens), pointerdown, close check (pointerdown), close check (click), mouseleave (tooltip stays open)
     */
    if (oe && oe.pointerType && oe.pointerType === A.pointerType.touch && oe.type === "click") {
      return;
    }

    /*
     * Lightbox/Modal scroller clicking logic will be handled at popover_light.js.  Do nothing here.
     * There's also a possibility that some android browsers will trigger a touchstart event on a mythical
     * <html> node whos pointer doesn't match document.documentElement during or shortly after scrolling.
     * If that happens, bail out quickly to prevent some seriously fubar behavior.
     */
    if ($target.hasClass("a-modal-scroller") || $target[0].id === "a-popover-lgtbox" || $target[0].nodeName.toLowerCase() === "html") {
      return;
    }

    // Function used to search the popover tree to see if the event occurred withing the confines of a popovper
    var condition = function (popover) {
      return util.eventOccursWithin(event, popover);
    };

    A.each(factory.getRoot().children, function (child) {
      if (child.isVisible() || child.isContentLoaded()) {
        var clickedChild = util.search(child, condition);
        if (clickedChild) {
          clickedChild.hideChildren();
        } else if (child.attrs("lightboxOptions") === null && !child.attrs("immersive")) {
          // If the popover is a lightbox-backed popover, it is not possible to click on any portion
          //   of the document to close the popover itself.  In the case of such happens, such as the ipad
          //   case in SC-1426, we check that first before closing a popover
          //
          // Same theory, if a popover is immersive (secondary view), dont close it as it might be needed later for the back operation
          child.unlock(LOCK_SYSTEM).hide();
        }
      }
    });
  });

  P.when('a-event-analytics').execute(function (ea) {
    ea.notifyJquery($(document), 'click ' + A.action.start);
  });

  /**
   *  Get the closest popover instance when a popover content Jquery object is passed in
   */

  function _getPopoverByDescendantElement ($target) {
    var id;

    // Search for the closest element with a popover id
    while ($target.length) {
      id = $target.data('a-popover-id');
      if (id) {
        break;
      }
      $target = $target.parent();
    }

    return factory.get(id);
  }

  /**
   *  Many popovers have a close button.  Keep that behavior in a centralized place.
   */
  // Adding touchstart as well in case people are getting non-touch asset in touch devices
  A.declarative('a-popover-close', ['click', A.action.end], function (event) {
    var popover = _getPopoverByDescendantElement(event.$target);

    if (popover) {
      // Explicit user action overrides this lock which only prevents accidental closing of a popover
      popover.unlock().hide();
      util.trigger('dismiss', popover);
    }
    event.$event.preventDefault();

  });

  var startFocusout = null;
  var startFocusin = null;
  var throttleMSecs = 100;

  /**
  * Trap the focus inside the popover
  *
  * We used to rely on keydown events to trap the focus inside the popover,
  * however this doesn't work on mobile devices, because they don't dispatch
  * keydown events. There is no way to listen to any touch event and anticipate
  * a focus change. So now, we are listening to the focusout event and check where the
  * next focus is going to land, if its going to land on "a-popover-start" outward,
  * we forcefully move the focus to the last tabbable element in the popover content.
  * If it lands on "a-popover-start" when popover opens, we do nothing.
  */
  A.declarative("a-popover-a11y", "focusout", function loopFocusToBegin(event) {
    var popover = _getPopoverByDescendantElement(event.$target);
    if (!popover || !event.$target.length || !popover.$firstTabbable.length) { return; }

    var isFirstTabbable = event.$target[0] === popover.$firstTabbable[0];
    if(!isFirstTabbable) { return; }

    // One focus out unexpectedly trigger two events
    if (startFocusout && (A.now() - startFocusout) < throttleMSecs) {
      return;
    }
    startFocusout = A.now();

    A.delay(function () {
      if ($(document.activeElement).hasClass(START_ANCHOR_CLASSNAME)) {
        popover.$lastTabbable.focus();
      }
    }, 0);
  });

  /**
  * Trap the focus inside the popover
  *
  * If the focus lands on "a-popover-end", we move the focus to the first tabbable
  * element. In this case, we don't check the tabbing/swiping direction since
  * there's only one possible direction: from last tabbable element to "a-popover-end".
  */
  A.declarative("a-popover-a11y", "focusin", function loopFocusToEnd(event) {
    var popover = _getPopoverByDescendantElement(event.$target);
    if (!popover || !event.$target.length) { return; }

    var isLastTabbable = event.$target.hasClass(END_ANCHOR_CLASSNAME);
    if (!isLastTabbable) { return; }

    // One focus in unexpectedly trigger two events
    if (startFocusin && (A.now() - startFocusin) < throttleMSecs) {
      return;
    }
    startFocusin = A.now();

    A.delay(function () {
      popover.$firstTabbable.focus();
    }, 0);
  });

    /**
  * Close the popover by pressing escape
  */
  A.declarative("a-popover-a11y", "keydown", function (event) {
    var e = event.$event;
    var keyCode = e.keyCode;
      //close the popover by pressing escape
      if (keyCode === A.constants.keycodes.ESCAPE) {
        var popover = _getPopoverByDescendantElement(event.$target);
        // Prevent the default escape key behavior, which cancels existing network request
        e.preventDefault();
        if(popover) {
          popover.hide();
        }
      }
  });

  /**
   *  Ensure all popovers are properly when the window's size changes.
   */

  A.on("resize zoom", function () {
    factory.getRoot().updatePosition();
  });

  // Implementing workaround for AUI-5568
  if (privateCapabilities.isSafari && A.capabilities.ios) {
    A.on("a:popover:refresh",function(data){
      var popover = data.popover;

      if (popover.$popover){
        popover.$popover.undelegate('input[type="date"]','blur')
          .delegate('input[type="date"]','blur',function(){
          var w = A.$(window);
          // Scroll the window down 1 px to force a page-redraw
          w.scrollTop(w.scrollTop()+1);
        });
      }
    });
  }

});
/////////////////////////
// END FILE js/base/popover_base_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Popover base class
 *
 */

'use strict';

P.when('A', 'a-popover-base-apis', 'a-popover-base-handlers').register('a-popover-base', function (A, apis, handlers) {

  // Returning deprecated popover APIs
  return apis;
});
/////////////////////////
// END FILE js/base/popover_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_objectclass.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Object class for popovers, needs to be created/constructed to work
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-data', 'a-popover-position', 'a-popover-lightbox', 'a-popover-animate', 'prv:a-capabilities')
  .register('a-popover-objectclass', function (A, util, data, position, lightbox, animation, privateCapabilities) {
  var undefined;
  var $ = A.$;
  var page = $('#a-page');

  /*****************************************
  PRIVATE CONSTANTS USED THROUGHOUT THE FILE
  ******************************************/

  /**
   *  The entire nav bar has its own z-index.  We need to be above that.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var NAV_ZINDEX = 299;

  /**
   *  The minimum z-index for dropdowns.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var DROPDOWN_ZINDEX = 599;

  /**
   *  Lock levels
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var LOCK_SYSTEM = 1,
    LOCK_USER = 10,
    LOCK_UNLOCK = -1;

  /**
   *  Status codes
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var STATUS_ACTIVE = 1,
    STATUS_VISIBLE = 2,
    STATUS_CONTENT_LOADING = 3,
    STATUS_CONTENT_LOADED = 4,
    STATUS_INACTIVE = -1,
    STATUS_UNLOADED = -2;

  /**
   *  The ID of the root popopver.  Constant used for self-documenting some code.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ROOT_POPOVER_ID = -1;

  /**
   *  The name of the data attribute which contains the popover's ID.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var POPOVER_ID_DATA_ATTR = "a-popover-id";

  /**
   *  The name of the custom position in popover_position
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var CUSTOM_POSITION_KEY = "customPosition";

  /**
   *  List of attribute names change that does not require skin refresh
   *  Make it an object to save inArray() iterations
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var NO_SKIN_REFRESH_NAMES = {
    "name": true,
    "url": true,
    "content": true,
    "width": true,
    "height": true,
    "max-width": true,
    "max-height": true,
    "min-width": true,
    "min-height": true
  };

  /**
   *  For mobile specific workarounds
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_MOBILE = A.capabilities.mobile;

  /**
   *  For touch specific workarounds
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_TOUCH = IS_MOBILE || A.capabilities.tablet;

  /**
   *  For IE specific workarounds
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_IE_MOBILE = IS_MOBILE && privateCapabilities.isIE10Plus;

 /**
  *  Whether the browser is IE < 9
  *
  *  @private
  *  @constant
  *  @type {boolean}
  */
 var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

 /**
  *  Selector to get all the tabbable elements
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var TABBABLE_SELECTOR = "a, button, input, select, textarea, [tabindex]:not([tabindex='-1'])"

 /**
  *  An event that should be triggered when the popover is actually visible to
  *  the customers after animation(if any)
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var POPOVER_VISIBLE_EVENT = "visible";

 /**
  *  An event that should be triggered when the popover is completely invisible to
  *  the customers after animation(if any)
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var POPOVER_INVISIBLE_EVENT = "invisible";

  /******************************************************************************
  PRIVATE HELPER FUNCTIONS USED INSIDE CONSTRUCTORS BUT NOT DEPENDENT ON INSTANCE
  ******************************************************************************/


  /**
   *  The default show animation for popovers.  Can be called from methods
   *  which override the showMethod method
   *
   *  @private
   *  @param {function} triggerVisibilityChange The function that triggers the visibility event
   */
  var _baseShowMethod = function (triggerVisibilityChange) {
    /*jshint validthis:true */
    var popover = this;

    // Manipulating a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
    popover.$popover.css({
      "visibility": "visible"
    }).removeClass("a-popover-hidden");

    // Focus on the popover when it is shown:
    // - only if the focusWhenShown option is set to true
    // - unless ajax is used to load content. Then, wait for the ajax response. See a-popover-ajax-strategy
    if (popover.attrs("focusWhenShown") && (popover.attrs("currentDataStrategy") !== "ajax")) {
      popover.focus();
    }

    // Need to trigger visibility events even for cases
    // when no animation is invloved, and the popover
    // becomes immediately visible.
    triggerVisibilityChange.call(popover);
  }

  /**
   *  The default hide animation for popovers.  Can be called from methods
   *  which override the hideMethod method
   *
   *  @private
   *  @param {function} triggerVisibilityChange The function that triggers the visibility event
   */

  var _baseHideMethod = function (triggerVisibilityChange) {
    /*jshint validthis:true */
    var popover = this;
    var triggerVisibilityChange = arguments[0];

    popover.$popover.hide().find(".a-lgtbox-vertical-scroll").removeClass("a-lgtbox-vertical-scroll");

    // Need to trigger visibility events even for cases
    // when no animation is invloved, and the popover
    // hides immediately
    triggerVisibilityChange.call(popover);
  }

  /**
   *  Get the html look-and-feel of the popover as string
   *
   *  @private
   *  @return {object}  jquery wrapped DOM of the content parent
   */
  var _skin = function () {
    var popover = this,
      typeSpecificFunctions = popover.typeSpecificFunctions;
    return typeSpecificFunctions.skin !== undefined ? typeSpecificFunctions.skin(popover) : "";
  };

  /*******************
  CONSTRUCTOR FUNCTION
  ********************/

  /**
   * Constructor used to create a new popover
   *
   * @constructor
   * @this {Carousel}
   *
   * @public
   * @param {object} attributes             Instance specific attributes used in configuring the look and behavior of the popover
   * @param {object} typeSpecificFunctions  Instance specific functions used to determine the behavior of the popover during show, hide, content loading, etc.
   *
   * @return {PopoverClass}
   */
  function PopoverClass(attributes, typeSpecificFunctions) {

    /**
     *  This is a soft lock which prevents hiding this popover.  It is ignored in several instances, mostly in
     *  the popover_base module.  However, it can be useful if you want to prevent this popover from hiding
     *  in instances where locking would not prevent parent popover behavior.
     *
     *  @private
     *  @type {integer}
     */

    var _lock_level = LOCK_UNLOCK;

    /**
     *  A list of attribute names that have changed upon the previous update() function
     *  Initialize with one element so that the first refresh() is guaranteed to load skin
     *
     *  @private
     *  @type {array}
     */

    var _attrs_changed = [1];

    /**
     *  An integer to indicate the status of the popover
     *
     *  @private
     *  @type {integer}
     */

    var _status = STATUS_UNLOADED;

    /**
     *  The popover which contains the trigger for this popover
     *
     *  @public
     *  @type {object}
     */

    this.parent = null;

    /**
     *  An array containing the popovers whos trigger is a child of this popover's DOM nodes
     *
     *  @public
     *  @type {array}
     */

    this.children = [];

    /**
     * An object for display-related functions, specific to the popover type, that
     * are injected upon popover instance initialization (dependency injection pattern).
     *
     * @public
     * @type {object}
     */
    this.typeSpecificFunctions = {};

    /**
     *  An object for injected attributes
     *
     *  @public
     *  @type {object}
     */

    this.attributes = {
      /**
       *  The positioning strategy used by this popover.  See the "a-popover-position" module for options.
       *
       *  @public
       *  @type {boolean}
       */
      position: 'triggerVertical',

      /**
       *  Should this popover be the only active popover in its scope
       *
       *  @public
       *  @type {boolean}
       */
      alone: false,

      /**
       *  We wanted to name this propery "modal" but since there's already a popover type called modal,
       *  we didn't do that.  Basically, if this popover takes over the user's focus and must be dealt with
       *  before the user can do anything else, this is set to true.
       *
       *  @public
       *  @type {boolean}
       */
      immersive: false,

      /**
       *  By default, popovers will attempt to restore focus to the previous active element when they are closed.
       *  This attribute, when set to false, will disable this behavior (e.g. tooltips)
       *
       *  @public
       *  @type {boolean}
       */
      restoreFocusOnHide: true
    };

    /**
     *  Trigger the popover visible/invisible event
     *  Called within showMethod/hideMethod whenever there is a change in visibility of the component
     *  Should be called after the animation(if any) concludes
     *
     *  @private
     *
     *  @return {object}  popover instance
     */

    var _triggerVisibilityChange = function() {
     var popover = this;
     if (popover.isActive()) {
       if (popover._willTriggerEvents) {
         util.trigger(POPOVER_VISIBLE_EVENT, popover);
      }
     }
     else {
       util.trigger(POPOVER_INVISIBLE_EVENT, popover);
     }
     return popover;
    };

    /**
     *  Refresh a popover.  If the forceContentRefresh parameter is true, the content will be refreshed no matter what.
     *
     *  @private
     *  @param {boolean} forceContentRefresh
     *  @param {boolean} forceSkinRefresh
     *
     *  @return {PopoverObject}
     */

    var _refreshPopover = function (forceContentRefresh, forceSkinRefresh) {
      var popover = this;
      var isActive = popover.isActive();
      var dataStrategy = popover.getDataStrategy();
      var isFirstRender = !popover.$popover;
      var isRefreshSkin = forceSkinRefresh || isFirstRender;
      var hasUnloadedContent = false;
      forceContentRefresh = forceContentRefresh || isRefreshSkin;

      // Check if skin refresh required
      if (!isRefreshSkin) {
        var i = _attrs_changed.length;
        while (i-- && !isRefreshSkin) {
          isRefreshSkin = !NO_SKIN_REFRESH_NAMES[_attrs_changed[i]];
        }
      }

      if (isRefreshSkin) {
        // Load skin
        var newContainer = _skin.apply(popover),
          $newContainer = $(newContainer);

        // Backup content and remove current popover DOM
        if (!isFirstRender) {
          dataStrategy.unloadContent(popover);
          popover.$container.remove();
          hasUnloadedContent = true;
        }

        // Update $container and $popover
        $('body').append($newContainer);
        popover.$container = $newContainer;
        popover.$popover = popover.$container.hasClass("a-popover") ? popover.$container : popover.$container.find(".a-popover");
        popover.$startAnchor = popover.$popover.hasClass("a-popover-start") ? popover.$popover : popover.$popover.find(".a-popover-start");
        popover.$endAnchor = popover.$popover.find(".a-popover-end");
        popover.$popover.attr('id', 'a-popover-' + popover.id).data(POPOVER_ID_DATA_ATTR, popover.id);

      }

      // Make sure a non-modal popover will show up on top of its parent
      if (!popover.attrs("immersive")) {
        var zIndex = parseInt(popover.parent.$popover.css("z-index"), 10);
        if (!A.isFiniteNumber(zIndex)) {
          zIndex = popover.parent.attrs("immersive") ? 1010 : 0;
        }
        // TODO: Experiment to remove IS_MOBILE
        if (popover.type === 'dropdown' && IS_MOBILE) {
           zIndex = Math.max(DROPDOWN_ZINDEX, zIndex);
        }
        zIndex = Math.max(NAV_ZINDEX, 100 + zIndex);
        popover.$popover.css("z-index", zIndex);
      }

      if (dataStrategy.shouldRefreshContent(popover) || forceContentRefresh) {
        // Load content
        if (!hasUnloadedContent) {
          dataStrategy.unloadContent(popover);
        }
        dataStrategy.loadContent(popover, isFirstRender);
      }

      // Update popover dimension
      if (popover.typeSpecificFunctions.updateDimensions !== undefined) {
        popover.typeSpecificFunctions.updateDimensions.apply(popover);
      }

      // Clear changed attributes (set isDirty()=false) before show() to prevent calling refresh() again
      _attrs_changed = [];

      // Show (update position) if it is displaying now
      if (isActive) {
        _displayPopover.call(popover, [], false);
      }

      // Get tabbable elements and set the first/last element as an attribute,
      // these attributes need to be accessed later for accesibility reasons.
      var tabbableContent = popover.$popover.find(".a-popover-inner").find(TABBABLE_SELECTOR);
      tabbableContent = tabbableContent.not('.a-dropdown-link'); // tabbing should be handled by parent ".a-dropdown-item"
      // Close button will be always there and focusable (for screen reader user) and should be the first tabbable element.
      popover.$firstTabbable = popover.$popover.find('[data-action="a-popover-close"]');
      // Fallback if there's really no close button (e.g. split dropdown or desktop dropdown)
      popover.$firstTabbable = popover.$firstTabbable.length ? popover.$firstTabbable : tabbableContent.first();
      popover.$lastTabbable = tabbableContent.length === 0 ?  popover.$firstTabbable : tabbableContent.last();

      return popover;
    };

    /**
     *  The main popover display logic.  Executing beforeShowMethod, showMethod and afterShowMethod
     *  in sequence to show a popover.
     *
     *  @private
     *  @param {array}  args arguments passed from the public API show() method to the three subsequent methods
     *  @param {boolean}  willTriggerEvents  a boolean to determine if events will be triggered.  Used for refresh() when triggers should not be fired.
     */
    var _displayPopover = function (args, willTriggerEvents) {
      var popover = this,
        willTriggerEvents = !! willTriggerEvents,
        typeSpecificFunctions = popover.typeSpecificFunctions,
        showMethod = typeSpecificFunctions.showMethod !== undefined ? typeSpecificFunctions.showMethod : _baseShowMethod,
        beforeShowMethod = typeSpecificFunctions.beforeShowMethod !== undefined ? typeSpecificFunctions.beforeShowMethod : null,
        afterShowMethod = typeSpecificFunctions.afterShowMethod !== undefined ? typeSpecificFunctions.afterShowMethod : null;

      // Set popover as active after we are certain we have popover.$popover after refresh()
      _status = STATUS_ACTIVE;

      // Used in the triggerVisibilityChange function, which is called within the instance specific showMethod
      // and does not have access to this boolean
      popover._willTriggerEvents = willTriggerEvents;

      // Record current focus to restore during hide operation
      popover.attrs('originalFocus', document.activeElement);

      // Set to visibility:hidden so that updatePosition() can be called before the show function
      // Added a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
      popover.$popover.css("visibility", "hidden").addClass("a-popover-hidden").show();

      if (beforeShowMethod) {
        // Accepting abitrary arguments from input
        beforeShowMethod.apply(popover, args);
      }

      // Real show method.
      // Add delay to ensure correct dimension calculations during updatePosition() unless the config options forbid it
      function realShow() {
        popover.updatePosition();
        var prevNavigate = popover.attrs("navigate");

        // This is a temporary solution to a bigger problem. If the content of a secondary view
        // gets updated during the "show" process, then the containing method gets called twice.
        // On the second pass-through, the willTriggerEvents arg will be false.  If willTriggerEvents
        // is false, we don't want to push stuff onto the navigation stack.  If we did, it would cause
        // two hashes to be pushed onto the stack.  Since clicking back only removes one, the same
        // secondary view would be shown a second time and two more hashes would be created.  Thus,
        // the popover could never be closed.
        if (!willTriggerEvents && prevNavigate) {
          popover.attrs("navigate", false);
        }
        // Accepting abitrary arguments from input
        showMethod.call(popover, _triggerVisibilityChange, args);

        if (willTriggerEvents) {
          util.trigger('show', popover);
        }

        if (afterShowMethod) {
          // Accepting abitrary arguments from input
          afterShowMethod.apply(popover, args);
        }

        if (willTriggerEvents) {
          util.trigger('afterShow', popover);
        }

        popover.$popover.attr("aria-hidden", "false");

        // page content should not conveyed to the user via the assistive technology.
        if ("tooltip" !== popover.type) {
          page.attr("aria-hidden", "true");
        }

        if (!willTriggerEvents && prevNavigate) {
          popover.attrs("navigate", prevNavigate);
        }

        // Indicate the state of popover as visible
        _status = STATUS_VISIBLE;
      }

      if (popover.attrs("synchronous")) {
        realShow();
      } else {
        A.delay(function () {
          realShow();
        }, 0);
      }
    };

    /**
     *  Take a given popover and return a function which wraps the popover's show
     *  function an allows for default functionality to be run whenever the popover's
     *  show function is executed.
     *
     *  @public
     */

    this.show = function () {
      var popover = this,
        lightboxOptions = popover.attrs("lightboxOptions") || null;

      if (popover.isActive() || animation.isAnimating(popover)) {
        return this;
      }

      // Lock popover to prevent hide when animation
      popover.lock(LOCK_SYSTEM);

      // If this popover needs lightbox, lock lightbox so that it will not be hidden
      if (lightboxOptions) {
        lightbox.lock(LOCK_SYSTEM);
      }
      popover.parent.$container &&
        popover.parent.$container.is(".a-popover") &&
        popover.parent.$container.attr("aria-hidden", "true");

      // Hide all sibling popovers if this popover wants to be the only open popover in this context
      if (popover.attrs("alone")) {
        A.each(popover.parent.children, function (sibling) {
          // Skip if sibling is a modeless model
          if (sibling.isActive() && sibling.id !== popover.id && !sibling.attrs("modeless")) {
            sibling.unlock().hide();
          }
        });
      }

      // Trigger beforeShow before refresh() to include content changes
      util.trigger('beforeShow', popover);

      // Load content by repainting popover if data is not loaded yet or the data strategy requires a refresh
      if (!popover.$container || popover.isDirty() || popover.getDataStrategy().shouldRefreshContent(popover)) {
        // Added this trigger for AUI-5568
        util.trigger('refresh',popover);
        _refreshPopover.call(popover);
      }

      if (popover.draggable) {
        var $container = popover.$container;
        A.draggable($container, {
          handle: $container.find('.a-popover-draggable-handle')
        });
      }

      // Show lightbox if the popover requires it
      if (lightboxOptions) {
        lightbox.show(A.extend({
          popover: popover
        }, lightboxOptions));
      }

      // Real show method
      _displayPopover.call(popover, arguments, true);

      // Add delay to locking popover and lightbox
      A.delay(function () {
        popover.unlock(LOCK_SYSTEM);
        if (lightboxOptions) {
          lightbox.unlock(LOCK_SYSTEM);
        }
      }, 0);
      return this;
    }

    /**
     *  Take a given popover and return a function which wraps the popover's hide
     *  function an allows for default functionality to be run whenever the popover's
     *  hide function is executed.
     *
     *  @public
     */
    this.hide = function () {
      var popover = this,
        typeSpecificFunctions = popover.typeSpecificFunctions,
        hideMethod = typeSpecificFunctions.hideMethod !== undefined ? typeSpecificFunctions.hideMethod : _baseHideMethod,
        beforeHideMethod = typeSpecificFunctions.beforeHideMethod !== undefined ? typeSpecificFunctions.beforeHideMethod : null,
        afterHideMethod = typeSpecificFunctions.afterHideMethod !== undefined ? typeSpecificFunctions.afterHideMethod : null,
        lightboxOptions = popover.attrs("lightboxOptions") || null;

      if (!popover.isActive() || popover.isLocked() || animation.isAnimating(popover)) {
        return this;
      }

      // Set popover as inactive
      _status = STATUS_INACTIVE;

      // Hide its children first
      popover.hideChildren();

      util.trigger('beforeHide', popover);
      if (beforeHideMethod) {
        // Accepting abitrary arguments from input
        beforeHideMethod.apply(popover, arguments);
      }

      // Real hide method
      // Accepting abitrary arguments from input
      hideMethod.call(popover, _triggerVisibilityChange, arguments);
      util.trigger('hide', popover);

      A.delay(function () {
        if (afterHideMethod) {
          // Accepting abitrary arguments from input
          afterHideMethod.apply(popover, arguments);
        }

        popover.$popover.attr("aria-hidden", "true");
        if ("tooltip" !== popover.type) {
          page.attr("aria-hidden", "false");
        }
        popover.parent.$container
          && popover.parent.$container.is(".a-popover")
          && popover.parent.$container.attr("aria-hidden","false");

        // Hide lightbox if the popover requires it
        if (lightboxOptions) {
          // Unless the parent also requires lightbox, hide lightbox
          if (popover.parent.attrs("lightboxOptions")) {
            lightbox.show(A.extend({
              popover: popover.parent
            }, lightboxOptions));
          } else {
            lightbox.hide(lightboxOptions);
          }
        }

        // Currently, the screen (e.g. lightbox for modal or "white" for secondary view)
        // has different animation times. And they don't have a shared event
        // while the animation is done. We need to make sure the screen is gone
        // then focus on the target. A large delay is set to cover
        // the worst case of modal (250ms) and secondary view (350ms).
        var DELAY_MILLI_SECONDS_FOR_FOCUS_CHANGING = 400;

        util.trigger('afterHide', popover);

        // Indicate the state of popover as unloaded
        _status = STATUS_UNLOADED;

        // 1. Fix focused target when popover dismisses.
        // Restore the focus to popover's trigger if it has one. If it doesn't, jump to the previously focused element.
        // Don't do this with tooltips because that prevents navigating out of the element with the tooltip (AUI-4451)
        // 2. Fix focusability of target.
        // [AUI-8786] Currently, best practice of using "popover trigger" is
        // wrapping it with declarative action rather than directly put action data
        // on it. See https://aui.amazon.com/development/interactive_components/popover/popover
        // However, the trigger will be the declarative layer (<span>)
        // rather than the "popover trigger" (<a>). And span can't get complete focus state.
        /* Importing js/base/_restoreFocusOnHide.js */
function restoreFocusOnHide () {
  var $nextFocus = null;

  if (popover.type === 'dropdown') {
    $nextFocus = popover.$trigger;
  } else {
    var focusCandidates = 'a, input, button';
    if (popover.$trigger && $(popover.$trigger).length) {
      $nextFocus = popover.$trigger.is(focusCandidates) ?
                    popover.$trigger :
                    popover.$trigger.find(focusCandidates);
    }
  }

  if (!$nextFocus || !$nextFocus.length) {
    $nextFocus = $(popover.attrs('originalFocus'));
  }

  if ($nextFocus.length && (!IS_LT_IE9 || $nextFocus.is(":visible"))) {
    A.delay(function() {
      // Focus back to trigger if trigger is visible on viewport.
      // However, this is not true for secondary view.
      // Secondary view first hides page and show back on closure which scrolls page to top and
      // trigger is never visible on viewport
      if ((popover.type === 'secondary-view' || A.onScreen($nextFocus, 0))) {
        $nextFocus.focus();
      }
    }, DELAY_MILLI_SECONDS_FOR_FOCUS_CHANGING);
  }
}
/* Done importing js/base/_restoreFocusOnHide.js */

        if (popover.attrs('restoreFocusOnHide')) {
          restoreFocusOnHide();
        }
      }, 0);

      return this;
    };

    /**
     *  Popover API, updating popover
     *  This function will only update attributes that are in the OVERRIDE_ATTRS whitelist
     *
     *  @public
     *
     *  @param {object} attributes  a key/value of attributes to change
     *                              also accepting a string for backward compatibility
     *  @return {object}  popover instance
     */

    this.update = function (inAttrs) {
      var popover = this;
      var attributes = typeof inAttrs === "string" ? {
        content: inAttrs
      } : A.copy(inAttrs); // For backward compatibility
      var oldAttrs = this.attrs();
      var oldStrategy = popover.getDataStrategy();

      // Compare old and new set of attributes and find the diff
      A.each(attributes, function (val, key) {
        if ((val && !oldAttrs[key]) || (oldAttrs[key] && oldAttrs[key] !== val)) {
          _attrs_changed.push(key); // we should not care too much about dups here
        }
      });

      if (popover.isDirty()) {
        // Save updated attributes
        var newAttrs = A.extend({}, oldAttrs, attributes);
        popover.attrs(newAttrs);

        // Determine new data strategy
        var newStrategy = popover.getDataStrategy(newAttrs);

        // Backup if popover has been initialized
        if (popover.$popover) {
          oldStrategy.unloadContent(popover);
        }

        if (popover.isActive()) {
          _refreshPopover.call(popover, true);
          popover.focus();
        }
      }
      return popover;
    };

    /**
     *  Load/Reload skin and html content
     *
     *  @public
     *  @param {boolean} isRefreshSkin  force refresh skin
     *  @param {boolean} isRefreshSkin  force refresh skin
     *
     *  @return {object}  popover instance
     */
    this.refresh = function (forceContentRefresh, forceSkinRefresh) {
      return _refreshPopover.call(this, forceContentRefresh || true, forceSkinRefresh || false);
    };

    /**
     *  Determine whether the current popover is activated
     *  meaning a show() is triggered, but perhaps not shown onto viewport yet
     *
     *  @public
     *  @return {boolean}
     */
    this.isActive = function () {
      return _status >= STATUS_ACTIVE;
    };

    /**
     *  Determine whether the popover is visible/shown on the page
     *
     *  @public
     *  @return {boolean}
     */
    this.isVisible = function () {
      return _status === STATUS_VISIBLE;
    };

    /**
     * Determine whether the content is current loading (waiting on ajax)
     * - used for the ajax data strategy
     * - should be true while waiting on an ajax request
     *
     * @public
     * @return {boolean}
     */
    this.isContentLoading = function () {
      return _status === STATUS_CONTENT_LOADING;
    };

    this.setContentLoading = function () {
      _status = STATUS_CONTENT_LOADING;
    };

    /**
     * Determine whether the content has been loaded into the popover
     * - used for ajax data strategy
     *
     * @public
     * @return {boolean}
     */
    this.isContentLoaded = function () {
      return _status === STATUS_CONTENT_LOADED;
    };

    this.setContentLoaded = function () {
      _status = STATUS_CONTENT_LOADED;
    };

    /**
     *  Determine whether a force refresh is necessary
     *
     *  @public
     *  @return {boolean}
     */

    this.isDirty = function () {
      return _attrs_changed.length > 0;
    };

    /**
     *  Set current lock level, higher the more powerful
     *
     *  @public
     *  @param {integer} lockLevel
     *
     *  @return {object}  popover instance
     */

    this.lock = function (lockLevel) {
      // Assume a user lock if lock level is not set
      if (!lockLevel) {
        lockLevel = LOCK_USER;
      }
      if (_lock_level < lockLevel) {
        _lock_level = lockLevel;
      }
      return this;
    };

    /**
     *  Remove lock if lockLevel is high enough
     *
     *  @public
     *  @param {integer} lockLevel
     *
     *  @return {object}  popover instance
     */

    this.unlock = function (lockLevel) {
      //assume a user lock if lock level is not set
      if (!lockLevel) {
        lockLevel = LOCK_USER;
      }
      if (_lock_level <= lockLevel) {
        _lock_level = LOCK_UNLOCK;
      }
      return this;
    };

    /**
     *  Check lock status
     *
     *  @public
     *
     *  @return {boolean}  lock or unlock
     */

    this.isLocked = function () {
      return _lock_level !== LOCK_UNLOCK;
    };

    // Constructor starts here
    this.typeSpecificFunctions = typeSpecificFunctions;
    this.attrs(attributes);


    //TODO right now we do not have a good idea on what each dependencies passes to popover in and how they use it,
    //     eventually we will only allow dependencies to mess around with using popover.attrs(),
    //     need to remove this when we have better control of our attributes
    //by 8/15/2013, list of items need to be switched:
    //      id
    //      $trigger
    //      $triggerWrapper
    //      data
    //      header
    //      content
    //      position
    //      sourceSelect
    //      sourceButton
    //      name
    //      preventNameReuse
    //      type
    //      footer
    //      width
    //      height
    //      url
    //      ajaxFailMsg
    //      cache
    //      disableAnimation
    //      animationLength
    //      hideHeader
    //      padding
    //      scrollable
    //      data
    A.extend(this, this.attributes);
  }


  /*******************************************************************************
  POPOVER CLASS PROTOTYPE (FUNCTIONS WHICH DON'T NEED ACCESS TO PRIVATE VARIABLES)
  *******************************************************************************/


  // Alias the prototype for better file compression
  var prototype = PopoverClass.prototype;

  /**
   *  Get data strategy used in this popover
   *
   *  @public
   *  @param {object} attrs  hash of popover instance attributes, if empty, return the existing dataStrategy
   *
   *  @return {object}  popover data strategy object
   */
  prototype.getDataStrategy = function (attrs) {
    var popover = this,
      typeSpecificFunctions = popover.typeSpecificFunctions,
      newDataStrategy;

    // If getting dataStrategy without having one, determine data strategy from existing attributes
    if (!attrs && !popover.attrs("currentDataStrategy")) {
      attrs = popover.attrs();
    }

    if (attrs) {
      newDataStrategy = attrs.dataStrategy ? data.getStrategyByName(attrs.dataStrategy) : data.guessStrategyByAttrs(attrs);
      if (newDataStrategy) {
        typeSpecificFunctions.dataStrategy = newDataStrategy;
        popover.attrs("currentDataStrategy", newDataStrategy.name);
      }
    }
    return typeSpecificFunctions.dataStrategy;
  };

  /**
   *  Obtain content DOM node of the popover
   *  Used by popover_data
   *
   *  @return {object}  jquery wrapped DOM of the content parent
   */
  prototype.getContent = function () {
    return this.typeSpecificFunctions.getContent !== undefined ? this.typeSpecificFunctions.getContent.apply(this, arguments) : null;
  };

  /**
   *  Update content of the popover
   *  Used by popover_data
   *
   *  @public
   *  @param {string|object} content  html DOM or content, please handle both cases
   */
  prototype.updateContent = function (content) {
    if (this.typeSpecificFunctions.updateContent !== undefined) {
      this.typeSpecificFunctions.updateContent.apply(this, arguments);
    }

    return this;
  };

  prototype.setAriaBusy = function(busy) {
    if (this.typeSpecificFunctions.setAriaBusy !== undefined) {
      this.typeSpecificFunctions.setAriaBusy.apply(this, arguments);
    }
    return this;
  };

  /**
   *  @deprecated
   *  An adapter to update the url of a popover
   *
   *  @public
   *
   *  @param {string} url  new url to load
   *  @return {object}  popover instance
   */

  prototype.ajax = function (url) {
    return this.update({
      url: url
    });
  };

  /**
   *  Recursively update position for children of the popover
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.updateChildrenPosition = function () {
    A.each(this.children, function (child) {
      if (child.isActive()) {
        child.updatePosition();
      }
    });
    return this;
  };

  /**
   *  Measure the popover and trigger and set the position of the popopver
   *  based on which strategy is set (position attribute)
   *
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.updatePosition = function () {
    var popover = this;
    // The root popover should never be visible, so doing these calculations is pointless
    if (popover.id === ROOT_POPOVER_ID) {
      A.each(popover.children, function (child) {
        if (child.isActive()) {
          child.updatePosition();
        }
      });
    } else {
      if (this.typeSpecificFunctions.updatePosition !== undefined) {
        this.typeSpecificFunctions.updatePosition.apply(this, arguments);
        return popover;
      }

      var $popover = popover.$popover;

      // Unfortunately, in some cases, Metro IE will drop focus on an element if visibility: hidden is used...
      // This can cause the keyboard to pop up and go back down and make it impossible to enter text in a modal
      // At least that's the hunch as switching from visibility to opacity seems to have resolved it as far as
      // I was able to test.
      if (privateCapabilities.isMetroIEGuess && privateCapabilities.isIETouchCapable) {
        $popover.css('opacity', 0.01);
      } else {
        $popover.css("visibility", "hidden");
      }

      var _runUpdate = function () {
        var $inner = $popover.find(".a-popover-inner").css({
          "height": "auto",
          "overflow-y": "auto"
        });
        var posKey = popover.attrs("position");
        var offset = {};
        var positioningObj;

        if (popover.typeSpecificFunctions.positionStrategy) {
          offset = position[CUSTOM_POSITION_KEY](popover, popover.typeSpecificFunctions.positionStrategy);
        } else {
          offset = position[posKey](popover);
        }

        util.trigger('beforeUpdatePosition', popover);

        positioningObj = {
          top: offset.top + "px",
          left: offset.left + "px"
        }

        if (privateCapabilities.isMetroIEGuess && privateCapabilities.isIETouchCapable) {
          positioningObj.opacity = 1;
        } else {
          positioningObj.visibility = "visible";
        }

        $popover.css(positioningObj);

        // Focus on popover, if:
        // - This is not the first update (the first update is always called from the show method which will call focus)
        // - The current focus is out of popover
        // - Prevent losing focus on form elements inside popover upon resizing
        // - Only call focus when we need to update for other reasons (resizing)
        // - only if the focusWhenShown option is set to true
        // - when content has been loaded (wait for the ajax response)
        if (popover.isContentLoaded() && $(document.activeElement).closest(popover.$popover).length === 0 && popover.attrs("focusWhenShown") === true) {
          popover.focus();
        }

        if ($inner.length && (!$inner[0].style.height || $inner[0].style.height === "auto")) {
          // outerHeight() measures height + padding + border
          var popoverHeight = $popover.outerHeight() || 0;
          // outerHeight(true) measures height + padding + border + margin.
          // Only one of .a-popover-header or .a-modal-close-nohead-top will match.
          var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
          var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;
          // inner height must not have margin, otherwise height update below is incorrect.
          var innerHeight = $inner.outerHeight() || 0;
          var maxInnerHeight = popoverHeight - headerHeight - footerHeight;
          if (innerHeight > maxInnerHeight) {
            $inner.css({
              height: maxInnerHeight + "px",
              "overflow-y": "scroll"
            });
          }
        }

        util.trigger('afterUpdatePosition', popover);
        util.trigger('positionUpdated', popover); //for backward compatibility

        A.each(popover.children, function (child) {
          if (child.isActive()) {
            child.updatePosition();
          }
        });
      };

      // Reset the offset to ensure that the position is calculated correctly
      if (popover.attrs("immersive") && IS_TOUCH) {
        $popover.css({
          top: 0,
          left: 0
        });
        A.delay(function () {
          _runUpdate();
        }, 0);
      } else {
        _runUpdate();
      }
    }

    return popover;
  };

  /**
   *  Get attributes from attrs hash
   *
   *  @public
   *  @param {array|string|null} keys  list of attributes to fetch
   *  @param {object} value  value to set for SET case
   *
   *  @return {string|integer|object|null} for GET
   *  @return {object}  this for SET
   */
  prototype.attrs = function (keys, value) {
    var popover = this;

    if (value === undefined && typeof keys !== 'object') {
      //GET
      if (!keys) {
        return this.attributes;
      } else if (typeof keys === "string") {
        return this.attributes[keys] !== undefined ? this.attributes[keys] : null;
      } else {
        return null;
      }
    } else {
      //SET
      if (typeof keys === 'object') {
        A.each(keys, function (val, key) {
          popover.attrs(key, val);
        });
      } else if (typeof keys === "string") {
        this.attributes[keys] = value;

        //TODO right now we do not have a good idea on what each dependencies passes to popover in and how they use it,
        //     eventually we will only allow dependencies to mess around with using popover.attrs(),
        //     need to remove this when we have better control of our attributes
        popover[keys] = value;
      }
      return this;
    }
  };

  /**
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.hideChildren = function () {
    A.each(this.children, function (child) {
      child.unlock(LOCK_SYSTEM); // If the parent popover is being hidden, locks on children don't matter.
      child.hide();
    });
    return this;
  };


  prototype.focus = function() {
    var popover = this;
    var $window = $(window);
    var scrollTop = $window.scrollTop();
    var offsetTop = popover.$popover.offset().top;

    // In Windows mobile 8.0/8.1, when we focus on a DOM that is above current viewport, the viewport
    // scrolls(windows mobile 8.0) or jumps(windows mobile 8.1) to 0 no matter where the DOM offset is.
    // To workaround this, we scroll viewport to show the to be focused DOM before we set the focus.
    if (IS_IE_MOBILE && scrollTop > offsetTop) {
      $window.scrollTop(offsetTop);
    }
    A.delay(function(){
      popover.$firstTabbable.focus();
    }, 0);

    return this;
  }

  return {
    PopoverClass: PopoverClass
  };
});
/////////////////////////
// END FILE js/base/popover_objectclass.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/changeover/changeover.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Changeover code for AUI Popover

'use strict';

P.when('jQuery', 'prv:a-tnr', 'ready').register('a-changeover', function ($, tnr) {
  $(document).delegate('.a-changeover:not(.a-changeover-manual)', 'webkitAnimationEnd animationend click touchstart', function (event) {
    tnr.ackDelegated(event);
    this.style.display = "none";
  });
});
/////////////////////////
// END FILE js/changeover/changeover.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_positions.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown positions - standard file for desktop/non-touch devices
 *
 */

'use strict';

P.when('A').register('a-dropdown-base-positions', function (A) {
  var undefined,
    $ = A.$;

  function nativeDropdownDefineTop($popover, position, coords, triggerTopSpace, triggerBottomSpace) {
    var $inner = $popover.find(".a-popover-inner"),
      totalSpace;

    if (triggerTopSpace > triggerBottomSpace && triggerBottomSpace < coords.popoverHeight) {
      totalSpace = triggerTopSpace;
      position.top = triggerTopSpace < coords.popoverHeight ? coords.triggerBottom - triggerTopSpace : coords.triggerBottom - coords.popoverHeight;
    } else {
      totalSpace = triggerBottomSpace;
      position.top = coords.triggerTop;
    }

    //css changes
    $inner.css('height', totalSpace < coords.popoverHeight ? totalSpace - coords.headerHeight + "px" : "auto");
    if (coords.popoverHeight > totalSpace) {
      $inner.addClass("a-lgtbox-vertical-scroll");
    } else {
      $inner.removeClass("a-lgtbox-vertical-scroll");
    }
    return position;
  }

  return {
    /**
     *  Determine top/left of the split dropdown,
     *  and some css changes that I think should be moved somewhere
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    // TODO [AUIQA-1172] is fixed for mobile only due to the initial root cause
    // is limited in mobile. However, if the limitation changes in the future
    // (i.e. launching SKY in desktop), we need to apply the fix to desktop, too.
    positionStrategy: function (options) {
      var $popover = options.$popover,
        $trigger = options.$trigger,
        measure = options.measure,
        $inner = $popover.find(".a-popover-inner");

      //css reset for inner before measure() is done
      $inner.css({
        "min-width": "0px",
        "width": "auto",
        "height": "auto"
      });

      var $triggerBtn = $trigger.nextAll('.a-button-dropdown');

      if (!$triggerBtn.length){
        $triggerBtn = $trigger.closest(".a-button-group");
      }

      var coords = measure($popover, $triggerBtn);
      var popoverRightSpace = coords.windowWidth - (coords.triggerLeft + coords.popoverWidth);
      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;
      var triggerRightSpace = coords.windowWidth - coords.triggerLeft - coords.triggerWidth;
      var triggerLeftSpace = coords.triggerLeft;
      var position = nativeDropdownDefineTop($popover, {}, coords, triggerTopSpace, triggerBottomSpace);

      // If left unchecked, the vertical scroll bar in Windows desktop browsers can eat into the
      // width of its container and end up covering up text in the "options" or making the
      // padding look wrong. We also need to be sure to set the width before the position
      // to ensure accurate positioning in a right aligned trigger use case.
      //
      // Switched from checking overflow-y scroll as that is getting overridden elsewhere
      // in the Popover code to "auto" and it was getting set to scroll as a result of
      // this class, so checking for this class, instead, accomplishes the same end.
      if ($inner.hasClass("a-lgtbox-vertical-scroll") && navigator.appVersion.indexOf("Windows") > -1) {
        var width = Math.max(coords.popoverWidth, coords.triggerWidth) + A.scrollBarWidth(true);
        $inner.width(width);
      } else {
        $inner.css("min-width", coords.triggerWidth + "px");
      }
      coords.popoverWidth = $popover.width();

      if (popoverRightSpace < 50 && triggerLeftSpace > triggerRightSpace) {
        position.left = coords.triggerRight - coords.popoverWidth;
      } else {
        position.left = coords.triggerLeft;
      }

      return position;
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_positions.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/base/dropdown_base_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Common methods for Dropdowns
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-positions').register('a-dropdown-base-view-base', function (A, positions) {
  var undefined,
    $ = A.$;

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1;

  return A.extend(positions, {
    /**
     *  method to update dropdown popover content
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-inner').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-inner').html("").append(content);
      }
    },

    /**
     *  Operations before standard show function completes
     *
     *  @public
     */
    beforeShowMethod: function () {
      this.parent.lock(LOCK_SYSTEM);

      // NOTE: we are not using aria-owns here b/c it causes
      // JAWS to read off all the contents of the list of options
      // as one giant string when closing the dropdown and focusing
      // on the dropdown button. This bug appeared in JAWS
      // 16.0.2339
      this.$trigger.attr("aria-pressed", true);
    },

    /**
     *  Operations after standard show function completes
     *
     *  @public
     */

    afterShowMethod: function () {
      var $popover = this.$popover,
        $selected = $popover.find(".a-active");

      // Ensure the selected or first item has focus for accessibility
      A.delay(function () {
        if ($selected.length) {
          $selected.closest("li").focus();
        } else {
          $selected = $popover.find("li").first().focus();
        }
      }, 0);
    },

    /**
     *  Operations before standard hide function completes
     *
     *  @public
     */

    beforeHideMethod: function () {
      // Allow the parent to close itself
      this.parent.unlock(LOCK_SYSTEM);
    },

    /**
     *  Operations after standard hide function completes
     *
     *  @public
     */

    afterHideMethod: function () {
      this.$trigger.attr("aria-pressed", false);
      var $popover = this.$popover;

      $popover.css("width", "auto");
    }
  });
});
/////////////////////////
// END FILE js/dropdowns/base/base/dropdown_base_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown base view
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-view-base').register('a-dropdown-base-view', function (A, viewBase) {
    return viewBase;
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base class for dropdown, providing pointers to show popovers and manipulate select tags
 */
"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */

P.when("A", "a-popover-base-factory", "a-dropdown-base-view").register("a-dropdown-base-factory", function (A, baseFactory, view) {
  var $ = A.$;
  var POPOVER_TYPE = "dropdown";
  var firstAfterGroup = false;
  var idCount = 1;

  /**
   *  The CSS class of the container of any dropdown list
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var INNER_CLASS = "a-popover-inner";

  /**
   *  Given a jQuery wrapped <option> tag, generate the corresponding <li>
   *  from the data attributes present
   *
   *  @private
   *  @param {DOM node} $option  jQuery wrapped <option> to process
   *  @param {boolean} preselected  Is this option supposed to be selected by default
   *
   *  @return {string}  The HTML for the <li>
   */

  function _makeRichOption($option, preselected, labelId) {
    var li = ['<li tabindex="0" role="option"'];
    var optionClass = $option.data('aCssClass');
    var optionId = $option.data('aId');
    var htmlContent = $option.data('aHtmlContent');
    var imageSource = $option.data('aImageSource');

    // The value should be set in the data attribute as an object to prevent the data API from type coercing a zero padded number to an integer, which messes everything up.
    // Since we're using string buffers, we also have to watch out for double quotes in the data-value string and the existing value, so go ahead and play with that as well
    // AUI-8874 we need to properly escape both json and HTML.
    var anchorDataValue = JSON.stringify({ 'stringVal': $option.val() });
    var anchor = ['<a tabindex="-1" href="javascript:void(0)" aria-hidden="true" data-value="', A.escapeHtml(anchorDataValue), '"'];
    var anchorClasses = ["a-dropdown-link"];
    var liClasses = ["a-dropdown-item"];
    var content;

    if (preselected) {
      anchorClasses.push("a-active");
      li.push(' aria-checked="true"');
    }

    if (firstAfterGroup && (A.capabilities.mobile || A.capabilities.tablet)) {
      anchorClasses.push("a-list-link-after-group");
    }
    firstAfterGroup = false;

    if (optionClass) {
      liClasses.push(optionClass);
    }

    if (optionId) {
      li.push(' id="' + optionId + '"');
    }

    li.push('aria-labelledby="');
    li.push(labelId);
    li.push('"');

    anchor.push(' id="');
    anchor.push(labelId);
    anchor.push('"');

    li.push(' class="' + liClasses.join(" ") + '"');
    li.push('>');

    if (htmlContent) {
      content = htmlContent;
    } else {
      content = [];
      if (imageSource) {
        anchorClasses.push("a-option-has-image");
        content.push('<img src="' + imageSource + '" class="a-rich-option-image" />');
      }
      content.push($option.html());
      content = content.join('');
    }
    anchor.push(' class="');
    anchor.push(anchorClasses.join(' '));
    anchor.push('">');
    anchor.push(content);
    anchor.push('</a>');

    li.push(anchor.join(''));
    li.push('</li>');
    return li.join('');
  }

  /**
   *  Generate the HTML for the actual list which serves as the dropdown for a corresponding <select> tag.
   *
   *  @private
   *  @param {DOM Node} The jQuery wrapped <select> node
   *
   *  @return {string}  The HTML for the popover list
   */

  function _subskin($select) {
    if (!$select.jquery) {
      $select = $($select);
    }
    var $children = $select.children('optgroup,option:not(.a-prompt)');
    var trailingDivider = false;
    var select = $select[0];
    var selectId = $select.attr('id') ? $select.attr('id') : "dropdown" + idCount++;

    var selectValue;
    var buffer;

    if (select.selectedIndex > -1) {
      selectValue = select.options[select.selectedIndex].value;
    }
    // Use role="listbox" to identify an element that creates a list
    // it switches screen reader interaction mode from browse to form.
    // With NVDA/JAWS, ESCAPE key need to press twice to close dropdown list item.
    // First press will switch mode and second will trigger keydown event to close
    buffer = ['<ul tabindex="-1" class="a-nostyle a-list-link',
      $select.data('a-has-images') ? ' a-box-list' : '',
      '" role="listbox" aria-multiselectable="false">'
    ];

    var count = 0;
    $children.each(function () {
      var $child = $(this);
      if ($child.is('optgroup')) {
        $child.children().each(function (idx) {
          buffer.push(_makeRichOption($(this), selectValue === this.value, selectId + '_' + count++));
        });
        buffer.push('<li tabindex="-1" class="divider"><hr /></li>');
        firstAfterGroup = true;
        trailingDivider = true;
      } else {
        // Child is <option>
        buffer.push(_makeRichOption($child, selectValue === this.value, selectId + '_' + count++));
        trailingDivider = false;
      }
    });

    if (trailingDivider) {
      buffer.pop();
    }

    buffer.push('</ul>');
    return buffer.join('');
  }

  /**
   * Base Dropdown popover creation, allowing overriding from child dropdowns
   *
   * @public
   * @param {object} $trigger   jQuery wrapped DOM of the trigger
   * @param {object} options    A dropdown-specific options object for the dropdown
   * @param {object} childView  Display-related functions that are specific to the popover type
   *
   * @return {object} popover
   */
  function create($trigger, options, childView) {
    var $button = options.$button,
      $sourceSelect = options.$sourceSelect,
      sourceSelect = $sourceSelect[0],
      $dropdownLabel = $button.find(".a-dropdown-label");

    var skin = function (popover) {
        var content = childView.subskin ? childView.subskin(sourceSelect) : _subskin(sourceSelect);
        popover.attrs("inlineContent", content);
        return childView.skin(popover);
    };

    var header = $sourceSelect.data("aTouchHeader");
    if (!header || (!header.length && $dropdownLabel.length)) {
      header = $dropdownLabel.text();
    }

    var attributes = {
      type: POPOVER_TYPE,
      header: header,
      closeButtonLabel: options.closeButtonLabel ? options.closeButtonLabel : "Close",
      inlineContent: $sourceSelect,
      position: options.position,
      alone: true,
      sourceSelect: $sourceSelect,
      sourceButton: $button,
      name: $sourceSelect[0].name,
      preventNameReuse: true,
      lightboxOptions: A.capabilities.mobile || A.capabilities.tablet ? {
        showDuration: A.capabilities.ios ? null : 0,
        hideDuration: 0
      } : null
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: A.extend({}, view, childView, {
        skin: skin
      }),
      actionCheck: false
    });
  }

  //extending methods from popover baseFactory
  return A.extend({
    create: baseFactory.create,
    remove: baseFactory.remove,
    get: baseFactory.get
  }, {
    type: POPOVER_TYPE,
    create: create
  });
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Events and delegations for all types of Dropdowns
 *
 * Nothing to do for desktop.
 */
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/keyboard_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Events and delegations for all types of Dropdowns
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-factory').register('a-dropdown-keyboard-handlers', function (A, factory) {
  var $ = A.$;
  var KEYS = A.constants.keycodes;

  // Number of milliseconds before a dropdown will "forget" what the user was typing,
  // for the purpose of keyboard navigation.
  var KEYBOARD_NAVIGATION_TIMEOUT = 1000;

  // Data attributes //
  // Index of the last prefix match, or -1 if no possible match
  var USER_NAVIGATED_IDX = "a-user-navigated-idx",
    // What the user has entered so far, for keyboard navigation
    USER_NAVIGATED_TEXT = "a-user-navigated-text",
    // The debounced method for resetting the idx and text fields
    USER_NAVIGATED_DEBOUNCER = "a-user-navigated-debouncer";

  /**
   * Reset all state related to keyboard navigation to its default state.
   *
   * @param {object} $el  The jQuery object representing the node to reset.
   */
  function _clearNavigationState($el) {
    $el
      .removeData(USER_NAVIGATED_TEXT)
      .removeData(USER_NAVIGATED_IDX);
  }

  /**
   * Get the highlighted (focused or checked) option in the list (dropdown)
   *
   * @private
   *
   * @param {jQueryElement} list The dropdown list.
   */
  function _getHighlighted($list) {
    // if an option has focus, start there
    var $highlighted = $list.find(':focus');

    // otherwise start with the checked option
    if($highlighted.length < 1) {
      $highlighted = $list.find('[aria-checked="true"]');
    }

    return $highlighted;
  }

  /**
   * Change the focused element
   *
   * @param {jQueryElement} $from the previously focused element
   * @param {jQueryElement} $to the element to be focused
   */
  function _changeFocus($from, $to) {
    // TODO don't just focus, for mobile need to set appropriate "active" classes
    $from.removeAttr('aria-selected');

    // don't select dividers, only real options
    if($to.attr('role') === 'option') {
      $to.attr('aria-selected', 'true');
    }

    $to.focus();
  }

  function _getCurrent($current) {
    var $list = $current.parent('ul');

    // select the <ul> element (so we can boundary check)
    var $options = $list.find('li');

    // get the index of the selected element
    var $highlighted = _getHighlighted($list);

    return {
      index: ($highlighted.length > 0) ? $highlighted.index() : 0,
      $options: $options
    }
  }

  function _spaceHandler(event, $current, $parent) {
    event.preventDefault();

    // triggers the _selectItem method
    $current.find("a").eq(0).trigger("click");
    _clearNavigationState($parent);
  }

  function keyDownHandler(event) {
    /*jshint validthis:true */
    var $current = $(this),
      $parent = $current.parent();

    switch (event.which) {
    case KEYS.UP_ARROW:
      event.preventDefault();
      _clearNavigationState($parent);

      if(_getCurrent($current).index > 0) {
        _changeFocus($current, $current.prev());
      }

      break;

    case KEYS.DOWN_ARROW:
      event.preventDefault();
      _clearNavigationState($parent);

      var currentData = _getCurrent($current);
      var index = currentData.index;

      if(index >= 0 && index + 1 < currentData.$options.length) {
        _changeFocus($current, $current.next());
      }

      break;

    case KEYS.ENTER:
      _spaceHandler(event, $current, $parent);

      break;

    case KEYS.ESCAPE:
      event.preventDefault();
      var popover = factory.get($current.closest(".a-popover"));
      popover.sourceButton.find(".a-button-text").focus();
      popover.hide();
      _clearNavigationState($parent);

      break;

    case KEYS.SPACE:
      if (!$parent.data(USER_NAVIGATED_TEXT)) {
        _spaceHandler(event, $current, $parent);
      }

      break;

    case KEYS.TAB:
      // clear state, everything else is normal tab behavior
      // handled elsewhere

      _clearNavigationState($parent);

      break;

    // People might hit backspace in an attempt to correct their autocomplete.
    // In Chrome, with a standard <select>, backspace does *nothing*. It doesn't
    // edit the queried text, and importantly, does *not* navigate backwards
    // through the browser history. We mimic that behavior here.
    case KEYS.BACKSPACE:
      event.preventDefault();
      break;
    }
  }

  function _navigationDebouncer($parent) {
    var debouncer = $parent.data(USER_NAVIGATED_DEBOUNCER);

    if (!debouncer) {
      debouncer = A.debounce(function() {
        _clearNavigationState($parent);
      }, KEYBOARD_NAVIGATION_TIMEOUT);

      $parent.data(USER_NAVIGATED_DEBOUNCER, debouncer);
    }

    debouncer();
  }

  function keyPressHandler(event) {
    /*jshint validthis:true */
    var $current = $(this),
      $parent = $current.parent(),
      popover = factory.get($current.closest(".a-popover")),
      key = event.which;

    // Abort if the popover is actually closed, i.e. it was closed by the preceding keyDown handler.
    if (!popover || !popover.isActive()) {
      return;
    }

    // we don't want to match TAB as a character, and TAB nav handled elsewhere
    if(key === KEYS.TAB || key === 0) {
        return;
    }

    /**
     * Keyboard navigation notes:
     * 1) Uses keydown, which is unreliable (read: unusable) for punctuation characters
     *    (See http://www.quirksmode.org/js/keys.html#link5 Punctuation keys)
     * 2) Clears state KEYBOARD_NAVIGATION_TIMEOUT milliseconds after the last keypress.
     * 3) Because this is a prefix search, this optimizes subsequent keypresses by not
     *    rescanning elements that couldn't possibly match.
     * 4) Ignores backspace.
     * 5) If no match can be found, the current state is "poisoned" so we won't keep checking
     *    until the state is cleared.
     * 6) Because of optimizations made herein, modifying the dropdown options, even via API,
     *    will result in undefined behavior if the user is in the middle of typing.
     * 7) If the user hits a key that closes the popover (e.g. Enter), clearNavigationState
     *    will ultimately be called twice -- once immediately when Enter is hit, and again
     *    when the navigationDebouncer finally executes.  However, this is harmless; the
     *    "clear on Enter" case is vital so the state is clean if the dropdown is quickly
     *    reopened; and tracking enough state to keep the debouncer from actually executing
     *    would be a bit of a pain.
     */

    // We want to "reset" the state after a bit so they can start over with a new query.
    _navigationDebouncer($parent);

    var startingIndex = $parent.data(USER_NAVIGATED_IDX) || 0;

    if (startingIndex < 0) {
      // Query is doomed, no possible match.
      return;
    }

    // Append onto the text so far, unless it's whitespace.
    var query = ($parent.data(USER_NAVIGATED_TEXT) || '') + String.fromCharCode(key).toLocaleLowerCase();
    $parent.data(USER_NAVIGATED_TEXT, query);

    var $optionsToCheck = $parent.children();

    // Optimization: skip ahead to the last found entry and start searching from there.
    for (var i = startingIndex; i < $optionsToCheck.length; i++) {
      var $option = $optionsToCheck.eq(i);

      if (A.trim($option.text().toLocaleLowerCase()).indexOf(query) === 0) {
        $option.focus();
        $parent.data(USER_NAVIGATED_IDX, i);
        return;
      }
    }

    // Mark query as doomed, no possible match, since nothing has been found so far.
    $parent.data(USER_NAVIGATED_IDX, -1);

    // if it hasn't matched and the final key was a space, select the option
    if(key === KEYS.SPACE) {
      _spaceHandler(event, $current, $parent);
    }
  }

  return {
    keyDown: keyDownHandler,
    keyPress: keyPressHandler
  };
});
/////////////////////////
// END FILE js/dropdowns/base/keyboard_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base class for dropdown, providing pointers to show popovers and manipulate select tags
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */

P.when("A", "a-dropdown-select-apis", "a-dropdown-base-factory", "a-popover-base").register("a-dropdown-base", function (A, dropdownSelect, factory, popoverBase) {
  var undefined,
    $ = A.$;

  /**
   * Creates and shows the popover which serves as the proxy <select> tag
   *
   * @private
   * @param {object} event  The declarative event which triggered the creation of the popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   */
  function showDropdown(event, options, typeSpecificFunctions) {
    // IE 8 somtimes throws an error when attempting to do things
    // to the event.  The jist is by the time you attempt to prevent default,
    // the event object has been replaced or invalidated, even if in a closure.  This
    // causes a "member not found" error to be thrown.  Related jQuery bug is
    // marked "won't fix".  Corresponding MS bug exists, but very little activity,
    // and nothing from MS. You have to register with their feedback thing to get
    // a non-404 page with the MS link, unfortunately.
    //   jQuery:  http://bugs.jquery.com/ticket/12577
    //   MS:  https://connect.microsoft.com/IE/feedback/details/774078
    try {
      var nativeEvent = event.$event || event;
      if(nativeEvent.preventDefault) {
        nativeEvent.preventDefault();
      } else {
        nativeEvent.returnValue = false;
      }
    } catch (e) {}
    var $trigger = event.$declarativeParent ? event.$declarativeParent : $(event.currentTarget);
    // To allow the preventClickThrough stuff to work, we need to give the timer a chance to fire.
    A.delay(function () {
      var $button = options.$button ? options.$button : options.getButtonFromEvent(event),
        $sourceSelect = options.$select ? options.$select : options.getSelectFromEvent(event);

      if (!$button.hasClass("a-button-disabled")) {
        // Refresh popover if the content in the popover is different than in <select>
        var selectInstance = getSelect($sourceSelect, options);
        if (!selectInstance.isSynced()) {
          refreshPopover($.extend({
            $button: $button,
            $select: $sourceSelect
          }, options));
        }

        // Variables to initiate a popover
        var newOptions = A.extend({}, options, {
            $button: $button,
            $sourceSelect: $sourceSelect
          }),
          popover = factory.create($trigger, newOptions, typeSpecificFunctions);

        if (popover) {
          popover.show();
          $button.data("a-popover-id", popover.id).data("popover", popover).data("isPressed", true);

          // When images haven't been loaded, the height and width are small.  However, after loading,
          // they can affect the total height of the popover.  Ensure that when images are loaded,
          // the popover has been resized and/or made scrollable to accommodate the new size.
          if (!popover.hasOnLoad) {
            popover.hasOnLoad = true;
            var deferreds = [];
            var $images = popover.$popover.find("img");
            if ($images.length) {
              $images.each(function (idx, image) {
                if (!image.complete || !image.naturalWidth) {
                  var def = $.Deferred();
                  deferreds.push(def);
                  $(image).bind("load error", function () {
                    def.resolve();
                  });
                }
              });

              if (deferreds.length) {
                $.when.apply($, deferreds).done(function () {
                  popover.updatePosition();
                });
              } else {
                popover.updatePosition();
              }
            }
          }
        }
      }
    });
  }

  /**
   *  @deprecated
   *  A default event handler which will toggle the visible state of the dropdown popover
   *  and create it if necessary.  Calling this function will also update the data/aria
   *  attributes to accurately reflect the state of the popover.
   *
   *  @public
   *  @param {object} event  The event which triggered this function
   *  @param {object} mandatory options hash
   */

  function toggleDropdown(event, options) {
    var $button = options.$button ? options.$button : options.getButtonFromEvent(event),
      popover = $button.data("popover");

    if (popover && popover.$popover.is(":visible")) {
      popover.hide();
    } else {
      showDropdown(event, options);
    }
  }

  /**
   *  Hides the dropdown popover
   *
   *  @public
   *  @param {object} mandantory options hash
   *
   *  @return boolean  if the remove process succeed
   */

  function hidePopover(options) {
    var $button = options.$button;
    var $select = options.$select;

    if (!$button) {
      $button = $select.nextAll(".a-button-dropdown");
    }
    if ($select.length) {
      var popover = factory.get($button);
      if (popover) {
        popover.hide();
      }
      return true;
    }
    return false;
  }

  /**
   *  Refreshes content of dropdown popover, especially after updates
   *
   *  @public
   *  @param {object} mandantory options hash
   *
   *  @return boolean  if the remove process succeed
   */

  function refreshPopover(options) {
    var $button = options.$button;
    var $select = options.$select;

    if (!$button) {
      $button = $select.nextAll(".a-button-dropdown");
    }
    if ($select.length) {
      var popover = factory.get($button);
      if (popover) {
        factory.remove(popover.id);
      }
      $select.data("a-info", null); // Clear cached option info
      return true;
    }
    return false;
  }

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *  @param {object} mandantory options hash
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom, options) {
    var $select, select, $button;

    if (options.$select) {
      $select = options.$select;
    } else if (typeof selectNativeIdOrDom === "string") {
      $select = $("select#" + selectNativeIdOrDom);
    } else {
      $select = selectNativeIdOrDom.jquery ? selectNativeIdOrDom : $(selectNativeIdOrDom);
    }
    if (!$select.length) {
      return null;
    }

    if (options.$button) {
      $button = options.$button;
    } else {
      $button = options.getButtonFromSelect($select);
    }

    if (!$select.data("a-select")) {
      select = A.extend({
        hidePopover: hidePopover,
        refreshPopover: refreshPopover,
        options: A.extend({
          $select: $select,
          $button: $button
        }, options)
      }, dropdownSelect);
      $select.data("a-select", select);
    } else {
      select = $select.data("a-select");
    }
    return select;
  }

  return {
    toggleDropdown: toggleDropdown,
    showDropdown: showDropdown,
    getSelect: getSelect
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_options_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown options APIs
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "jQuery").register("a-dropdown-options-apis", function (A, $) {
  var undefined;
  /**
   *  Updates the native <option> with the given ID and invalidate the cached popover, if it exists.
   *  Only options exposed on the dropdownOption tempate are accepted.  Any other options which
   *  are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {object} hash  A hash of new option values to set on the <option>
   */

  function update(hash) {
    /*jshint validthis:true */
    if (typeof hash !== "object") {
      P.error("input of options.update() function must be a hash");
    }

    this.hidePopover(this.options);

    for (var i = 0, last = this.size(); i < last; i++) {
      var $item = this.options.elements[i];
      var item = $item[0];

      if (hash.value) {
        $item.val(hash.value);
      }

      if (hash.selected !== undefined) {
        if (!item.selected && hash.selected) {
          this.options.$select.val(item.value);
        } else if (item.selected && !hash.selected) {
          this.options.$select.val("");
        }
      }

      if (hash.html_content) {
        $item.data("a-html-content", hash.html_content);
      }

      if (hash.image_source) {
        $item.data("a-image-source", hash.image_source);
      }

      if (hash.native_css_class) {
        item.className = hash.native_css_class;
      }

      if (hash.css_class) {
        $item.data("a-css-class", hash.css_class);
      }

      if (hash.native_id) {
        item.id = hash.native_id;
      }

      if (hash.id) {
        $item.data("a-id", hash.id);
      }

      if (hash.text) {
        $item.text(hash.text);
        if (item.selected) {
          this.setSelectValue(item.value);
        }
      }
    }

    this.refreshPopover(this.options);
    return this;
  }

  /**
   *  remove current set of options
   *
   *  @public
   *
   *  @return {boolean} always true
   */

  function remove() {
    /*jshint validthis:true */

    this.hidePopover(this.options);

    for (var i = 0, last = this.size(); i < last; i++) {
      var $option = this.options.elements[i];

      //remove set value if we are removing this option
      if ($option.is(":selected")) {
        this.setSelectValue("");
      }
      //remove option node
      //potential bug fix when the option is in an option group option is not
      //removed (added by gorkem)
      $option.remove();
    }

    this.refreshPopover(this.options);
    return true;
  }

  /**
   *  get options' info
   *
   *  @public
   *
   *  @return {object}  array of [{text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}]
   */

  function info() {
    /*jshint validthis:true */
    var infoArray = [];

    for (var i = 0, last = this.size(); i < last; i++) {
      var $option = this.options.elements[i];

      infoArray.push({
        value: $option[0].value,
        text: $option.text(),
        selected: $option[0].selected,
        html_content: $option.data('a-html-content'),
        image_source: $option.data("a-image-source"),
        native_css_class: $option[0].className,
        css_class: $option.data("a-css-class"),
        native_id: $option[0].id,
        id: $option.data("a-id")
      });
    }
    return infoArray;
  }

  /**
   *  get options' size
   *
   *  @public
   *
   *  @return {number}  number of items in options array
   */

  function size() {
    /*jshint validthis:true */
    return this.options.elements.length;
  }

  return {
    update: update,
    remove: remove,
    info: info,
    size: size
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_options_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_select_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown select APIs
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "jQuery", "a-dropdown-options-apis").register("a-dropdown-select-apis", function (A, $, dropdownOptions) {
  var undefined;

  /**
   *  When looking for child options, the jQuery selector isn't quite as obvious as you'd think.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var CHILD_OPTION_SELECTOR = "optgroup, option:not(.a-prompt)";

  /**
   *  Disabled css class name for the button
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_DISABLED_CSS_CLASS = "a-button-disabled";

  /**
   *  Error css class name for the button
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_ERROR_CSS_CLASS = "a-button-error";

  /**
   *  Toggle the disabled status by the given isDisabled flag.
   *  When isDisabled is true, the dropdown will be disabled.
   *
   *  @private
   *  @param {Element} select The native select element
   *  @param {jquery} $buttonCollection The button collection jquery object
   *  @param {boolean} isDisabled The flag indicating if it should disable the dropdown
   */

  function toggleDisabledDropdown(select, $buttonCollection, isDisabled) {
    // the select doesn't need aria-disa  bled because screen readers already recognize "disabled" attribute
    select.disabled = isDisabled;

    // toggling disabled css class
    $buttonCollection.toggleClass(BUTTON_DISABLED_CSS_CLASS, isDisabled);

    // toggling a11y aria-disabled attribute
    if( $(select).hasClass('a-native-splitdropdown')) {
      if(isDisabled) {
        $buttonCollection.find('button.a-button-text')
          .attr('aria-disabled', 'true').parents('.a-button-splitdropdown').find('button.a-button-text').removeAttr('role');
      } else {
        $buttonCollection.find('button.a-button-text')
          .removeAttr('aria-disabled').parents('.a-button-splitdropdown').find('button.a-button-text').attr('role','combobox');
      }
    } else {
      isDisabled ? $buttonCollection.attr('aria-disabled', 'true') :
        $buttonCollection.removeAttr('aria-disabled');
    }
  }

  /**
   *  Toggle the error status by the given isError flag.
   *  When isError is true, the dropdown's button status will be set to error.
   *
   *  @private
   *  @param {jquery} $buttonCollection The button collection jquery object
   *  @param {boolean} isDisabled The flag indicating if it should disable the dropdown
   */
  function toggleErrorButton($buttonCollection, isError) {
    $buttonCollection
      .toggleClass(BUTTON_ERROR_CSS_CLASS, isError);
  }

  function updateDropdownStatus(select, $button, status) {
    // $buttonCollection will represent one or two buttons
    // depending on dropdown type (standard or split)
    var $buttonCollection = $button
        .closest(".a-dropdown-container, .a-splitdropdown-container")
        .find(".a-button");

    // status flags
    var isDisabled = status === 'disabled',
      isError = status === 'error';

    toggleDisabledDropdown(select, $buttonCollection, isDisabled);
    toggleErrorButton($buttonCollection, isError);
  }
  /**
   * Check if the options is synchronized with content of popover. Since popover recreation
   * requires DOM manipulation, checking two levels of hash values should still be faster.
   *
   * @public
   *
   * @return {boolean} true for the content has not been changed since last dropdown displayed, false otherwise.
   */

  function isSynced() {
    /*jshint validthis:true */
    var $select = this.options.$select,
      prev = $select.data("a-info"),
      current = this.getOptions().info();

    $select.data("a-info", current);

    // No "prev" means popover never displayed, thus it is clean
    return prev ? A.equals(prev, current) : true;
  }

  /**
   *  Updates classes and data attributes on the native <select> node as well as the generated dropdown button.  If the
   *  dropdown is currently "open", it will "close". Only options exposed on the dropdown tempate are accepted.
   *  Any other options which are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {object} hash  A hash of new option values for the dropdown template
   *
   *  @return {object} self pointer
   */

  function update(hash) {
    /*jshint validthis:true */
    if (typeof hash !== "object") {
      P.error("input of select.update() function must be an object");
    }

    this.hidePopover(this.options);

    var validSpacing = {
      none: true,
      micro: true,
      mini: true,
      small: true,
      base: true,
      medium: true,
      large: true,
      "extra-large": true,
      "double-large": true,
      block: true
    };
    var $select = this.options.$select;
    var select = $select[0];
    var $button = this.options.$button;
    var button = $button[0];
    var $label = $select.siblings("label");

    if (hash.name) {
      select.name = hash.name;
    }

    if (hash.option_prompt) {
      var $prompt = $select.find(".a-prompt");
      if ($prompt.length) {
        $prompt.text(hash.option_prompt);
        if ($prompt.prop("selected")) {
          $button.find(".a-dropdown-prompt").text(hash.option_prompt);
        }
      } else {
        $select.prepend($("<option class='a-prompt' />").text(hash.option_prompt));
        $button.find(".a-dropdown-prompt").text(hash.option_prompt);
      }
    }

    if (hash.has_images !== undefined) {
      $select.data("a-has-images", !!hash.has_images);
    }

    if (hash.button_size !== undefined && $button.length) {
      if (hash.button_size === "small") {
        $button.addClass("a-button-small");
      } else {
        $button.removeClass("a-button-small");
      }
    }

    if (hash.spacing !== undefined) {
      if (validSpacing.hasOwnProperty(hash.spacing)) {
        var spacingClassRegex = /\ba-spacing-[a-z]+\b/g
        select.className = select.className.replace(spacingClassRegex, "");
        button.className = button.className.replace(spacingClassRegex, "");
        $select.addClass("a-spacing-" + hash.spacing);
        $button.addClass("a-spacing-" + hash.spacing);
      }
    }

    if (hash.grid_units !== undefined) {
      var gridUnitsClassRegex = /\ba-button-span\d{1,2}\b/g;
      select.className = select.className.replace(gridUnitsClassRegex, "");
      button.className = button.className.replace(gridUnitsClassRegex, "");

      if (isFinite(hash.grid_units) && hash.grid_units > 0 && hash.grid_units < 13) {
        $select.addClass("a-button-span" + hash.grid_units);
        $button.addClass("a-button-span" + hash.grid_units);
      }
    }

    if (hash.width_name) {
      if (hash.width_named === "base") {
        $button.addClass("a-button-width-normal");
      } else {
        $button.removeClass("a-button-width-normal");
      }
    }

    if (hash.status) {
      updateDropdownStatus(select, $button, hash.status);
    }

    if (hash.native_id) {
      select.id = hash.native_id;
      if ($label.length) {
        $label[0].htmlFor = hash.native_id;
      }
    }

    if (hash.id) {
      button.id = hash.id;
    }

    if (hash.native_css_class) {
      var nativeClass = $select.data("a-native-class");
      if (nativeClass) {
        $select.removeClass(nativeClass);
      }
      $select.addClass(hash.native_css_class).data("a-native-class", hash.native_css_class);
    }

    if (hash.css_class) {
      var buttonClass = $button.data("a-class");
      if (buttonClass) {
        $button.removeClass(buttonClass);
      }
      $button.addClass(hash.css_class).data("a-class", hash.css_class);
    }

    if (hash.label_text !== undefined) {
      if (hash.label_text === "") {
        $button.find(".a-dropdown-label").remove();
        $select.siblings("label").remove();
      } else {
        var $dropdownLabel = $button.find(".a-dropdown-label");
        if ($dropdownLabel.length) {
          $dropdownLabel.text(hash.label_text);
        } else {
          $button.find(".a-dropdown-prompt").before($("<span class='a-dropdown-label' />").text(hash.label_text));
        }

        if ($label.length) {
          $label.text(hash.label_text);
        } else {
          $label = $select.before($("<label for='" + select.id + "' class='a-native-dropdown' />").text(hash.label_text));
        }
      }
      // Some browsers don't update the button's width after adding or removing the label span when the button is display:inline
      // This results in text that's cut off or a button that's too wide.
      // Set min-width to effectively "touch" it and force an update.
      $button.css("min-width", hash.label_text === "" ? "0.1%" : "0%");
    }

    this.refreshPopover(this.options);
    return this;
  }

  /**
   *  Alter the dropdown with the given native_id so that the option with the value passed is selected.
   *  Pass in an empty string to set the value to the default.
   *
   *  @public
   *  @param {string} value  The new value to set
   *
   *  @return {object} self pointer
   */

  function setValue(value) {
    /*jshint validthis:true */
    var $select = this.options.$select;
    var $button = this.options.$button;
    var select = $select[0];

    // The value attribute of options is always a string, but trying to set the value to 3 seems legit.
    if (typeof value === "number") {
      value = value.toString();
    }

    // Find the option which matches the value
    for (var i = 0, l = select.options.length; i < l; i++) {
      if (select.options[i].value === value) {
        break;
      }
    }

    // Passing in an empty string for value means selecting the first option in the list
    // if there isn't an existing option with that value.
    if (i === l && value === "") {
      i = 0;
    }

    // If the value has actually changed, update stuff.
    if (i < l) {
      // Make sure that the button text is up to date no matter what
      $button.find(".a-dropdown-prompt").html(select.options[i].innerHTML);
      $button.css("min-width", i / select.options.length + "%");

      if ($select.val() !== value) {
        // Manually trigger the element-changed event on the native component
        // Only triggers if the value changed, mimicking native
        // We don't want to trigger events using A.trigger when using this API because the user didn't select anything
        $select.val(value);
        $select.trigger("change", [undefined, true]);
      }
    }

    return this;
  }

  /**
   * A shorthand for setValue/getValue to align with jQuery style
   *
   * @public
   *  @param {string} value  The new value to set
   *
   *  @return {object/string}  Depending on whether the value is set
   */

  function val(value) {
    /*jshint validthis:true */
    if (value === undefined) {
      //get value
      return this.options.$select.val();
    } else {
      //set value
      this.setValue = setValue;
      return this.setValue(value);
    }
  }

  /**
   *  Returns options instance for option level operations
   *
   *  @public
   *  @param {number/string/object} nativeIdsOrIndexesOrDoms  an array of numbers(indexes), strings(ids), or objects(DOM) to locate the options
   *
   *  @return {object}  options instance
   */

  function getOptions(nativeIdsOrIndexesOrDoms) {
    /*jshint validthis:true */
    var keys = [];
    var $select = this.options.$select;
    var elements = [];

    if (nativeIdsOrIndexesOrDoms === undefined) {
      keys = $select.children(CHILD_OPTION_SELECTOR);
    } else if ($.isArray(nativeIdsOrIndexesOrDoms)) {
      keys = nativeIdsOrIndexesOrDoms;
    } else {
      keys = [nativeIdsOrIndexesOrDoms];
    }

    for (var i = 0, last = keys.length; i < last; i++) {
      var key = keys[i];
      var $option = [];
      if (A.isFiniteNumber(key)) {
        $option = $select.children(CHILD_OPTION_SELECTOR).eq(key);
      } else if (typeof key === "string") {
        $option = $select.children('option#' + key);
      } else if (typeof key === "object") {
        $option = key.jquery ? key : $(key);
      }
      if ($option.length) {
        elements.push($option);
      }
    }

    return A.extend({
      hidePopover: this.hidePopover,
      refreshPopover: this.refreshPopover,
      setSelectValue: val,
      options: A.extend({
        elements: elements //array of dropdown options
      }, this.options)
    }, dropdownOptions);
  }

  /**
   * Returns options instance for option level operations
   *
   * @public
   *  @param {number/string/object} nativeIdOrIndexOrDom  number(index), string(id), or object(DOM) to locate the option
   *
   *  @return {object}  options instance
   */

  function getOption(nativeIdOrIndexOrDom) {
    /*jshint validthis:true */
    return this.getOptions(nativeIdOrIndexOrDom);
  }

  /**
   *  Add multiple options into dropdown. Options with existing id will not be inserted again.
   *  @public
   *  @param {object} options  [{text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}]
   *  @param {number} position  where the option is inserted, starting from 0
   *
   *  @return {object} self pointer
   */

  function addOptions(elements, position) {
    /*jshint validthis:true */
    if (!$.isArray(elements)) {
      elements = [elements];
    }

    // Loop in reserve order to preserve options sequence
    var i = elements.length;
    while (i--) {
      this.addOption(elements[i], position)
    }
    return this;
  }

  /**
   *  Add one option into dropdown. Options with existing id will not be inserted again.
   *
   *  @public
   *  @param {object} hash  {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *  @param {number} position  where the option is inserted, starting from 0
   *
   *  @return {object} self pointer
   */

  function addOption(hash, position) {
    /*jshint validthis:true */
    var $select = this.options.$select;

    // Only add an option if that option native id does not exist or there is no native_id
    if (!hash.native_id || !$select.find("option#" + hash.native_id).length) {
      var $options = $select.children(CHILD_OPTION_SELECTOR);
      var newOption = document.createElement("option");
      var index = position && position > 0 && position <= $options.length ? position : 0;

      if (hash.native_id) {
        newOption.id = hash.native_id;
      }

      if ($options.length === 0 || index === $options.length) {
        $select[0].appendChild(newOption);
      } else {
        $options.eq(index).before(newOption);
      }
      this.getOption(newOption).update(hash);
    }
    return this;
  }

  /**
   *  This is a convenience function which delegates to addOption and uses the proper index.
   *
   *  @public
   *  @param {object} hash  {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *
   *  @return {object} self pointer
   */

  function appendOption(hash) {
    /*jshint validthis:true */
    return this.addOption(hash, this.options.$select.children(CHILD_OPTION_SELECTOR).length);
  }

  /**
   *  A convenience function for appending multiple options to a dropdown
   *
   *  @public
   *  @param {array} hashes  An array of hashes representing options.  Format for the hashes: {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *
   *  @return {object} self pointer
   */

  function appendOptions(hashes) {
    /*jshint validthis:true */
    if ($.isArray(hashes)) {
      for (var i = 0, l = hashes.length; i < l; i++) {
        this.addOption(hashes[i]);
      }
    }
    return this;
  }

  /**
   *  Remove options from dropdown by option's nativeIds or by their indexes
   *
   *  @public
   *  @param {object} idsOrIndexes  array of nativeIds(strings) or indexes(numbers), or a mixture of both
   *
   *  @return {object} self pointer
   */

  function removeOptions(idsOrIndexes) {
    /*jshint validthis:true */
    this.getOptions(idsOrIndexes).remove();
    return this;
  }

  /**
   *  Remove one option from dropdown by option's nativeId or by their index
   *
   *  @public
   *  @param {string/number} idOrIndex  nativeId (strings) or index(numbers)
   *
   *  @return {object} self pointer
   */

  function removeOption(idOrIndex) {
    /*jshint validthis:true */
    return this.removeOptions(idOrIndex);
  }

  return {
    isSynced: isSynced,
    update: update,
    setValue: setValue,
    val: val,
    getOptions: getOptions,
    getOption: getOption,
    addOptions: addOptions,
    addOption: addOption,
    removeOptions: removeOptions,
    removeOption: removeOption,
    appendOption: appendOption,
    appendOptions: appendOptions
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_select_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown code for AUI Popover
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "a-dropdown-options", "a-dropdown-apis", "a-dropdown-keyboard-handlers", 'a-analytics').register("a-dropdown", function (A, options, apis, handlers, analytics) {
  var undefined,
    $ = A.$,
    $doc = $(document);

  /**
   *  Selector used to find the root DOM node of the dropdown button.
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_SELECTOR = ".a-button-dropdown";

  /**
   *  The name of the class applied to the selected item in a dropdown.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var SELECTED_ITEM_CLASS = "a-active";
  /**
   * name of the classes applied on dropdown
   * @type {String}
   */
  var DROPDOWN_UE_KEY = 'dropdown:usage';
  var BUTTON_TEXT_SELECTOR = ".a-button-text";
  var NATIVE_DROPDOWN_SELECTOR = "select.a-native-dropdown";


  A.on("beforeReady a:pageUpdate a:ajax:complete", function () {
    var dropdownWithoutTabindex = $doc.find(NATIVE_DROPDOWN_SELECTOR).not('[tabindex=0]');
    var dropdownWithoutTabindexLength = dropdownWithoutTabindex.length;
    if(dropdownWithoutTabindexLength) {
      // Hide dropdown button from keyboard and screen reader users
      dropdownWithoutTabindex.next(BUTTON_SELECTOR).attr('aria-hidden', true).find(BUTTON_TEXT_SELECTOR)
        .removeAttr('tabindex');

      // increase ue count if declarative action is applied through template on native Dropdown
      // TODO
      // Clean up code when DROPDOWN_UE_KEY count reaches to 0.
        analytics.count(DROPDOWN_UE_KEY, dropdownWithoutTabindexLength);

      // Native dropdown changes to focusable and screenreader discoverable element.
      dropdownWithoutTabindex
        .attr('tabindex', 0);
    }
  });

  /**
   *  Trigger the events associated with a user selecting a new dropdown value.
   *  Convenience function to make reading the change event handler easier to read.
   *
   *  @private
   *  @param {DOM Node} select  The native select DOM node whos value changed
   *  @param {DOM Node} itemNode  If an <li> was selected in the popover, it should be passed here (optional)
   *
   *  triggers a:dropdown:selected:[name]
   *  triggers a:dropdown:[name]:select
   *  triggers a:dropdown:[id]:select
   *  triggers a:dropdown:select
   */
  function triggerDropdownEvents(select, itemNode) {
    var name = select.name,
      value = select.value,
      selectId = select.id,
      eventHash = {
        auiItemNode: itemNode,
        nativeItemNode: select.options[select.selectedIndex],
        selectNode: select,
        id: selectId,
        name: name,
        value: value
      };

    if (name && name !== "") {
      A.trigger("a:dropdown:" + name + ":select", eventHash);
      /**
       *  Aimed to replace by a:dropdown:<name>:select to recitfy with the rest of the triggers
       *  jira: https://jira2.amazon.com/browse/SC-794
       *  @deprecated
       */
      A.trigger("a:dropdown:selected:" + name, eventHash);
    }

    if (selectId && selectId !== "") {
      // Name specific event
      A.trigger("a:dropdown:" + selectId + ":select", eventHash);
    }

    // Global event
    A.trigger("a:dropdown:select", eventHash);
  }

  /**
   * Common delegates
   */
  // Update the UI when the native select's value changes
  $doc.delegate(".a-native-dropdown", "change", function (event, $item, silent) {
    var $button = options.getButtonFromEvent(event),
      displayText = "",
      select = this,
      value = select.selectedIndex > -1 ? select.options[select.selectedIndex].value : "", // Can't use select.value since it's not available in IE 6
      popover = $button.data("popover"),
      itemExists = false,
      option;

    // Make sure we have a button to update.  If not, the rest of this is unnecessary because something
    // went terribly wrong.
    if (!$button.length) {
        return;
    }

    $button = $button.eq(0);

    // Get the text we're going to display in the button and make sure the correct option
    // is listed as "selected"
    var i = select.length;
    while (i--) {
      option = select.options[i];
      if (option.value === value) {
        displayText = option.innerHTML;
        break;
      }
    }

    // If a popover item hasn't been passed in, then someone triggered a change event via JS
    // and we need to try and find it using the data on the $button
    if (popover && popover.$popover) {
      // Clear the active class and aria attributes from the popover DOM
      var $selected = popover.$popover.find("." + SELECTED_ITEM_CLASS);
      $selected.removeClass(SELECTED_ITEM_CLASS).closest("li").attr("aria-checked", false);

      if ($item === undefined) {
        // AUI-8874 we let JSON do the dirty work
        var valString = JSON.stringify({ 'stringVal': value });
        // we also need to escape one more time for jQuery selector
        $item = popover.$popover.find('a[data-value="' + A.escapeJquerySelector(valString) + '"]');
      }
    }

    // If we have a popover item, then we need to update the UI for that component
    if ($item && $item.length) {
      itemExists = true;

      // ARIA attributes and classes need to be updated
      $item.addClass(SELECTED_ITEM_CLASS).closest("li").attr("aria-checked", true);
    }

    // Update the trigger button text and hide the popover.
    // Some browsers don't update the button's width after updating the prompt span when the button is display:inline.
    // This results in text that's cut off or a button that's too wide.
    // Set min-width to force a repaint and ensure the button is the correct width.
    $button.find(".a-dropdown-prompt").html(displayText);
    $button.css("min-width", select.selectedIndex / select.options.length + "%");

    if (popover) {
      popover.hide();

      // We need to update the info cache or the popover will be invalidated after every odd numbered selection
      var selectObj = apis.getSelect(select);
      if (selectObj) {
        $(this).data("a-info", selectObj.getOptions().info());
      }
    }

    // Trigger a selection event if necessary and able
    if (!silent) {
      triggerDropdownEvents(this, itemExists ? $item[0] : null);
    }
  });

  // Focusing on a button's containing span using JS should actually focus the element (a, button, input) within
  $doc.delegate(BUTTON_SELECTOR + ":not(.a-button-disabled)", "focusin", function () {
    $(this).find(".a-button-text").focus();
  });

  // Added focus ring around dropdown button when native dropdown gets focus
  $doc.delegate(NATIVE_DROPDOWN_SELECTOR, 'focusin', function() {
    var $button = $(this).closest('.a-dropdown-container').find('.a-button-dropdown');
    if (!$button.hasClass("a-button-disabled")) {
      $button.addClass("a-button-focus");
    }

  // Remove focus ring around dropdown button when native dropdown looses focus
  }).delegate(NATIVE_DROPDOWN_SELECTOR, 'focusout', function() {
    $(this).closest('.a-dropdown-container').find('.a-button-dropdown').removeClass("a-button-focus");
  });

  // Returning dropdown APIs
  return apis;
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown APIs
 *
 */

"use strict";

P.when("A", "a-dropdown-base", "a-dropdown-options").register("a-dropdown-apis", function (A, base, options) {
  var undefined,
    $ = A.$;

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom) {
    return base.getSelect(selectNativeIdOrDom, options);
  }

  /**
   *  @deprecated
   *
   *  Updates the native <option> with the given ID and invalidate the cached popover, if it exists.
   *  Only options exposed on the dropdownOption tempate are accepted.  Any other options which
   *  are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {string} nativeId  The native_id parameter used in the dropdownOption template
   *  @param {object} hash  A hash of new option values to set on the <option>
   */

  function updateOption(nativeId, hash) {
    var $select = $("option#" + nativeId).closest("select");
    getSelect($select).getOption(nativeId).update(hash);
  }

  /**
   *  @deprecated
   *
   *  Updates classes and data attributes on the native <select> node as well as the generated dropdown button.  If the
   *  dropdown is currently "open", it will "close". Only options exposed on the dropdown tempate are accepted.
   *  Any other options which are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {string} nativeId  The native_id parameter used in the dropdown template
   *  @param {object} hash  A hash of new option values for the dropdown template
   */

  function updateSelect(nativeId, hash) {
    getSelect(nativeId).update(hash);
  }

  /**
   *  @deprecated
   *
   *  Alter the dropdown with the given native_id so that the option with the value passed is selected.
   *  Pass in an empty string to set the value to the default.
   *
   *  @public
   *  @param {string} nativeId  The native_id param used when creating the dropdown template
   *  @param {string} value  The new value to set
   *
   *  @return {boolean}  Returns true if the value was present and set succeeded, false otherwise
   */

  function setValue(nativeId, value) {
    getSelect(nativeId).setValue(value);
  }

  /*
  On DOM ready, it's possible for the UI of the dropdown component to not match the value
  of the underlying <select> tag due to browsers autocompleting or changing the value provided
  by the server to whatever the user had selected on a previous page view.
  */
  A.on("beforeReady", function () {
    $(".a-dropdown-container select").each(function () {
      var auiSelect = getSelect(this);
      if (auiSelect) {
        auiSelect.val(auiSelect.val());
      }
    });
  });

  return {
    getSelect: getSelect,
    updateOption: updateOption, // deprecated
    updateSelect: updateSelect, // deprecated
    setValue: setValue // deprecated
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown view
 *
 */

'use strict';

P.when('A', 'a-popover-accessibility').register('a-dropdown-view', function (A, a11y) {
  var undefined,
    $ = A.$;

  return {
    /**
     *  Creates the outer skin (popover container) for desktop dropdowns
     *
     *  @private
     *  @param {object} popover  Popover instance
     *
     *  @return {string}  The HTML for the dropdown popover
     */

    skin: function (popover) {
      var header = popover.attrs("header") || "";
      var id = popover.id;
      var accesibility_params = {
          id : id,
          header_str: header,
          needs_declarative: false
      };

      return [
        '<div class="a-popover a-dropdown a-dropdown-common a-declarative" aria-modal="true" data-action="a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        '<div class="a-popover-inner"></div>',
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>'].join('');
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_options.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown specific selector and locators
 *
 */

"use strict";

P.when("A").register("a-dropdown-options", function (A) {
  var undefined,
    $ = A.$;

  /**
   *  Selector used to find the root DOM node of the dropdown button.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var BUTTON_SELECTOR = ".a-button-dropdown";
  var NATIVE_DROPDOWN_SELECTOR = "select.a-native-dropdown";

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown button
   */

  function getButtonFromEvent(event) {
    if (event.popover) {
      return event.popover.$trigger.nextAll(BUTTON_SELECTOR);
    } else if (event.$target) {
      return getButtonFromSelect(event.$target);
    } else {
      return $(event.target).nextAll(BUTTON_SELECTOR);
    }
  }

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} $select  select jquery object
   *
   * @return {object} jquery object of the dropdown button
   */

  function getButtonFromSelect($select) {
    return $select.nextAll(BUTTON_SELECTOR);
  }
  /**
   * Obtain select DOM for event calls
   *
   * @private
   * @param {object} $button  button jquery object
   *
   * @return {object} jquery object of the dropdown select
   */

  function getSelectFromButton($button) {
    return $button.closest(BUTTON_SELECTOR).prevAll(NATIVE_DROPDOWN_SELECTOR);
  }

  /**
   * Obtain select DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown select
   */

  function getSelectFromEvent(event) {
    var $select = $(event.target);

    if (!$select.length) {
      P.error("Cannot locate the <select> of dropdown");
    }
    return $select;
  }

  /**
   * A list of options to be injected into dropdown base class
   *
   * @private
   */
  return {
    getSelectFromButton: getSelectFromButton,
    getButtonFromEvent: getButtonFromEvent,
    getButtonFromSelect: getButtonFromSelect,
    getSelectFromEvent: getSelectFromEvent,
    triggerSelector: BUTTON_SELECTOR
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_options.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Split Dropdown view
 *
 */

'use strict';

P.when('A', 'a-popover-accessibility').register('a-dropdown-split-view', function (A, a11y) {
  var undefined;

  return {
    /**
     *  Creates the outer skin (popover container) for desktop split dropdowns
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string}  The HTML for the dropdown popover
     */

    skin: function (popover) {
      var label = popover.attrs("header") || "";
      var id = popover.id;
      var accesibility_params = {
          id : id,
          label_str: label,
          needs_declarative: false
      };

      return [
        '<div class="a-popover a-splitdropdown a-dropdown-common a-declarative" aria-modal="true" data-action="a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        '<div class="a-popover-inner"></div>',
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>'].join('\n');
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations for Split Dropdowns
 *
 */

'use strict';

P.when("A", "a-dropdown-base", "a-dropdown-split-utils", "a-dropdown-split-view", "a-dropdown-split-options", "a-dropdown-base-factory", "a-dropdown-keyboard-handlers", "prv:a-tnr")
.register('a-dropdown-split-handlers', function (A, base, utils, view, options, factory, handlers, tnr) {
  var undefined,
    $ = A.$;

  /**
   *  Bind to the dropdown button's click event via the declarative API
   */
  A.declarative("a-splitdropdown-button", "click", function (event) {
    tnr.ackDeclarative(event);
    var $button = options.getButtonFromEvent(event);
    base.showDropdown(event, A.extend({
      $button: $button
    }, options), view);
  });

  /**
   *  Bind to the split dropdown's main action's click event via the declarative API
   */
  A.declarative("a-splitdropdown-main", "click", function (event) {
    tnr.ackDeclarative(event);
    var $select = event.$target.closest(".a-splitdropdown-container").find("select"),
      selectId = $select.attr("id"),
      //the value of the main option is the default value of the select
      value = $select.val();

    //Trigger events
    utils.triggerEvent(selectId, $select, value);
    event.$event.preventDefault();
  });

  /**
   *  Ensure that the dropdown can also be accessed via the keyboard.
   */
  A.declarative("a-splitdropdown-button", "keydown", function (event) {
    tnr.ackDeclarative(event);
    var $button = options.getButtonFromEvent(event);
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;
    if (key === keycodes.DOWN_ARROW || key === keycodes.ENTER || key === keycodes.SPACE) {
      base.showDropdown(event, $.extend({
        $button: $button
      }, options), view);
    }
  });

  // Handle user selecting an item in the popover
  $(document)
    .delegate(".a-popover.a-splitdropdown a", "click", function (event) {
      tnr.ackDelegated(event);
      var $this = $(this),
        value = $this.data("value").stringVal,
        popover = factory.get($this.closest(".a-popover")),
        $select = popover.sourceSelect,
        selectId = $select.attr("id");

      // Hide popover
      popover.hide();

      //Trigger events
      utils.triggerEvent(selectId, $select, value);
      event.preventDefault();
    })

    // Keyboard navigation
    .delegate(".a-splitdropdown li", "keydown", handlers.keyDown)
    .delegate(".a-splitdropdown li", "keypress", handlers.keyPress);
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_options.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown specific selector and locators
 *
 */

"use strict";

P.when("A").register("a-dropdown-split-options", function (A) {
  var undefined,
    $ = A.$;

  /**
   * obtain button DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown button
   */

  function getButtonFromEvent(event) {
    if (event.popover) {
      return event.popover.$trigger.closest(".a-button-splitdropdown");
    } else if (event.$target) {
      return event.$target.closest(".a-button-splitdropdown");
    } else {
      return $(event.target).nextAll(".a-button-splitdropdown");
    }
  }

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} $select  select jquery object
   *
   * @return {object} jquery object of the dropdown button
   */

  function getButtonFromSelect($select) {
    return $select.next(".a-button-group-splitdropdown").find(".a-button-splitdropdown");
  }

  /**
   * Obtain select DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown select
   */

  function getSelectFromEvent(event) {
    var $select = getButtonFromEvent(event).closest(".a-splitdropdown-container").find("select");

    if (!$select.length) {
      P.error("cannot locate the <select> of the split dropdown");
    }
    return $select;
  }

  return {
    getButtonFromEvent: getButtonFromEvent,
    getButtonFromSelect: getButtonFromSelect,
    getSelectFromEvent: getSelectFromEvent
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_options.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown specific util functions
 *
 */

"use strict";

P.when("A").register("a-dropdown-split-utils", function (A) {
  var undefined,
    $ = A.$;

  function triggerEvent(selectId, $select, value) {
    var eventHash = {
      $select: $select,
      value: value,
      id: selectId
    };
    A.trigger('a:splitdropdown:' + selectId + ':select', eventHash);
    A.trigger('a:splitdropdown:select', eventHash);
  }

  return {
    triggerEvent: triggerEvent
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown, variation of popover
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "a-dropdown-base", "a-dropdown-split-options", "a-dropdown-split-utils", "a-dropdown-split-handlers", 'a-analytics').register("a-splitdropdown", function (A, base, options, utils, handlers, analytics) {
  var undefined,
    $ = A.$,
    $document = $(document);


  /**
   * name of the classes applied on split dropdown
   * @type {String}
   */
  var SPLITBUTTON_SELECTOR = ".a-button-splitdropdown .a-button-text";
  var NATIVE_SPLITDROPDOWN_SELECTOR = 'select.a-native-splitdropdown';

  A.on("a:pageUpdate beforeReady", function () {
    /*
     * If the browser doesn't really support overflow:scroll in floated or
     * positioned divs, So, we'll need to fallback to native.
     */
    // To make native dropdown discoverable by screen reader for mobile and tablet devices
    // If touch scrolling is not active.
    if ((A.capabilities.mobile || A.capabilities.tablet) && ! A.capabilities.touchScrolling) {
      var $nativeSplitDropdowns = $document.find(NATIVE_SPLITDROPDOWN_SELECTOR);

      // To make native dropdown discoverable by screen reader, remove aria-hidden fron native split-dropdowns
      // Also, attached for attribute on label tag sothat it can be bound to native dropdown.
      $nativeSplitDropdowns.removeAttr('tabindex').removeAttr('aria-hidden');
      var $splitDropdownLabels = $document.find('.a-splitdropdown-container label.a-native-dropdown');
      A.each($splitDropdownLabels, function(splitDropdownsLabel){
        $(splitDropdownsLabel).attr('for', $(splitDropdownsLabel).nextAll(NATIVE_SPLITDROPDOWN_SELECTOR).attr('id') || '');
      });
    }
  });

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom) {
    return base.getSelect(selectNativeIdOrDom, options);
  }

  /**
   *  Common event handlers
   */

  // broadcast event when the native select's value changes when native dropdown are used
  $document
    .delegate(".a-native-splitdropdown", "change", function (event, $item, silent) {
      var $this = $(this),
        value = $this.val(),
        selectId = $this.attr("id");

      //Trigger events
      if (!silent) {
        utils.triggerEvent(selectId, $this, value);
      }
    })

  // Focusing on a button's containing span using JS should actually focus the element (a, button, input) within
  .delegate(".a-button-splitdropdown:not(.a-button-disabled)", "focusin", function () {
    $(this).find(".a-button-text").focus();
  })

  var SPLIT_DROPDOWN_UE_KEY = 'splitdropdown:usage';
  A.on("beforeReady a:pageUpdate a:ajax:complete", function () {
    var disabledSplitDropdown = $document.find('.a-button-group-splitdropdown .a-button-disabled');
    if(disabledSplitDropdown.attr('aria-disabled')) {
      // increase ue count if aria attribute is not applied through template
      // TODO
      // Clean up code when SPLIT_DROPDOWN_UE_KEY count reaches to 0.
      analytics.count(SPLIT_DROPDOWN_UE_KEY, disabledSplitDropdown.length);
      disabledSplitDropdown.removeAttr('aria-disabled').find('.a-button-text').attr('aria-disabled', true).removeAttr('role');
    }
  });

  /**
   * Public API endpoints
   */

  return {
    getSelect: getSelect
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_accessibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Accessibility Utils for AUI Popover
 */

'use strict';

P.when('A', 'a-popover-accessibility-templates').register('a-popover-accessibility', function (A, templates) {
  var $ = A.$;
  var undefined;

  var startAnchorTemplate = templates.startAnchorTemplate;
  var startAnchorDeclarativeTemplate = templates.startAnchorDeclarativeTemplate;
  var endAnchorTemplate = templates.endAnchorTemplate;

  var descriptionTemplate = templates.descriptionTemplate;
  var offscreenDescriptionTemplate = templates.offscreenDescriptionTemplate;
  var labelTemplate = templates.labelTemplate;
  var offscreenStartTemplate = templates.offscreenStartTemplate;

  /**
   * Generates the html for the popover aria description.
   * - To be referenced by the popover's aria-describedby attribute
   *
   * @private
   * @param {string} id  The description element's id.
   * @param {string} description  The aria description text.
   *
   * @return {string}
   */
  var _getDescriptionHtml = function(id, aria_description) {
    var template = descriptionTemplate;
    var map = {
      "{{DESCRIPTION}}": aria_description,
      "{{DESCRIPTION_ID}}" : id
    }

    var mapMatch = function(match){
      return map[match];
    };

    return template.replace(/\{\{[\w_]*\}\}/g, mapMatch);
  }

  /**
   * Generates the html for the two 'anchoring' elements that bookend the popover content
   *
   * @private
   * @param {object} params  The accesibility_params. EG: id, aria label, aria describedby, etc
   *                 {string} id  popover ID
   *                 {string} label_str  popoverLabel action param
   *                 {string} header_str  header action param
   *                 {boolean} needs_declarative  whether a declarative action is needed
   *
   * @return {string}
   */
  var _getStartAnchorHtml = function(params) {
    var id = params.id;
    var header_str = params.header_str;
    var label_str = params.label_str;
    var aria_description = params.aria_description;
    var description_html = "";
    var description_id;
    var template;

    // Since popover IDs are auto-generated, there should be no use case of no ID, just in case.
    if (!id) {
      return "";
    }

    var map = {
      "{{ROLE}}": 'role="dialog"',
      "{{ANCHOR_NAME}}": "a-popover-start",
      "{{ARIA_LABEL}}": _getAriaLabel(params),
      "{{LABEL_STR}}": label_str || '', // avoid literal 'undefined'
      "{{ARIA_DESCRIBEDBY}}": ""
    };
    var mapMatch = function(match){
      return map[match];
    };

    template = params.needs_declarative ? startAnchorDeclarativeTemplate : startAnchorTemplate;

    // Add the aria aria-describedby attribute to the start content, if provided
    if (aria_description) {
      description_id = 'a-popover-aria-description-' + id;
      map["{{ARIA_DESCRIBEDBY}}"] = 'aria-describedby="' + description_id + '"';
      description_html = _getDescriptionHtml(description_id, aria_description);
    }

    // iOS issue: Voice Over ignores our hidden element which holds the aria-label
    // if the the element content is empty and the element has a role attribute set.
    // (e.g. <span role="dialog" aria-label="This is a popover label"></span>)
    // Removing the role attribute fixes the issue. But without the role,
    // the screen reader will announce the aria-label AND the name tag of the element
    // (in our case, it's button).
    // However, considering Voice Over on iOS is the prevailing combination
    // for mobile screen reader user,
    // we will apply a workaround to remove the role attribute only for iOS.
    if (A.capabilities.ios) {
      map['{{ROLE}}'] = '';
    }

    template = template.replace(/\{\{[\w_]*\}\}/g, mapMatch) + description_html;

    // trim whitespace that comes before ">"
    return template.replace(/\s\s>|\s>/g, ">");
  }

  /**
   * Generate aria-label depending on header/label combinations
   *
   * @private
   * @param {object} params  The accesibility_params. EG: id, aria label, aria describedby, etc
   *
   * @return {string}
   */
  var _getAriaLabel = function(params) {
    var id = params.id;
    var header_str = params.header_str;
    var label_str = params.label_str;

    if (label_str) {
      return 'aria-label="' + label_str + '"';
    } else if (header_str) {
      return 'aria-labelledby="a-popover-header-' + id + '"';
    }
    return "";
  };

  var _getEndAnchorHtml = function(params) {
    return endAnchorTemplate;
  };

  var _getAriaLabelledByDescribedby = function(params) {
    var id = params.id;
    var header_str = params.header_str;
    var label_str = params.label_str;
    var aria_description = params.aria_description;
    var description_id;
    var aria_attr = '';

    if (label_str) {
      aria_attr = 'aria-labelledby="a-popover-label-' + id + '"';
    } else if (header_str) {
      aria_attr =  'aria-labelledby="a-popover-header-' + id + '"';
    }

    if (aria_description) {
      description_id = 'a-popover-aria-description-' + id;
      aria_attr += ' aria-describedby="' + description_id + '"';
    }
    return aria_attr;
  };

  /**
   * Generates the screen reader hidden html for the popover aria description .
   * - To be referenced by the popover's aria-describedby attribute
   *
   * @private
   * @param {string} id  The description element's id.
   * @param {string} description  The aria description text.
   *
   * @return {string}
   */
  var _getoffScreenDescriptionHtml = function(id, aria_description) {
    var template = offscreenDescriptionTemplate;
    var map = {
      "{{DESCRIPTION}}": aria_description,
      "{{DESCRIPTION_ID}}" : id
    };

    var mapMatch = function(match){
      return map[match];
    };

    return template.replace(/\{\{[\w_]*\}\}/g, mapMatch);
  };

  /**
   * Generates the html for the aria-description html.
   * - To be referenced by the popover's aria-description attribute
   *
   * @private
   * @param {string} id  The description element's id.
   * @param {string} description  The description text.
   *
   * @return {string}
   */
  var _getDescription = function (params) {
    var description_html = "";
    var id = params.id;
    var aria_description = params.aria_description;
    var description_id;
    if (aria_description) {
      description_id = 'a-popover-aria-description-' + id;
      description_html = _getoffScreenDescriptionHtml(description_id, aria_description);
    }
    return description_html;
  };


  /**
   * Generates the html for the popover label.
   * - To be referenced by the popover's popoverLabel option
   *
   * @private
   * @param {string} id  The popoverLabel element's id.
   * @param {string} description  The popoverLabel text.
   *
   * @return {string}
   */
  var _getPopoverLabelHtml = function (params) {
    var template = labelTemplate;
    var popover_label_html= "";
    var id = params.id;
    var label_str = params.label_str;
    var label_id;
    if (label_str) {
      label_id = 'a-popover-label-' + id;
      var map = {
        "{{LABEL}}": label_str,
        "{{LABEL_ID}}" : label_id
      };
      var mapMatch = function(match){
        return map[match];
      };
      popover_label_html = template.replace(/\{\{[\w_]*\}\}/g, mapMatch);
    }
    return popover_label_html;
  };

  /**
   * Generate hidden html tag to stop focus move out of dialog
   *
   * @private
   *
   * @return {string}
   */
  var _getStartAnchorSimplifiedHtml = function () {
    return offscreenStartTemplate;
  };

  return {
    getAriaLabelledByDescribedby: _getAriaLabelledByDescribedby,
    getPopoverLabelHtml : _getPopoverLabelHtml,
    getStartAnchorHtml: _getStartAnchorHtml,
    getEndAnchorHtml: _getEndAnchorHtml,
    getDescription: _getDescription,
    getStartAnchorSimplifiedHtml: _getStartAnchorSimplifiedHtml
  };
});
/////////////////////////
// END FILE js/mixins/popover_accessibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_accessibility_templates.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
*  Accessibility Templates for Popover Start Anchor
*/

'use strict';

P.declare('a-popover-accessibility-templates', {
    startAnchorTemplate  : '<span tabindex="0" role="dialog" class="{{ANCHOR_NAME}} a-popover-a11y-offscreen" {{ARIA_LABEL}} {{ARIA_DESCRIBEDBY}}></span>',
    startAnchorDeclarativeTemplate  : '<span tabindex="0" role="dialog" data-action="a-popover-a11y" class="{{ANCHOR_NAME}} a-popover-a11y-offscreen a-declarative" {{ARIA_LABEL}} {{ARIA_DESCRIBEDBY}}>{{LABEL_STR}}</span>',
    endAnchorTemplate   : '<span tabindex="0" class="a-popover-end a-popover-a11y-offscreen"></span>',
    descriptionTemplate : '<span id="{{DESCRIPTION_ID}}" class="a-popover-a11y-offscreen">{{DESCRIPTION}}</span>',
    offscreenDescriptionTemplate : '<span id="{{DESCRIPTION_ID}}" class="a-popover-a11y-offscreen" aria-hidden="true">{{DESCRIPTION}}</span>',
    labelTemplate : '<span id="{{LABEL_ID}}" class="a-popover-a11y-offscreen" aria-hidden="true">{{LABEL}}</span>',
    offscreenStartTemplate : '<span tabindex="0" class="a-popover-start a-popover-a11y-offscreen"></span>'
  }
);
/////////////////////////
// END FILE js/mixins/popover_accessibility_templates.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  @deprecated
 *
 *  Deprecated popover ajax APIs
 */

'use strict';

P.when('A', 'a-popover-util').register('a-popover-ajax', function (A, util) {
  var undefined;

  return {
    /**
     * @deprecated
     * deprecated, please use popover.update()
     *
     * @public
     * @param {object} popover  popover instance
     * @param {string} url  url string
     * @param {object} options  hash of ajax related options
     */
    update: function(popover, url, options) {
      var hash = {};

      hash.url = url;
      if(options.timeout){
        hash.timeout = options.timeout;
      }
      if(options.ajaxFailMsg){
        hash.ajaxFailMsg = options.ajaxFailMsg;
      }
      if(options.cache){
        hash.cache = options.cache;
      }
      popover.update(hash);
    },

    /**
     * @deprecated
     * deprecated, please use popover.update() to achieve this functionality
     *
     * @public
     * @param {object} popover  popover instance
     *
     * @return {object} popover instance
     */
    showSpinner: function(popover) {
      return util.showSpinner(popover);
    }
  }
});
/////////////////////////
// END FILE js/mixins/popover_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_animate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Abstraction for animating popovers and properly invoking callbacks when they finish

'use strict';

P.when('A').register('a-popover-animate', function (A) {

  function _animate(method, args) {
    return function() {
      A[method].apply(A, args);
    }
  }

  function _callback(popover, finished) {
    return function() {
      popover._isAnimating = false;
      finished && finished();
    }
  }

  function isAnimating(popover) {
    return popover._isAnimating;
  }

  function animate(popover, properties, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('animate', [popover.$popover, properties, time, easing, _callback(popover, finished)]));
  }

  function fadeOut(popover, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('fadeOut', [popover.$popover, time, easing, _callback(popover, finished)]));
  }

  function fadeIn(popover, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('fadeIn', [popover.$popover, time, easing, _callback(popover, finished)]));
  }

  return {
    isAnimating: isAnimating,
    animate: animate,
    fadeOut: fadeOut,
    fadeIn: fadeIn
  }

});
/////////////////////////
// END FILE js/mixins/popover_animate.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_lightbox_markup.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  An abstraction for the markup for the lightbox
 */
P.declare('a-popover-lightbox-markup', {
    id: "a-popover-lgtbox",
    div: '<div id="a-popover-lgtbox" class="a-declarative" data-action="a-popover-floating-close" />'
});
/////////////////////////
// END FILE js/mixins/popover_lightbox_markup.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_navigate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Popover Hash Navigation Code For AUI

'use strict';

/**
 *  nathanir@ - Any changes to the hash outside of AUI popover navigation could result in unexpected behavior. It is
 *  not recommended to use popover navigation if an application is also modifying hash.
 */
P.when('A', 'ready').register('a-popover-navigate', function(A){
  var $ = A.$;
  var $window = $(window);

  /**
   *  A stack of visible navigable popovers.  Used when hiding popovers after altering the history stack.
   *
   *  @private
   *  @type {array}
   */
  var activeStack = [];

  /**
   *  Known history of hash navigation for the current page. Browser back button actually appends to this list, while
   *  programmatic back action will pop from this list.
   *
   *  Examples 1
   *  Navigate to #a       | hashes state = ['', 'a']            | browser history ['', 'a']
   *  Navigate to #b       | hashes state = ['', 'a', 'b']       | browser history ['', 'a', 'b']
   *  Programmatic back    | hashes state = ['', 'a']            | browser history ['', 'a']
   *  Programmatic forward | hashes state = ['', 'a', 'b']       | browser history ['', 'a', 'b']
   *  Navigate to #c       | hashes state = ['', 'a', 'b', 'c']  | browser history ['', 'a', 'b', 'c']
   *
   *  Example 2
   *  Navigate to #a  | hashes state = ['', 'a']                          | browser history ['', 'a']
   *  Navigate to #b  | hashes state = ['', 'a', 'b']                     | browser history ['', 'a', 'b']
   *  Navigate to #c  | hashes state = ['', 'a', 'b', 'c']                | browser history ['', 'a', 'b', 'c']
   *  Browser back    | hashes state = ['', 'a', 'b', 'c', 'b']           | browser history ['', 'a', 'b']
   *  Browser forward | hashes state = ['', 'a', 'b', 'c', 'b', 'c']      | browser history ['', 'a', 'b', 'c']
   *  Navigate to #d  | hashes state = ['', 'a', 'b', 'a', 'b', 'c', 'd'] | browser history ['', 'a', 'b', 'c', 'd']
   *
   *  Example 3
   *  Navigate to #a    | hashes state = ['', 'a']           | browser history ['', 'a']
   *  Navigate to #b    | hashes state = ['', 'a', 'b']      | browser history ['', 'a', 'b']
   *  Browser back      | hashes state = ['', 'a', 'b', 'a'] | browser history ['', 'a']
   *  Programmatic back | hashes state = ['', 'a', 'b']      | browser history [''] (This would likely result in bug, opening b)
   *
   *  @private
   *  @type {array}
   */
  var hashes =[];

  /**
   * Ignore enables the hash change function to bypass automatic navigation. Ignore is set to true when programmatically
   * setting a hash, and is then reset to false from the hash change handler. This only occurs when using the forward
   * API method.
   *
   * @private
   * @type {boolean}
   */
  var ignore = false;

  /**
   * The known object, associated hash values with navigable popovers.
   *
   * @private
   * @type {object}
   */
  var known = {};

  /**
   * _isBack disabled the hash change function from pushing new hash values to the hashes array. _isBack is set to true
   * when using the back API method, and it is then reset to false from the hash change handler. It is worth noting
   * that as indicated in examples above _isBack is not set when using the browser back button.
   *
   * @private
   * @type {boolean}
   */
  var _isBack = false;

  // Update browser hash or read browser hash
  function hash(value){
    if (typeof value === 'string'){
      ignore = true;
      window.location.hash = value;
    }

    return window.location.hash || '';
  }

  // Push initial window hash
  hashes.push(hash());

  // Determines hash from popover name and timestamp, updates browser hash, hashchange will fire with ignore=true
  // Known updated with popover handle
  function forward(popover){
    var name = popover.name + '_' + A.now();
    known['#' + name] = popover;
    hash(name);
  }

  // Pop off the last hash from hashes array, navigate the browser back, hashchange will fire with _isBack=true
  function back(){
    if (hashes.length > 0){
      hashes.pop();
    }

    _isBack = true;
    window.history.back();
  }

  // There are four expected methods of reaching this hashchagne event
  // - forward API with ignore=true
  // - back API with _isBack=true
  // - browser back (nathanir@ - unclear why this is handled different than back API)
  // - browser forward
  $window.bind('hashchange', function(event){
    event.preventDefault();

    if (!_isBack) {
      hashes.push(hash());
    } else {
      _isBack = false;
    }

    // Keep only the last 32 hashes on the stack
    if (hashes.length >= 32){
      hashes.shift();
    }

    if (ignore){
      ignore = false;
      return;
    }

    // For navigation, the last hash value is used. In expected use cases this would be the same as hash()
    var currentHash = hashes[hashes.length - 1];
    var popover = known[currentHash];

    // Navigate to popover for back API, browser back, or browser forward
    A.trigger('a:popover:navigate', popover);
  });

  /**
   *  When a popover needs to alter the history stack, we alter the stack first
   *  and then we either show or hide the popover.
   *
   *  nathanir@ - This handling seems confusing. It would seem that showing a popover will always contribute to
   *  activeStack. This would mean simply opening nested popovers, and clicking back for each one, would cause
   *  unexpected behavior.
   *
   *  For example:
   *  Navigate to #a     | hashes state = ['', 'a']      |          | activeStack = ['a']
   *  Navigate to #b     | hashes state = ['', 'a', 'b'] |          | activeStack = ['a', 'b']
   *  Programmatic back  | hashes state = ['', 'a']      | show 'a' | activeStack = ['a', 'b', 'a']
   *  Programmatic back  | hashes state = ['']           | hide 'a' | activeStack = ['a', 'b'] (This would likely result in bug, leaving b open)
   */
  A.on('a:popover:navigate', function (popover) {
    if (popover) {
      // Navigating to a popover, based on last hash value in hashes array on navigable hash change
      // preventNavigate prevents recursive calls to forward API
      popover.show({preventNavigate: true});
    } else {
      // Navigating to no popover, based on empty hash value or hash that does not match known popover
      // The expected use case would be based on empty hash value

      // If any popovers in the active stack, hide the last one.
      var lastActive = activeStack.length - 1 >= 0 ? activeStack[activeStack.length - 1] : null;
      if (lastActive) {
        // preventNavigate prevents recursive calls to back API
        lastActive.unlock().hide({preventNavigate: true});
      }
    }
  });

  /**
   *  Push active stack when a new popover is opened
   *  and then we either show or hide the popover.
   *
   *  AUI-5884 attempted to narrow popover types that contribute to active stack. Unfortunately this broke cases
   *  that dependent on this side effect AUI-6393. A legacy event is provided until these dependencies can be resolved.
   */
  A.on('a:popover:showNavigable a:popover:showNavigableLegacy', function (event) {
    activeStack.push(event.popover);
  });

  /**
   *  Pop active stack when a new popover is opened
   *  and then we either show or hide the popover.
   *
   *  AUI-5884 attempted to narrow popover types that contribute to active stack. Unfortunately this broke cases
   *  that dependent on this side effect AUI-6393. A legacy event is provided until these dependencies can be resolved.
   */
  A.on('a:popover:hideNavigable a:popover:hideNavigableLegacy', function (event) {
    activeStack.pop();
  });

  return {
    forward : forward,
    back : back
  }
});
/////////////////////////
// END FILE js/mixins/popover_navigate.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_position.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Positioning code for AUI Popover

'use strict';

P.when('A', 'prv:a-capabilities').register('a-popover-position', function (A, privateCapabilities) {
  var undefined,
    $ = A.$,
    $window = $(window),
    $offsetTracker = null,
    TRIGGER_SPACING = 3,
    POPOVER_SPACING = 1,
    PADDING = 20,
    IS_IE_MOBILE = A.capabilities.mobile && privateCapabilities.isIE10Plus;

  P.when('prv:skin-vars-desktop').execute(function(vars){
    POPOVER_SPACING = (vars.popover.POPOVER_SPACING) ? vars.popover.POPOVER_SPACING : POPOVER_SPACING;
  });

  /**
   *  Insert a 1px DOM at (0,0). At the time when zooming happens, this DOM could
   *  provide offset information to fix the offset() function calls to other DOMs
   *
   *  @private
   *
   *  @return {object}  hash of top/left pixel values
   */

  function _getZoomOffset() {
    if (A.viewport().zoom === 1) {
      return {
        top: 0,
        left: 0
      }
    }
    // Lazy add offset tracker
    if (!$offsetTracker) {
      $offsetTracker = $('<span id="a-popover-offset-tracker"></span>');
      $("body").prepend($offsetTracker);
    }

    return $offsetTracker.offset();
  }

  /**
   *  A universal coordinate measurement function.  Returns window, popover, and trigger coordinates.
   *
   *  @public
   *  @param {DOM Node} $popover  The jQuery wrapped DOM Node for the popover
   *  @param {DOM Nods} $trigger  The jQuery wrapped DOM Node for the popover's trigger
   *
   *  @return {object}
   */

  function measure($popover, $trigger) {

    // Window dimensions
    var viewport = A.viewport();

    // Page zoom offset
    var zoomOffset = _getZoomOffset();

    // Trigger and Popover offset
    var  triggerOffset = $trigger.offset();
    var  popoverOffset = $popover.offset();

    // Fix: IE Mobile
    // In the IE Mobile webview, sometimes window.pageYOffset is incorrect. This problem traces all the way up to jQuery
    // where it uses window.pageYOffset to determine the scroll position of the webview. In *SOME, ONLY SOME* cases,
    // this value differs from document.documentElement.scrollTop, and in the cases where it does, it is incorrect and
    // the value from the document element is correct. Because popoverOffset and triggerOffset have their top values
    // calculated based on the window.pageYOffset value in jQuery, we want to take the final value and adjust it by the
    // difference of the two numbers.
    //
    // Without this code, the popover and tooltips can render themselves in the wrong positions, typically further down the
    // page than they should be by the exact amount of the difference between these two scroll values. In the browser
    // the values are always the same, so this code does not affect the values.
    if (IS_IE_MOBILE) {
      var offsetScrollDifferential = window.pageYOffset - document.documentElement.scrollTop;
      triggerOffset.top -= offsetScrollDifferential;
      popoverOffset.top -= offsetScrollDifferential;
    }

    // Fix: page zoom
    // When the page is zoomed the offset values are wrong. Fix that by subtracting the offset tracker.
    triggerOffset.top -= zoomOffset.top;
    triggerOffset.left -= zoomOffset.left;
    popoverOffset.top -= zoomOffset.top;
    popoverOffset.left -= zoomOffset.left;

    // Trigger and Popover dimensions
    var triggerDimensions = $trigger[0].getBoundingClientRect();

    var triggerWidth = triggerDimensions.right - triggerDimensions.left,
      triggerHeight = $trigger.outerHeight(),
      popoverWidth = $popover.outerWidth(true),
      popoverHeight = $popover.outerHeight(true);

    // Popover header dimensions
    var $popoverHeader = $popover.find(".a-popover-header");
    var headerHeight = $popoverHeader.length ? $popoverHeader.outerHeight(true) : 0;

    return {
      // Window
      windowWidth: viewport.width,
      windowHeight: viewport.height,
      windowTop: viewport.scrollTop,
      windowLeft: viewport.scrollLeft,
      windowRight: viewport.scrollLeft + viewport.width,
      windowBottom: viewport.scrollTop + viewport.height,

      // Zoom offset
      zoomTop: zoomOffset.top,
      zoomLeft: zoomOffset.left,

      // Trigger
      triggerWidth: triggerWidth + 1,
      triggerHeight: triggerHeight,
      triggerTop: triggerOffset.top - POPOVER_SPACING,
      triggerLeft: triggerOffset.left - POPOVER_SPACING,
      triggerRight: triggerOffset.left + triggerWidth + POPOVER_SPACING,
      triggerBottom: triggerOffset.top + triggerHeight + POPOVER_SPACING,
      triggerVerticalCenter: triggerOffset.top + (triggerHeight / 2),
      triggerHorizontalCenter: triggerOffset.left + (triggerWidth / 2),

      // Popover
      popoverWidth: popoverWidth,
      popoverHeight: popoverHeight,
      popoverTop: popoverOffset.top,
      popoverLeft: popoverOffset.left,
      popoverRight: popoverOffset.left + popoverWidth,
      popoverBottom: popoverOffset.top + popoverHeight,
      popoverVerticalCenter: popoverOffset.top + (popoverHeight / 2),
      popoverHorizontalCenter: popoverOffset.left + (popoverWidth / 2),

      // Popover header
      headerHeight: headerHeight
    }
  }

  /**
   *  Remove the CSS classes which place the arrow on the popover.
   *
   *  @private
   *  @param {DOM Node} $popover  The jQuery wrapped DOM node for the popover
   */

  function _clearPosition($popover) {
    return $popover.removeClass('a-arrow-top a-arrow-bottom a-arrow-left a-arrow-right');
  }

  /**
   *  Determine the CSS top property for popovers which are positioned horizontally (triggerLeft,
   *  triggerRight, triggerHorizontal)
   *
   *  @private
   *  @param {object} coords  The coordinates returned by the measure function
   *
   *  @return {object}  The generated properties object.
   */

  function _determineTopHorizontal(coords) {
    var position = {
      deltaTop: 0
    };
    var padding = 0;

    position.top = coords.triggerVerticalCenter - (coords.popoverHeight / 2);
    if (position.top < coords.windowTop + PADDING) {
      padding = Math.min(coords.windowTop + PADDING, coords.triggerTop - PADDING);
      position.deltaTop = position.top - padding;
      position.top = padding;
    } else if (position.top + coords.popoverHeight > coords.windowBottom - PADDING) {
      padding = Math.min(PADDING, coords.windowBottom - coords.triggerBottom + PADDING);
      position.deltaTop = (position.top + coords.popoverHeight) - (coords.windowBottom - padding);
      position.top = coords.windowBottom - padding - coords.popoverHeight;
    }

    return position;
  }

  /**
   *  Determine the CSS left property for popovers which are positioned vertically (triggerTop,
   *  triggerBottom, triggerVertical)
   *
   *  @private
   *  @param {object} coords  The coordinates returned by the measure function
   *
   *  @return {object}  The generated properties object.
   */

  function _determineLeftVertical(coords) {
    var position = {
      deltaLeft: 0
    };
    var padding = 0;

    position.left = coords.triggerHorizontalCenter - (coords.popoverWidth / 2);
    if (position.left < PADDING) {
      padding = Math.min(PADDING, coords.triggerLeft - PADDING);
      position.deltaLeft = position.left - padding;
      position.left = padding;
    } else if (position.left + coords.popoverWidth > coords.windowRight - PADDING) {
      padding = Math.min(PADDING, coords.windowRight - coords.triggerRight + PADDING);
      position.deltaLeft = (position.left + coords.popoverWidth) - (coords.windowRight - padding);
      position.left = coords.windowRight - padding - coords.popoverWidth;
    }

    return position;
  }

  var strategies = {
    // Window
    windowCenter: function (popover) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = measure($popover, $trigger),
        position = {};

      position.top = (coords.windowHeight - coords.popoverHeight) / 2;
      position.left = (coords.windowWidth - coords.popoverWidth) / 2;

      // Set top to 0 instead of a nice padding for each popover type to include its specific padding
      if (position.top < 0) {
        position.top = 0;
      }
      return position;
    },

    windowTop: function (popover) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = measure($popover, $trigger);
      var position = {};

      position.top = 0;
      position.left = (coords.windowWidth / 2) - (coords.popoverWidth / 2);

      return position;
    },

    windowFullWidth: function (popover) {
      return {
        top: 0,
        left: 0
      }
    },

    // Manual
    triggerRight: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineTopHorizontal(coords);  
      position.left = coords.triggerRight;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-right');
        $popover.find('.a-arrow-border').css('top', coords.popoverHeight / 2 + position.deltaTop);
      }

      return position;
    },

    triggerLeft: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineTopHorizontal(coords);
      position.left = coords.triggerLeft - coords.popoverWidth;
      position.left = (position.left > 0) ? position.left : 0;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-left');
        $popover.find('.a-arrow-border').css('top', coords.popoverHeight / 2 + position.deltaTop);
      }

      return position;
    },

    triggerTop: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineLeftVertical(coords);
      position.top = coords.triggerTop - coords.popoverHeight;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-top');
        $popover.find('.a-arrow-border').css('left', coords.popoverWidth / 2 + position.deltaLeft);
      }

      return position;
    },

    triggerBottom: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineLeftVertical(coords);
      position.top = coords.triggerBottom;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-bottom');
        $popover.find('.a-arrow-border').css('left', coords.popoverWidth / 2 + position.deltaLeft);
      }
      return position;
    },

    // Auto
    triggerHorizontal: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }
      var position = {};

      var triggerLeftSpace = coords.triggerLeft - coords.windowLeft;
      var triggerRightSpace = coords.windowRight - coords.triggerRight;

      // Put it on the side with more room
      return (triggerLeftSpace > triggerRightSpace) ? this.triggerLeft(popover, coords) : this.triggerRight(popover, coords);
    },

    triggerVertical: function (popover, inCoords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = inCoords ? inCoords : measure($popover, $trigger);
      var position = {};

      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;

      return (triggerTopSpace > coords.popoverHeight + PADDING) ? this.triggerTop(popover, coords) : this.triggerBottom(popover, coords);
    },

    triggerVerticalAlignLeft: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }
      var position = {};
      var delta = 0;
      var padding = 0;

      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;

      position.left = coords.triggerLeft;
      position.top = (triggerBottomSpace > coords.popoverHeight) ? coords.triggerBottom + TRIGGER_SPACING : coords.triggerTop - coords.popoverHeight - TRIGGER_SPACING;
      if (position.left < PADDING) {
        padding = Math.min(PADDING, coords.triggerLeft - PADDING);
        delta = position.left - padding;
        position.left = padding;
      } else if (position.left + coords.popoverWidth > coords.windowRight - PADDING) {
        padding = Math.min(PADDING, coords.windowRight - coords.triggerRight + PADDING);
        delta = (position.left + coords.popoverWidth) - (coords.windowRight - padding);
        position.left = coords.windowRight - padding - coords.popoverWidth;
      }

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass((triggerBottomSpace > coords.popoverHeight) ? 'a-arrow-bottom' : 'a-arrow-top');
        $popover.find('.a-arrow-border').css('left', coords.triggerWidth / 2 + delta);
      }
      return position;
    },

    /**
     * Custom Strategy by injection
     *
     * @public
     * @param {object} $popover
     * @param {object} $trigger
     * @param {object} func  The injected method that will be run to determine position
     *
     * @return {object}  top/left hash
     */
    customPosition: function (popover, func) {
      return func.call(this, {
        popover: popover,
        $popover: popover.$popover,
        $trigger: popover.$trigger,
        measure: measure
      });
    }
  };

  return strategies;
});
/////////////////////////
// END FILE js/mixins/popover_position.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/modal/common/modal_view_standard.js */
/**
 *  Modal view - standard
 *
 */

'use strict';

P.when('A', 'a-modal-view-base', 'a-modal-positions', 'a-popover-accessibility').register('a-modal-view', function (A, viewBase, positions, a11y) {
  var undefined,
    $ = A.$;

  var PADDING_NONE_CLASS = 'a-padding-none';

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

  /**
   *  Position strategy, and possibiliy before/after show/hide methods overrides
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var posStrategy = A.capabilities.touch || A.capabilities.mobile || A.capabilities.tablet || IS_LT_IE9 ? positions.innerScroll : positions.modalScroll;

  return A.extend(viewBase, posStrategy, {

    /**
     *  Skin function which determines the look of the modal.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {
      var id = popover.attrs("id");
      var header = popover.attrs("header") || "";
      var hideHeader = popover.attrs("hideHeader") || false;
      var footer = popover.attrs("footer");
      var modeless = popover.attrs('modeless') || false;
      var hasCloseButton = popover.attrs("closeButton");
      var closeButtonLabel = popover.attrs("closeButtonLabel") || '';
      var hideHeaderCloseButtonLayout = popover.attrs("hideHeaderCloseButtonLayout") || '';
      var popoverLabel = popover.attrs("popoverLabel") || '';
      var padding = popover.attrs("padding");
      var ariaDescription = popover.attrs("ariaDescription");
      var accesibilityParams = {
          id : id,
          header_str: header,
          label_str: popoverLabel,
          aria_description: ariaDescription
      };

      var ariaDescriptionHtml = a11y.getDescription(accesibilityParams);
      var popoverLabelHtml = a11y.getPopoverLabelHtml(accesibilityParams);

      // with hideHeaderCloseButtonLayout 'top', the close button layout will occupy top space of hideHeader modal.
      var closeButtonCssClass = hideHeaderCloseButtonLayout === 'top' ? ' a-modal-close-nohead-top' : ' a-button-top-right';
      // build the close button HTML if a close button was requested
      var closeButton = '<button data-action="a-popover-close" class="' + (!hasCloseButton ? ' a-button-close-a11y' : '') + ' a-button-close a-declarative' +
        // if the header is hidden and the close button is present, the close button will appear in the popover inner body and needs an extra class to position it
        (hideHeader ? (hasCloseButton ? closeButtonCssClass : ' a-button-a11y-top-right') : '') + '" aria-label="' + closeButtonLabel + '"><i class="a-icon a-icon-close"></i></button>';

      var headingHtml = '<h4 class="a-popover-header-content' + (modeless ? ' a-popover-draggable-handle' : '') + '" id="a-popover-header-' + id + '">' + header + '</h4>';

      // When header is present on modal, Modal heading, close button and popover label are placed together out of modal inner container
      // if header or popoverLabel present, close button, header and popoverLabel is wrapped with header
      // If modal header and popoverLabel both are not present, close button is not wrapped with header element to avoid extra noise of screen readers
      var headerWithAriaLabelAndCloseButton = (!hideHeader || popoverLabelHtml) ?
        '<header' + (hideHeader ? '' : ' class="a-popover-header"') + '>' + (hideHeader ?
          '' : headingHtml) + closeButton + popoverLabelHtml + '</header>' : closeButton;

      // Do not render footer if footer not set
      var footerStr = footer ? '<div class="a-popover-footer">' + footer + '</div>' : '';

      // If padding is none, add the a-padding-none class to a-popover-inner
      var paddingClass = (padding === 'none') ? " " + PADDING_NONE_CLASS : '';

      // offscreen element to trap keyboard focus on dialog.
      // a11y element should not be discoverable by user on Android devices.
      var startOffscreenHtml = A.capabilities.isAndroid ? "" : a11y.getStartAnchorSimplifiedHtml();
      var endOffscreenHtml = A.capabilities.isAndroid ? "" : a11y.getEndAnchorHtml(accesibilityParams);

      var modalScroller = modeless ? '' : '<div class="a-modal-scroller a-declarative" data-action="a-popover-floating-close">';
      var modalContainer = '<div class="a-popover a-popover-modal a-declarative' + (modeless ? ' a-modal-modeless' : ' ') + '" data-action="a-popover-a11y" aria-modal="true" role="dialog"' +
         a11y.getAriaLabelledByDescribedby(accesibilityParams) + '>';

      var modalWrapper = '<div class="a-popover-wrapper">';
      var modalInner = '<div class="a-popover-inner' + paddingClass + '" id="a-popover-content-' + id + '"></div>';
      var divCloseTag = '</div>';
      var modalScrollerCloseTag = modeless ? '' : '</div>';

      return modalScroller +
               modalContainer + // Build the modal div, add in modeless class if modeless dialog was requested
                 // offscreen element to trap keyboard focus on dialog.
                 startOffscreenHtml +
                 // Aria description html is placed out of modal wrapper to avoid extra noise of screen reader.
                 // VoiceOver, NVDA, JAWS announces banner if heading and popover label are not present in header.
                 // Screen readers don't consider aria description html text as part of heading html.
                 // This is why it is placed out of header
                 ariaDescriptionHtml +
                 // modal wrapper to wrap modal content and header
                 modalWrapper +
                 // Modal heading and close button and popover label are placed together
                 // When modal pops up and switches context from application to dialog,
                 // Screen reader announces Heading/popover label with focused Close button
                   headerWithAriaLabelAndCloseButton +
                   // modal inner content
                   modalInner +
                   footerStr + //
                 divCloseTag +
                 // offscreen element to trap keyboard focus on dialog.
                 endOffscreenHtml +
               divCloseTag +
             modalScrollerCloseTag;
    }
  });
});
/* Done importing js/modal/common/modal_view_standard.js */

/////////////////////////
// END FILE js/modal/modal_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_positions.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Modal position strategies
 *
 */

'use strict';

P.when('A', "a-popover-lightbox", 'a-popover-optional-helpers', 'prv:a-capabilities')
    .register('a-modal-positions', function (A, lgtbox, helpers, privateCapabilities) {
  var undefined;
  var $ = A.$;

  /**
   *  A flag to determine if this is a IE10+ mobile device for special handling for those devices
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_WIN_MOBILE = privateCapabilities.isIE10Plus && A.capabilities.mobile;

  /**
   *  Ratio of screen size that may be occupied by modal dialog before scrolling begins.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var SCROLL_THRESHOLD = 0.8;

  /**
   *  Ratio of screen size that may be used for left position and right padding when horizontal scroll is active.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var SCROLL_HORIZONAL_PADDING_RATIO = 0.05;

  var optionalButtonHeight = 0;
  P.when('prv:skin-vars').execute(function(vars) {
    optionalButtonHeight = vars.popover.optionalButtonHeight;
  });

  /**
   * Return measurements for popover maximum inner height.
   *
   * @public
   * @param {object} popover  popover instance
   * @return {Object}  maximum height value
   */
  function determineMaximumInnerHeight(popover) {
    var $popover = popover.$popover;

    // determine available height, multiply viewport by modal scrolling factor
    var maximumInnerHeight = A.viewport().height * SCROLL_THRESHOLD;

    // subtract header and footer height
    // only one of .a-popover-header or .a-modal-close-nohead-top will match
    var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
    var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;
    var maximumInnerHeight = maximumInnerHeight - headerHeight - footerHeight;

    return maximumInnerHeight;
  }

  /**
   * Return measurements for popover inner vertical padding.
   *
   * @public
   * @param {object} popover  popover instance
   * @return {Object}  inner vertical padding value
   */
  function determineInnerVerticalPadding(popover) {
    var $popover = popover.$popover;

    // subtract inner popover padding
    var $innerPopover = $popover.find('.a-popover-inner');
    var innerPopoverPadding = $innerPopover.outerHeight() - $innerPopover.height();

    return innerPopoverPadding;
  }

  /**
   * Enable modal scroll if popover is taller than 80% of viewport
   * requirement is to have 10% top/bottom when modal is scrollable
   *
   * @private
   *
   * @param {object} popover  popover instance
   */
  function _enableModalScroll(popover) {
    var $popover = popover.$popover;
    var $scroller = $popover.closest(".a-modal-scroller");

    //show scroller first for $popover height/width to be accurate
    $scroller.scrollTop(0).css("visibility", "visible");

    $scroller.bind("scroll", function () {
      popover.updateChildrenPosition();
    });
  }

  /**
   * Disable modal scroll
   *
   * @private
   *
   * @param {object} popover  popover instance
   */
  function _disableModalScroll(popover) {
    var $popover = popover.$popover,
      $scroller = $popover.closest(".a-modal-scroller");

    $scroller.css("visibility", "hidden").unbind("scroll");
  }

  /**
   * Special handling with lightbox dimension when win touch
   *
   * @private
   * @param {object} coords  measure result from popover_positions.js
   * @param {number} horizontalPadding  calculated padding from positionStrategy
   */
  function _adjustLightboxDimension(coords, horizontalPadding){
    var docHeight = $(document).height();
    var docWidth = $(document).width();
    var $lgtbox = $("#" + lgtbox.LIGHTBOX_ID);

    // Win mobile makes has DOM rendering issue AND having problem locking document,
    //    therefore trying our best to cover the entire document using position:absolute
    // We also want to ensure the lightbox area can cover the entire popover if
    //    the popover is wide, therefore the width logic below
    $lgtbox.css({
      "height": docHeight,
      "width": docWidth > coords.popoverWidth ? docWidth: coords.popoverWidth + horizontalPadding
    });
  }

  /**
   *  IE Tablet in landscape, in the modern app, positions things incorrectly when the on screen keyboard presents itself.
   *  Because we call this based on a guess, we still want to be sure that this could be the result of a keyboard showing, so
   *  Check the aspect ratio and make sure it's sufficiently large to suggest that may be the case. We can't be too aggressive
   *  and still be safe with this check as larger screens exist and the keyboard doesn't eat the entire screen in those systems.
   *  This safely covers all the tablets we have on hand though as they are 16:9 and end up being 32:9 with the keyboard open.
   *  That may not persist to the Surface Pro 3, and isn't a known constant for laptops, but >2 should be safe.
   *
   *  @private
   *  @param {number} pos
   */
  function _scrollToModalWithTextInput() {
    var viewport = A.viewport();

    if (viewport.width / viewport.height > 2) {
      A.delay(function() {
        document.activeElement.scrollIntoView();
        // Have gone through some attempts to make this more precise, but moving to the top of the screen guarantees it's fine
        // in all possible circumstances without creating a lot of flickering.
        window.scrollTo(window.pageXOffset, 0);
      }, 0);
    }
  }

  /**
   *  In general, a modal dialog will attempt to center itself in the viewport based on content size. This behavior will
   *  maintain until the modal dialog width exceeds the viewport width and a new strategy is used. The new strategy
   *  enforces a minimum horizontal padding to indicate to the user that scrolling or panning is available.
   *
   *  Example of rendering when popover exceeds width.
   *
   *  Viewport width: 400px
   *  Minimum horizonal padding: 20px (viewport width x SCROLL_HORIZONAL_PADDING_RATIO)
   *  Popover width: 500px
   *
   *  400px                       400px
   *  +----------------+          +----------------+
   *  |                |          |                |
   *  |20px(left)      |          |   20px(padding)|
   *  |   +------------+          +------------+   |
   *  |   |            |          |            |   |
   *  |   |            |          |            |   |
   *  |   |      500px |  => pan, | 500px      |   |
   *  |   |  (content-b|   scroll |ntent-box)  |   |
   *  |   |            |          |            |   |
   *  |   +------------+          +------------+   |
   *  |                |          |                |
   *  |                |          |                |
   *  +----------------+          +----------------+
   *
   *  @private
   *  @param {number} currentLeft - left as described above, provider by caller
   *  @param {number} minimumHorizonalPadding - horizontal padding as described above, provided by caller
   *  @param {function(object)} applyStylesFn - invoked with popover styles to apply
   *  @return {boolean} left should be reset to minimumHorizonalPadding by caller
   */
  function _applyHorizonalScrollStyles(currentLeft, minimumHorizonalPadding, applyStylesFn) {
    if (currentLeft < 0) {
      applyStylesFn({
        "padding-right": minimumHorizonalPadding + "px",
        // Preserve implicit width of popover
        "box-sizing": "content-box"
      });
      return true;
    } else {
      applyStylesFn({
        "padding-right": "",
        "box-sizing": ""
      });
      return false;
    }
  }
  // visible for testing
  P.declare('prv:a-model-applyHorizonalScrollStyles', _applyHorizonalScrollStyles);

  /**
   *  Simple binding helper for $.css function
   *
   *  @private
   *  @param {jQuery} $popover
   *  @return {function(object)} function invoked with popover styles to apply
   */
  function _defaultStylesFnProvider($popover) {
    return function(styles) {
      $popover.css(styles);
    };
  }

  var innerScroll = {
    /**
     *  For mobile devices (actually touch, mobile, tablet, and LT IE9), make a-popover-inner scrollable instead
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    positionStrategy: function (options) {
      var popover = options.popover;
      var $popover = options.$popover;
      var $trigger = options.$trigger;
      var $inner = $popover.find(".a-popover-inner").css("height", "auto");
      var $scroller = $popover.closest(".a-modal-scroller");
      var position = {};
      var viewport = A.viewport(true);
      var verticalPadding = viewport.height * 0.1;
      var horizontalPadding = viewport.width * SCROLL_HORIZONAL_PADDING_RATIO;
      var scrollThresholdHeight = viewport.height * SCROLL_THRESHOLD;

      // Resetting height, or ensuring popover height matches attrs
      var popHeight = popover.attrs("height");
      var popMinHeight = popover.attrs("min-height");
      $popover.css({
        "height": popHeight ? popHeight : "",
        "min-height": popMinHeight ? popMinHeight : ""
      });

      // Measure dimention after popover height is restored
      var coords = options.measure($popover, $trigger);

      position.left = (coords.windowWidth - coords.popoverWidth) / 2;

      if (_applyHorizonalScrollStyles(position.left, horizontalPadding, _defaultStylesFnProvider($popover))) {
        position.left = horizontalPadding;
      }

      var actualHeight = helpers.evaluateActualHeight(options, coords.popoverHeight, optionalButtonHeight);
      if (actualHeight > scrollThresholdHeight) {
        // only one of .a-popover-header or .a-modal-close-nohead-top will match
        var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
        var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;

        var offsetTop = verticalPadding;
        var delta = helpers.getOffsetTopDelta(options, offsetTop, optionalButtonHeight);
        var popoverHeight = scrollThresholdHeight - delta;
        offsetTop += delta;

        // If a modal is set with a height, there is a chance even if innerScroll
        //     the modal itself still needs to be scroll, which violates the
        //     meaning of this strategy, hence set a height on behave if that comes
        var innerHeight = popoverHeight - headerHeight - footerHeight;
        $inner.css({
          "height": innerHeight + "px",
          "overflow-y": "auto"
        });
        $popover.css({
          "height": popoverHeight,
          "min-height": 0
        });

        position.top = offsetTop;
      } else {
        position.top = (coords.windowHeight - coords.popoverHeight) / 2;
        $inner.css("height", "auto");
      }

      position.left += coords.zoomLeft;
      position.top += coords.zoomTop;

      if (IS_WIN_MOBILE) {
        // $scroller is position:absolute now, need to ensure his top is the
        //     scrollTop instead of 0 when position:static
        $scroller.css("top", $(window).scrollTop());

        // In theory we should only add a-popover-pan-x when popover width
        //     is larger then document width, however after some tests this is
        //     the only way to stop the background from scrolling, not even
        //     applying touch-action(none).
        // I believe that is a win phone bug, and for now, we add a-popover-pan-x
        //     for all cases and restrict lightbox width to document width or
        //     popover width, whatever which is larger.
        $popover.removeClass("a-popover-pan-y").addClass("a-popover-pan-x");

        _adjustLightboxDimension(coords, horizontalPadding);
      }

      /*
       * We have a problem with the Metro / Modern UI keyboard. We attempt to guess
       * if we're in Metro (no activeX) and then we rule out cases where the touch
       * keyboard will never display (machines without touch capability never show
       * the on screen keyboard even in Metro / Modern UI IE).
       *
       * This check isn't perfect, this could still run on the desktop version of
       * the client, but it should also be non-damaging to those platforms as we're
       * scrolling to the exact spot the viewport should already be in.
       */
      if (privateCapabilities.isMetroIEGuess && privateCapabilities.isIETouchCapable) {
        _scrollToModalWithTextInput();
      }

      return position;
    },

    beforeShowMethod: A.constants.NOOP,

    beforeHideMethod: A.constants.NOOP
  };

  var modalScroll = {
    /**
     *  Allow the modal dialog itself to be scrolled within the viewport for desktop.
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    // TODO [AUIQA-1172] is fixed for mobile only due to the initial root cause
    // is limited in mobile. However, if the limitation changes in the future
    // (i.e. launching SKY in desktop), we need to apply the fix to desktop, too.
    positionStrategy: function (options) {
      var $popover = options.$popover;
      var $trigger = options.$trigger;
      var $scroller = $popover.closest(".a-modal-scroller");
      var $inner = $popover.find(".a-popover-inner").css("height", "auto");
      if ($popover.hasClass("a-popover-modal-fixed-height")) {
        var $footer = $popover.find(".a-popover-footer")
        $inner.css("padding-bottom", $footer.height() + 15)
      }
      var position = {};
      var viewport = A.viewport(true);
      var viewportHeight = viewport.height;
      var viewportWidth = viewport.width;
      var verticalPadding = viewportHeight * 0.1;
      var horizontalPadding = viewportWidth * SCROLL_HORIZONAL_PADDING_RATIO;
      var scrollThresholdHeight = viewportHeight * SCROLL_THRESHOLD;
      // Need to get popover width/height without margin
      var popoverHeight = $popover.height();
      var popoverWidth = $popover.width();
      var coords = options.measure($popover, $trigger);

      position.left = (coords.windowWidth - popoverWidth) / 2;
      position.top = (coords.windowHeight - popoverHeight) / 2;

      if (_applyHorizonalScrollStyles(position.left, horizontalPadding, _defaultStylesFnProvider($popover))) {
        position.left = horizontalPadding;
      }

      if (popoverHeight > scrollThresholdHeight) {
        if ($scroller.length) {
          position.top = 0;

          $popover.css({
            "position": "relative",
            "margin": (coords.zoomTop + verticalPadding) + "px 0 " + verticalPadding + "px " + (coords.zoomLeft + position.left) + "px"
          });

          position.left = 0;

          // This bottom padding is needed to ensure that the bottom margin of the a-popover div actually creates
          // the necessary space between the bottom of the page and the bottom of the modal
          $scroller.css("padding-bottom", "1px");
        } else {
          if (popoverHeight > scrollThresholdHeight) {
            position.top = padding;
          }
        }
      } else {
        if ($scroller.length) {
          $popover.css({
            "position": "absolute",
            "margin": "0px"
          });
          $scroller.css("padding-bottom", "0px");
        }
      }

      position.left += coords.zoomLeft;
      position.top += coords.zoomTop;

      /*
       * We have a problem with the Metro / Modern UI keyboard. We attempt to guess
       * if we're in Metro (no activeX) and then we rule out cases where the touch
       * keyboard will never display (machines without touch capability never show
       * the on screen keyboard even in Metro / Modern UI IE).
       *
       * This check isn't perfect, this could still run on the desktop version of
       * the client, but it should also be non-damaging to those platforms as we're
       * scrolling to the exact spot the viewport should already be in.
       */
      if (privateCapabilities.isMetroIEGuess && privateCapabilities.isIETouchCapable) {
        _scrollToModalWithTextInput();
      }

      return position;
    },

    /**
     *  Add scroll effect before showing modal
     *
     *  @public
     */

    beforeShowMethod: function () {
      var popover = this;
      _enableModalScroll(popover);
    },

    /**
     *  Remove scroll effect before hiding modal
     *
     *  @public
     */

    beforeHideMethod: function () {
      var popover = this;
      _disableModalScroll(popover);
    }
  };

  return {
    innerScroll: innerScroll,
    modalScroll: modalScroll,
    util: {
      determineMaximumInnerHeight: determineMaximumInnerHeight,
      determineInnerVerticalPadding: determineInnerVerticalPadding
    }
  }
});
/////////////////////////
// END FILE js/modal/modal_positions.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Modal factory class
 *
 */

"use strict";

P.when('A', 'a-popover-base-factory', 'a-modal-view', 'a-popover-util', 'prv:a-capabilities').register('a-modal-factory', function (A, baseFactory, view, util, privateCapabilities) {
  var $ = A.$;
  var POPOVER_TYPE = "modal";
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = document.documentElement.className.indexOf("a-lt-ie9") > -1;

  var IS_WIN_MOBILE = A.capabilities.mobile && privateCapabilities.isIE10Plus;

  /**
   *  Create a new modal with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attributes) {
    // Disable modeless draggable modals in mobile or table mode as
    // the screen real estate is already small. It will use the regular
    // immersive modals instead
    var modeless = false, draggable = false;
    if (!(A.capabilities.mobile || A.capabilities.tablet)) {
      modeless = util.getBool(attributes.modeless);
      draggable = util.getBool(attributes.draggable);
    }
    
    var attributes = {
      modeless: modeless,
      draggable: draggable,
      type: POPOVER_TYPE,
      alone: true,
      immersive: true,
      position: 'windowCenter',
      header: attributes.header,
      hideHeader: attributes.hideHeader,
      footer: attributes.footer,
      padding: attributes.padding,
      width: attributes.width,
      height: attributes.height,
      "max-width": attributes["max-width"],
      "max-height": attributes["max-height"],
      "min-width": attributes["min-width"],
      "min-height": attributes["min-height"],
      closeButton: util.getBool(attributes.closeButton, true),
      timeout: attributes.timeout,
      lightboxOptions: modeless ? undefined :
          {
            lockScroll: true,
            showDuration: IS_LT_IE9 || IS_WIN_MOBILE ? 0 : null // fadeIn in <= IE8 makes ligthbos entirely black
          },
      //TODO SC-1333 adding back "data" as wish list is using it extensively.
      //     smetke@ has promised to remove the "data" related anchors on their Nov release for us to remove that.
      data: attributes.data || {},
      // Data sources
      dataStrategy: attributes.dataStrategy,
      url: attributes.url,
      manualRefresh: !! attributes.manualRefresh,
      ajaxFailMsg: attributes.ajaxFailMsg,
      cache: util.getBool(attributes.cache, true),
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      name: attributes.name,
      closeButtonLabel: attributes.closeButtonLabel ? attributes.closeButtonLabel : "Close",
      hideHeaderCloseButtonLayout: attributes.hideHeaderCloseButtonLayout,
      popoverLabel : attributes.popoverLabel,
      ariaDescription : attributes.ariaDescription,
      legacyNavigable: util.getBool(attributes.legacyNavigable, true)
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a modal, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  modal instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a modal dialog.  Delegates to the base factory.  Will remove the modal declarative action
   *  as well as the popover DOM nodes for the modal dialog itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/modal/modal_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Modal
 *
 */

'use strict';

P.when('A', 'a-modal-factory', 'a-popover-base', 'a-modal-handlers').register('a-modal', function (A, factory) {

  /**
   * Returning modal factory
   */
  return factory;
});
/////////////////////////
// END FILE js/modal/modal.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/base/popover_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Popover view - base class
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-animate').register('a-popover-view-base', function (A, util, animation) {
  var undefined,
    $ = A.$;

  return {

    /**
     * Update the aria-busy attribute for the overlay's wrapper element
     *
     * @public
     * @param {boolean} busy
     */
    setAriaBusy: function(busy) {
      this.$popover.find('.a-popover-wrapper').attr("aria-busy", busy);
    },

    /**
     *  Load content into the popover, use when create/update a popover
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-content').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-content').html("").append(content);
      }
    },

    /**
     *  Change the width and height of a popover
     *  Please make sure both the "off" and "on" cases are presented
     *
     *  @public
     *  @return {object}  DOM node
     */

    updateDimensions: function () {
      var popover = this;
      popover.$popover.css(util.getCSSHash(popover.attrs()));
      if (popover.isActive()) {
        popover.updatePosition();
      }
      return popover;
    },

    /**
     *  Get content wrapper of the popover
     *
     *  @public
     *  @return {object}  DOM node
     */

    getContent: function () {
      return this.$popover ? this.$popover.find('.a-popover-content') : null;
    },

    /**
     *  Overrides base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideMethod: function (triggerVisibilityChange) {
      var popover = this;
      animation.fadeOut(popover, 250, "linear", function() {
        // Reset the offset to ensure that the position is calculated correctly
        popover.$popover.css({
          "top": "auto",
          "left": "auto"
        });
        triggerVisibilityChange.call(popover);
      });
    }
  };
});
/////////////////////////
// END FILE js/popover/base/popover_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/common/popover_optional_helpers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

P.when('a-util').register('a-popover-optional-helpers', function(util) {
    'use strict';

    function getOffsetTopDelta(options, offsetTop, minOffsetTop) {
        minOffsetTop = parseFloat(minOffsetTop);
        var needAdjustment = util.isFiniteNumber(minOffsetTop) && minOffsetTop > 0;
        var hasVisibleCloseButton = options.$popover.find('.a-button-close').length &&
                                   !options.$popover.find('.a-button-close-a11y').length;
        // TODO options.popover.attrs('closeButton') should be fixed later
        var isTooSmallForButton = (offsetTop - minOffsetTop) < 0;

        if (needAdjustment && hasVisibleCloseButton && isTooSmallForButton) {
            return minOffsetTop - offsetTop;
        }
        return 0; // By default, no adjustment is needed
    }
    function evaluateActualHeight(options, baseHeight, buttonHeight) {
        var hasVisibleCloseButton = options.$popover.find('.a-button-close').length &&
                                   !options.$popover.find('.a-button-close-a11y').length;
        // TODO options.popover.attrs('closeButton') should be fixed later
        return hasVisibleCloseButton ? baseHeight + buttonHeight : baseHeight;
    }
    return {
        getOffsetTopDelta: getOffsetTopDelta,
        evaluateActualHeight: evaluateActualHeight
    }
});
/////////////////////////
// END FILE js/popover/common/popover_optional_helpers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/popover/common/popover_view_standard.js */
/**
 *  Popover view - standard
 *
 */

'use strict';

P.when('A', 'a-popover-view-base', 'a-popover-util', 'a-popover-accessibility').register('a-popover-view', function (A, viewBase, util, a11y) {

  var PADDING_NONE_CLASS = 'a-padding-none';

  var closeButtonEnabled = true;

  P.when('prv:skin-vars').execute(function (vars) {
    closeButtonEnabled = vars.popover.closeButtonEnabled;
  })

  function associateText(popoverOpeningLabel, closeButtonLabel) {
    return popoverOpeningLabel + " " + closeButtonLabel;
  }

  return A.extend(viewBase, {
    /**
     *  Skin function which determines the look of the popover.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {
      var id = popover.attrs("id");
      var header = popover.attrs("header");
      var hasCloseButton = closeButtonEnabled && popover.attrs("closeButton");
      var closeButtonLabel = popover.attrs("closeButtonLabel") || '';
      var popoverLabel = popover.attrs("popoverLabel") || '';
      var ariaDescription = popover.attrs("ariaDescription");
      var padding = popover.attrs("padding");
      var hasPopoverArrow = popover.attrs("popoverArrow");

      // accessibility parameters
      var accesibilityParams = {
          id : id,
          header_str: header,
          label_str: popoverLabel,
          aria_description: ariaDescription
      };

      // Android devices doesn't annouce popoverLabel/header when focus moves to close button
      if(A.capabilities.isAndroid) {
        closeButtonLabel = associateText(popoverLabel || header, closeButtonLabel);
      }

      var closeButtonStr = '<button data-action="a-popover-close" class="a-button-close ' + (!hasCloseButton ? 'a-button-close-a11y' : '') + ' a-declarative" aria-label="' + closeButtonLabel + '"><i class="a-icon a-icon-close"></i></button>';
      var hasHeader = !!header;
      var hasHeaderClass = hasHeader ? 'a-popover-has-header' : 'a-popover-no-header';

      // If padding is none, add the a-padding-none class to a-popover-inner
      var paddingClass = (padding === 'none') ? " " + PADDING_NONE_CLASS : '';
      var popoverArrowStr = hasPopoverArrow ? '<div class="a-arrow-border"><div class="a-arrow"></div></div>' : '';

      // offscreen element to trap keyboard focus on dialog.
      // a11y element should not be discoverable by user on Android devices.
      var startOffscreenHtml = A.capabilities.isAndroid ? "" : a11y.getStartAnchorSimplifiedHtml();
      var endOffscreenHtml = A.capabilities.isAndroid ? "" : a11y.getEndAnchorHtml(accesibilityParams);

      var headingHtml = header ? '<h4 class="a-popover-header-content" id="a-popover-header-' + id + '">' + header + '</h4>' : '';

      var popoverContainer = '<div class="a-popover ' + hasHeaderClass + ' a-declarative" data-action="a-popover-container a-popover-a11y" aria-modal="true" role="dialog"' +
          a11y.getAriaLabelledByDescribedby(accesibilityParams) + '>';
      var ariaDescriptionHtml = a11y.getDescription(accesibilityParams);
      var popoverLabelHtml = a11y.getPopoverLabelHtml(accesibilityParams);
      var popoverWrapper = '<div class="a-popover-wrapper">';

      // When header is present on popover, Popover heading, close button and popover label are placed together out of popover inner container
      var headerWithAriaLabelAndCloseButton = hasHeader ? '<header class="a-popover-header">' + headingHtml + closeButtonStr + popoverLabelHtml + '</header>' : '';
      var popoverInner = '<div class="a-popover-inner' + paddingClass + '">';

      // If popover header is not present, popover label and Close button wrapped with header element
      // voiceover on iOS doesn't announce popover label if label is not warpped in header element
      // If popover header and popover label both are not present, close button is not wrapped with header element to avoid extra noise of screen readers 
      var closeButtonWithPopoverLabelHtml = hasHeader ? '': (popoverLabelHtml ? '<header>' + closeButtonStr + popoverLabelHtml +  '</header>' : closeButtonStr);
      var popoverContentHtml = '<div class="a-popover-content" id="a-popover-content-' + id + '"></div>'; // It is important to have an additional div for content to prevent the button from being removed during content update

      return popoverContainer +
                // offscreen element to trap keyboard focus on dialog.
                startOffscreenHtml +
                // Aria description html is placed out of popover wrapper to avoid extra noise of screen reader.
                // VoiceOver, NVDA, JAWS announces banner if heading and popover label are not present in header.
                // Screen readers don't consider aria description hrml text as part of heading html.
                // This is why it is placed out of header
                ariaDescriptionHtml +

                // popover wrapper to wrap popover content and header
                popoverWrapper +

                  // When header is present on popover, Popover heading, close button and popover label are placed together out of popover inner
                  // When popover pops up and switches context from application to dialog,
                  // Screen reader announces Heading/popover label with focused Close button
                  headerWithAriaLabelAndCloseButton +
                  popoverInner +
                    // when popover header is missing, closed button and popover label are placed together inside popover inner
                    // Once popover pops up and switches context from application to dialog,
                    // Screen reader announces popover label with focused Close button
                    closeButtonWithPopoverLabelHtml +
                    // popover inner content
                    popoverContentHtml +
                  '</div>' +
                  popoverArrowStr +
                '</div>' +
                // offscreen element to trap keyboard focus on dialog.
                endOffscreenHtml +
             '</div>';
    }
  });
});
/* Done importing js/popover/common/popover_view_standard.js */

/////////////////////////
// END FILE js/popover/popover_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  This is a factory class for popovers, inheriting popover_factory
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-popover-view', 'a-popover-util').register('a-popover-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "popover",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Create a new popover with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attributes) {

    var attributes = {
      type: POPOVER_TYPE,
      alone: true,
      header: attributes.header,
      width: attributes.width,
      height: attributes.height,
      "max-width": attributes["max-width"],
      "max-height": attributes["max-height"],
      "min-width": attributes["min-width"],
      "min-height": attributes["min-height"],
      padding: attributes.padding,
      closeButton: util.getBool(attributes.closeButton, true),
      position: attributes.position || 'triggerVertical',
      activate: attributes.activate || 'onmouseover',
      timeout: attributes.timeout,
      //TODO SC-1333 adding back "data" as wish list is using it extensively.
      //     smetke@ has promised to remove the "data" related anchors on their Nov release for us to remove that.
      data: attributes.data || {},
      // Data sources
      dataStrategy: attributes.dataStrategy,
      url: attributes.url,
      manualRefresh: !! attributes.manualRefresh,
      ajaxFailMsg: attributes.ajaxFailMsg,
      cache: util.getBool(attributes.cache, true),
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      name: attributes.name,
      closeButtonLabel: attributes.closeButtonLabel ? attributes.closeButtonLabel : "Close",
      popoverLabel : attributes.popoverLabel,
      ariaDescription : attributes.ariaDescription,
      focusWhenShown: util.getBool(attributes.focusWhenShown, true),
      popoverArrow: util.getBool(attributes.popoverArrow, true),
      restoreFocusOnHide: util.getBool(attributes.restoreFocusOnHide, true)
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  popover instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a popover dialog.  Delegates to the base factory.  Will remove the popover declarative action
   *  as well as the popover DOM nodes for the popover itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }


  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/popover/popover_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations from popover view
 *
 */

'use strict';

P.when('A', 'a-popover-factory').register('a-popover-handlers', function (A, factory) {
  var $ = A.$;

  /**
   *  Teams are capable of delivering desktop assets to tablet and mobile devices
   *  detect this by checking mobile/tablet are not set (they are explicitly not when
   *  desktop assets are requested) and then confirm we're on iOS.
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IOS_WITH_DESKTOP_ASSETS = !(A.capabilities.mobile || A.capabilities.tablet) && A.capabilities.ios;

  /**
   * The delay between mouseenter and showing the popover.
   * Add a slight delay to handle the case where the user is quickly
   * moving the cursor past the trigger and not stopping on it.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_ENTER_DELAY = 200;

  /**
   * The delay between mouseleave and hiding the popover.
   * Add a slight delay to keep the popover open in case the user
   * accidentally moved the cursor outside the popover and back.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_LEAVE_DELAY = 250;

  /**
   * The maximum mouse velocity which will cause the popover to open.
   *
   * @private
   * @constant
   * @type {number}
   */
  var VELOCITY_THRESHOLD = 2;

  /**
   *  There's a delay between the event which causes the popover to be hidden
   *  and actually hiding it.  This will set the timer necessary to do that.
   *
   *  @private
   *  @param {object} popover
   */

  function _setDestroyTimer(popover) {
    if (popover && !popover.destroyTimer) {
      popover.destroyTimer = A.delay(function () {
        popover.hide();
      }, MOUSE_LEAVE_DELAY);
    }
  }

  /**
   *  After the destroy timer is set on a popover, it can be canceled
   *  by user actions.  This clears that timer.
   *
   *  @private
   *  @param {object} popover
   */

  function _clearDestroyTimer(popover) {
    if (popover) {
      clearTimeout(popover.destroyTimer);
      popover.destroyTimer = null;
      clearTimeout(popover.parent.destroyTimer);
      popover.parent.destroyTimer = null;
    }
  }

  /**
   * Show popover when click if activate attr === "onclick" or if we detect
   * that desktop assets are in use on iOS. See below if statement for context
   */
  A.declarative("a-popover", "click", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover) {
      popover.show();
      event.$event.preventDefault();
    }
  });

  /**
   * Show popover when enter is pressed
   */
  A.declarative("a-popover", "keydown", function(event) {
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;

    if (key === keycodes.ENTER || key === keycodes.SPACE) {
      // disable the behavior for "press space bar to page down"
      event.$event.preventDefault();

      factory.get(event.$declarativeParent).show();
    }
  });

  // iOS suspends part of the mouse-emulation event dispatch if certain things happen
  // in mouseenter and mousemove and create unexpected behavior where click events
  // don't dispatch. When we detect that desktop assets have been served to an iOS device
  // we want all popovers to be triggered by click for normalization purposes and
  // to not run any of the mouse handlers.
  // For more information, see: https://issues.amazon.com/issues/AUI-4632
  if (!IOS_WITH_DESKTOP_ASSETS) {
    /**
     * Open popover if cursor movement is slow or hover at target long enough
     */
    var openPopoverTimer;
    A.declarative("a-popover", "mouseenter", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _clearDestroyTimer(popover);

        //set open delay timer
        openPopoverTimer = A.delay(function () {
          popover = factory.get(event.$declarativeParent);

          // make sure popover still exists, $declarativeParent may have been removed
          if (popover) {
            popover.show();
          }
        }, MOUSE_ENTER_DELAY)
      }
    });

    A.declarative("a-popover", "mousemove", function (event) {
      if (A.cursor().speed < VELOCITY_THRESHOLD) {
        var popover = factory.get(event.$declarativeParent);

        if (popover && popover.attrs("activate") === "onmouseover") {
          popover.show();
        }
      }
    });

    A.declarative("a-popover", "mouseleave", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _setDestroyTimer(popover);

        //clear open delay timer
        if (openPopoverTimer) {
          clearTimeout(openPopoverTimer);
        }
      }
    });

    /**
     * Hide popover if it is not hovering on it for a duration
     */
    A.declarative("a-popover-container", "mouseenter", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _clearDestroyTimer(popover);
      }
    });

    A.declarative("a-popover-container", "mouseleave", function (event) {
      var popover = factory.get(event.$declarativeParent),
        setTimer = true,
        $relatedNode = $(event.$event.relatedTarget);

      if (popover && popover.attrs("activate") === "onmouseover" && popover.isActive()) {
        // If the mouse has moved into a child popover, then we shouldn't close this one
        A.each(popover.children, function (child) {
          if ($relatedNode.closest(child.$popover).length) {
            setTimer = false;
            return false;
          }
        });

        if (setTimer) {
          _setDestroyTimer(popover);

          // If the mouse has not moved back to the parent node, close it too
          if (!popover.parent.immersive && $relatedNode.closest(popover.parent.$popover).length === 0) {
            _setDestroyTimer(popover.parent);
          }
        }
      }
    });
  }
});
/////////////////////////
// END FILE js/popover/popover_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Popover
 *
 */

'use strict';

P.when('A', 'a-popover-factory', 'a-popover-base', 'a-popover-handlers').register('a-popover', function (A, factory) {

  /**
   * Returning popover factory
   */
  return factory;
});
/////////////////////////
// END FILE js/popover/popover.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/secondary_view/secondary_view_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Secondary view factory
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-secondary-view-view', 'a-popover-util').register('a-secondary-view-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "secondary-view",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  A boolean to determine if MASH object will load in the page. If mashWillLoad is false, use default fadeIn/fadeOut animation;
   *  If mashWillLoad is false, secondary view will be non-functional until the mash object is defined
   *
   *  @private
   *  @type {boolean}
   */
  var mashWillLoad = false;

  /**
   *  According to contract from MASH team, they will emit an inline script block thru its server-side API
   *  to register an empty "mash-will-load" module if mash should exist in the page.
   */
  P.when("mash-will-load").execute(function(){
    mashWillLoad = true;
  });

  /**
   *  Create a new secondary view with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger   jquery wrapped DOM of the trigger
   *  @param {object} attribute  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attrs) {
    attrs.disableAnimation = attrs.disableAnimation || A.capabilities.isOldAndroid;

    var attributes = {
      type: POPOVER_TYPE,
      immersive: true,
      disableAnimation: mashWillLoad || attrs.disableAnimation,
      synchronous: !! (mashWillLoad || (attrs.synchronous && attrs.synchronous !== "false")),
      animationLength: attrs.disableAnimation ? 0 : 300,
      alternateBackground: attrs.alternateBackground || false,
      hideHeader: mashWillLoad || attrs.hideHeader || false,
      scrollable: attrs.scrollable || true,
      header: attrs.header,
      backButtonText: attrs.backButtonText,
      position: 'windowFullWidth',
      timeout: attrs.timeout,
      // Data source
      dataStrategy: attrs.dataStrategy,
      inlineContent: attrs.inlineContent ? attrs.inlineContent : attrs.content,
      url: attrs.url,
      manualRefresh: !! attrs.manualRefresh,
      name: attrs.name,
      cache: attrs.cache === "false" || attrs.cache === false ? false : true,
      data: attrs.data || {},
      popoverLabel : attrs.popoverLabel,
      padding: attrs.padding,
      ariaDescription : attrs.ariaDescription,
      historyApi: attrs.historyApi === "true" || attrs.historyApi === true
    };
    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  secondary view instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    // Add data into popover. This needs to be done to support the secondary view being used by twister.  Don't remove.
    if (popover && typeof id === "object") {
      var id = $(id),
        $trigger = id.hasClass(DECLARATIVE_CLASS) ? id : id.find("." + DECLARATIVE_CLASS).eq(0),
        actionName = "a-" + POPOVER_TYPE,
        attributes = $trigger ? $trigger.data(actionName) : null;
      popover.data = attributes.data;
    }

    return popover;
  }

  /**
   *  Remove a secondary view.  Delegates to the base factory.  Will remove the secondary view declarative action
   *  as well as the popover DOM nodes for the secondary view itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/secondary_view/secondary_view_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/secondary_view/secondary_view_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Secondary View
 *
 */

'use strict';

P.when('A', 'a-secondary-view-factory', 'a-popover-base', 'a-secondary-view-handlers').register('a-secondary-view', function (A, factory) {

  /**
   * Returning secondary view factory
   */
  return factory;
});
/////////////////////////
// END FILE js/secondary_view/secondary_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/base/tooltip_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Tooltip overrides
 */

'use strict';

P.when('A', 'a-popover-animate').register('a-tooltip-view-base', function (A, animation) {
  var TOOLTIP_INNER = '.a-tooltip-inner';

  return {
    /**
     *  If a tooltip's contents need to be updated after it has been created, call this function.
     *
     *  @public
     *  @param {string|DOM Node} content
     */

    updateContent: function (content) {
      this.$popover.find(TOOLTIP_INNER).html(content);
    },

    /**
     *  Get content wrapper of the tooltip
     *
     *  @public
     *  @return {object}  DOM node
     */
    getContent: function () {
      return this.$popover ? this.$popover.find(TOOLTIP_INNER) : null;
    },

    /**
     *  Override base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideMethod: function (triggerVisibilityChange) {
      var popover = this;
      animation.fadeOut(popover, 250, "linear", function() {
        triggerVisibilityChange.call(popover);
      });
    }
  };
});
/////////////////////////
// END FILE js/tooltip/base/tooltip_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/tooltip/common/tooltip_view_standard.js */
/**
 *  Tooltip overrides
 */

'use strict';

P.when('A', 'a-tooltip-view-base').register('a-tooltip-view', function (A, viewBase) {
  return A.extend(viewBase, {
    /**
     *  Skin function which determines the look of the tooltip.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {

      var hasPopoverArrow = popover.attrs("popoverArrow");
      var popover_arrow_str = hasPopoverArrow ? '<div class="a-arrow-border"><div class="a-arrow"></div></div>' : '';

      return [
        '<div role="tooltip" class="a-popover a-tooltip a-declarative" data-action="a-popover-close">',
        '<div class="a-tooltip-inner"></div>',
        popover_arrow_str,
        '</div>'].join('');
    }
  });
});
/* Done importing js/tooltip/common/tooltip_view_standard.js */

/////////////////////////
// END FILE js/tooltip/tooltip_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Tooltip factory class
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-tooltip-view', 'a-popover-util').register('a-tooltip-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "tooltip",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Create a new tooltip with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */
  function create($trigger, attributes) {
    var attributes = {
      type: POPOVER_TYPE,
      name: attributes.name,
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      position: attributes.position || 'triggerVertical',
      activate: attributes.activate || 'onmouseover',
      popoverArrow: util.getBool(attributes.popoverArrow, true),
      restoreFocusOnHide: false
    };

    var tooltip = baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });

    // For accessibility, 'aria-describedby' attribute containing the id
    // of the tooltip element is added to the (focusable) trigger elements.
    // This enables screen readers to announce the content of the tooltip
    // when the trigger element is focused.

    // Known issue: Firefox on OSX with VoiceOver does not announce the
    // content of tooltips when link-based triggers are focused
    $trigger
      .add($trigger.children())
      .filter('a, input')
      .attr('aria-describedby', 'a-popover-' + $trigger.data("a-popover-id"));

    return tooltip;
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  tooltip instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a tooltip.  Delegates to the base factory.  Will remove the tooltip declarative action
   *  as well as the popover DOM nodes for the tooltip itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/tooltip/tooltip_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations from tooltip view
 *
 */

'use strict';

P.when('A', 'a-tooltip-factory').register('a-tooltip-handlers', function (A, factory) {
  var undefined,
    $ = A.$;

  /**
   * The delay between mouseleave and hiding the tooltip.
   * Add a slight delay to keep the tooltip open in case the user
   * accidentally moved the cursor outside the tooltip and back.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_LEAVE_DELAY = 125;

  /**
   * Open tooltip during click when activate attr === "onclick"
   */
  A.declarative("a-tooltip", "click", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onclick") {
      popover.show();
      event.$event.preventDefault();
    }
  });

  /**
   * Show tooltip during mouseover when activate attr === "onmouseover"
   */
  A.declarative("a-tooltip", "mouseenter", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onmouseover") {
      popover.show();
      if (popover.destroyTimer) {
        clearTimeout(popover.destroyTimer);
        popover.destroyTimer = null;
      }
    }
  });

  /**
   *  Hide tooltip when it is not hover for a duration
   *  There's a delay between the event which causes the tooltip to be hidden
   *  and actually hiding it.  This will set the timer necessary to do that.
   */
  A.declarative("a-tooltip", "mouseleave", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onmouseover") {
      popover.destroyTimer = A.delay(function () {
        popover.hide();
      }, MOUSE_LEAVE_DELAY);
    }
  });

  /**
   * Open tooltip during focus when activate attr === "onfocus"
   */
  A.declarative("a-tooltip", "focus focusin", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover) {
      popover.show();
    }
  });

  /**
   * Close tooltip when element focus is lost
   */
  A.declarative("a-tooltip", "blur focusout", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover) {
      popover.hide();
    }
  });

});
/////////////////////////
// END FILE js/tooltip/tooltip_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Tooltip
 *
 */

'use strict';

P.when('A', 'a-tooltip-factory', 'a-popover-base', 'a-tooltip-handlers').register('a-tooltip', function (A, factory) {

  /**
   * Returning tooltip factory
   */
  return factory;
});
/////////////////////////
// END FILE js/tooltip/tooltip.js
/////////////////////////

// END ASSET AmazonUIPopover@base-3.2.17177.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPopover@ready-control", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPopover@ready-control-3.2.17177.0
/////////////////////////
// BEGIN FILE js/data_strategies/popover_ajax_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-ajax-strategy', function (A, util) {
  var undefined,
    $ = A.$,
    AJAXFAILMSG = "Sorry, content is not available.",
    TIMEOUT = 10000,
    STRATEGY_NAME = "ajax";

  return {
    name: STRATEGY_NAME,

    reusePopover: false,

    loadContent: function (popover, isFirstRender) {
      popover.setContentLoading();
      var url = popover.attrs("url"),
        timeout = popover.attrs("timeout") || TIMEOUT,
        ajaxFailMsg = popover.attrs("ajaxFailMsg") || AJAXFAILMSG,
        cache = !! popover.attrs("cache"),
        spinnerTimer = popover.attrs("spinnerTimer"),
        ajaxHandler = popover.attrs("ajaxHandler");

      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");
      popover.attrs("content", null);

      // There is a requirement that when a popover is not initialized, any "content" changes done to ajax popovers will be removed, thus this rule
      if (content && !isFirstRender) {
        popover.updateContent(content);

        // Stop potential timers and XHRs
        if (spinnerTimer) {
          clearTimeout(spinnerTimer);
        }
        if (ajaxHandler && ajaxHandler.abort) {
          ajaxHandler.abort();
        }
      } else {
        var shouldProcessResponse = function() {
          return !popover.attrs("content")
              && popover.attrs("currentDataStrategy") === STRATEGY_NAME
              && (popover.isVisible() || popover.isActive());
        }

        // To prevent the spinner coming out for a split second for fast content,
        // that the spinner might flashes and scares users
        spinnerTimer = A.delay(function () {
          // Only process when the strategy and override doesn't change
          if (shouldProcessResponse()) {
            util.showSpinner(popover);
            popover.setAriaBusy(true);
          }
        }, 100);

        var updateContent = function(content, ajaxStatus, triggerContentLoaded) {
          // Only process when the strategy and override doesn't change
          // Don't update the content if the user closed the popover while the content was loading
          if (shouldProcessResponse()) {
            clearTimeout(spinnerTimer);
            popover.setContentLoaded();
            util.trigger(ajaxStatus, popover);
            popover.setAriaBusy(false);
            popover.update({'content' : content});

            if (popover.isActive()) {
              popover.updatePosition();
            }

            if (triggerContentLoaded) {
              util.trigger('ajaxContentLoaded', popover);
            }
          }
        }

        ajaxHandler = A.ajax(url, {
          type: 'GET',
          timeout: timeout,
          cache: cache,
          success: function (content) {
            updateContent(content, "ajaxSuccess", true);
          },

          error: function () {
            updateContent(ajaxFailMsg, "ajaxFail", false);
          }
        });

        popover.attrs({
          "spinnerTimer": spinnerTimer,
          "ajaxHandler": ajaxHandler
        });
      }
      return this;
    },

    unloadContent: function (popover) {
      util.clearContent(popover);
      return this;
    },

    shouldRefreshContent: function (popover) {
      return !popover.attrs("manualRefresh");
    },

    isValidStrategy: function (attributes) {
      return !!attributes.url;
    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_ajax_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/data_strategies/popover_inline_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-inline-strategy', function (A, util) {
  var undefined,
    $ = A.$;

  return {
    name: "inline",

    reusePopover: false,

    loadContent: function (popover) {
      popover.setContentLoading();
      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");

      if (content) {
        popover.attrs("content", null);
      }

      if (!content) {
        var $trigger = popover.$trigger;
        var actionName = $trigger.data("action");
        var data = $trigger.data(actionName) || {};
        content = data.inlineContent ? data.inlineContent : null;
      }

      if (!content) {
        content = popover.attrs("inlineContent");
      }

      popover.updateContent(content);
      popover.setContentLoaded();
      return this;
    },

    unloadContent: function (popover) {
      // Update the content on the trigger node to ensure any forced refresh
      // maintains the updated content
      var contentDOM = popover.getContent();
      var inlineContent = contentDOM && contentDOM.length > 0 ? contentDOM.html() : popover.attrs("inlineContent");
      var $trigger = popover.$trigger;
      var actionName = $trigger.data("action");
      var data = $trigger.data(actionName) || {};
      data.inlineContent = inlineContent;
      $trigger.data(actionName, data);

      // Now clear out whatever's there
      util.clearContent(popover);
      return this;
    },

    shouldRefreshContent: function (popover) {
      return popover.isDirty();
    },

    isValidStrategy: function (attributes) {
      // return true, as inline is the fallback of all strategies
      return true;
    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_inline_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/data_strategies/popover_preload_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-preload-strategy', function (A, util) {
  var undefined,
    $ = A.$;

  /**
   *  Search the DOM for preloaded content associated with the popover with a given name.
   *
   *  @private
   *  @param {string} name  popover name
   *
   *  @return {Document Fragment|false}  A document fragment containing the HTML for the popover content or false if content was not found
   */

  function _getPreloadContent(name) {
    var $preloadContent = $('#a-popover-' + name);
    $preloadContent.detach();

    if ($preloadContent.length) {
      // If we copy the HTML, then some style attributes like _margin-right will
      // be re-processed and removed by the browser.  Since we want to preserve
      // those, we'll need to move the entire DOM node as is.
      var contentDiv = $preloadContent[0];
      var fragment = document.createDocumentFragment();
      while (contentDiv.firstChild) {
        fragment.appendChild(contentDiv.firstChild);
      }
      return fragment;
    } else {
      return false;
    }
  }

  /**
   *  Get or create a preload div for a popover
   *
   *  @private
   *  @param {string} name  The name of the popover
   *
   *  @return {DOM node}  The preload div
   */

  function _getPreloadContentDiv(name) {
    var preloadName = 'a-popover-' + name;
    var $preloadContent = $('#' + preloadName);
    var preloadContent;

    // Use or create a preload DOM, reset content
    if (!$preloadContent.length) {
      preloadContent = document.createElement("div");
      preloadContent.id = preloadName;
      preloadContent.className = "a-popover-preload";
      document.body.appendChild(preloadContent);
    } else {
      preloadContent = $preloadContent[0];
    }
    return preloadContent;
  }

  /**
   *  Replace the contents of a popover preload div.
   *
   *  @private
   *  @param {DOM Node} div  The preload div
   *  @param {string|DOM Node}  The new content
   */

  function _replacePreloadContent(div, content) {
    if (typeof content === "string") {
      $(div).html(content);
    } else {
      var fragment = document.createDocumentFragment();
      while (content.firstChild) {
        fragment.appendChild(content.firstChild);
      }
      div.appendChild(fragment);
    }
  }

  /**
   *  Put(Move) the preload content back to "#a-popover-<name>", before the popover is removed
   *
   *  @private
   *  @param {string} name  popover name
   *  @param {object} popover
   */

  function _putPreloadContent(name, popover) {
    var $content = popover.getContent();

    // Do not process if the popover does not support getContent
    // or there is no content to unload
    if (!$content || !$content.html()) {
      return;
    }

    var preloadContent = _getPreloadContentDiv(name);

    // Add the existing content back to the preload div if the user hasn't updated the content
    var html = A.trim(preloadContent.innerHTML);
    if (!html) {
      _replacePreloadContent(preloadContent, $content[0]);
    }

    // Empty popover's content
    util.clearContent(popover);
  }

  return {
    name: "preload",

    reusePopover: true,

    loadContent: function (popover) {
      popover.setContentLoading();
      var name = popover.attrs("name");

      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");
      popover.attrs("content", null);

      // Even if we use content override, we still need to remove preload content in order not
      // to treat as new content, therefore we are getting(removing) content in preload div anyway
      var preloadContent = _getPreloadContent(name);

      if (content) {
        popover.updateContent(content);
      } else if (name) {
        popover.updateContent(preloadContent);
      }
      popover.setContentLoaded();
      return this;
    },

    unloadContent: function (popover) {
      var name = popover.attrs("name");
      if (name) {
        _putPreloadContent(name, popover);
      }
      return this;
    },

    shouldRefreshContent: function (popover) {
      var name = popover.attrs("name"),
        $preload = name ? $('#a-popover-' + name) : null;
      return !!($preload && $preload.length && $preload.html() !== "")
    },

    isValidStrategy: function (attributes) {
      // This strategy is valid if attr name exist and its popover preload content exists
      if (!attributes.name) {
        return false;
      }

      // Since we remove preload container when preload content is used,
      // if the current data strategy is preload, we can restreo the preload container div
      // thus preload is still a valid strategy
      if (attributes.currentDataStrategy === "preload") {
        return true;
      }

      var preloadName = 'a-popover-' + attributes.name;
      var $preloadContent = $('#' + preloadName);
      return !!$preloadContent.length;
    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_preload_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/dropdowns/dropdown/common/dropdown_handlers_common.js */
/**
 *  Events and delegations for Dropdowns
 *
 */

'use strict';

P.when("A", "a-dropdown-base", "a-dropdown-view", "a-dropdown-options", "a-dropdown-apis", "a-dropdown-base-factory", "a-dropdown-keyboard-handlers", "prv:a-tnr")
.register('a-dropdown-handlers', function (A, base, view, options, apis, factory, handlers, tnr) {
  var $ = A.$,
      $doc = $(document);

  var NATIVE_DROPDOWN_SELECTOR = "select.a-native-dropdown";

  /**
   *  Update the value of the dropdown with the value of a given item.
   *
   *  @this {HTMLElement}
   *  @private
   *  @param {Event} event
   */
  function _selectItem(event) {
    /*jshint validthis:true */
    event.preventDefault();
    tnr.ackDelegated(event);
    var $this = $(this);
    var popover = factory.get($this.closest(".a-popover"));

    if (!$this.hasClass("a-active")) {
      var value = $this.data("value").stringVal,
        $select = popover.sourceSelect;

      $select.val(value).trigger("change", [$this]);
    } else {
      popover.hide();
    }
  }

  /**
   *  Bind to the dropdown button's click event via the declarative API
   */
  A.declarative("a-dropdown-button", "click", function (event) {
    var $select = options.getSelectFromButton(event.$target);
    $select.trigger('click');
  });

  /**
   * Binds keydown event to native dropdown to open dropdown options using UP, DOWN ARROW, SPACE KEY and ENTER key.
   * @param  {[type]} event
   */
  $doc.delegate(NATIVE_DROPDOWN_SELECTOR, "keydown", function (event) {
    tnr.ackDeclarative(event);
    var keycodes = A.constants.keycodes;
    var key = event.which;
    var $button = $(event.target).nextAll('.a-button-dropdown').eq(0);
    if (A.onScreen($button) && (key === keycodes.UP_ARROW || key === keycodes.DOWN_ARROW || key === keycodes.ENTER || key === keycodes.SPACE)) {
      var elem = $(event.target);
      elem.prop('disabled', true);
      A.delay(function() {
        elem.prop('disabled', false);
      }, 0);
      event.preventDefault ? event.preventDefault() : (event.returnValue = false);
      base.showDropdown(event, A.extend({
        $button: $button
      }, options), view);
    }
  });

  /**
   * Binds click event to native dropdown to open dropdown.
   * @param  {[type]} event
   */
  $doc.delegate(NATIVE_DROPDOWN_SELECTOR, "click", function (event) {
    tnr.ackDeclarative(event);
    event.preventDefault ? event.preventDefault() : (event.returnValue = false);
    var $button = $(event.target).nextAll('.a-button-dropdown').eq(0);
    if(A.onScreen($button)) {
      base.showDropdown(event, A.extend({
        $button: $button
      }, options), view);
    }
  });

  // Handle user selecting an item in the popover with a mouse
  // and gets triggered by SPACE key event handler.
  // TODO make selector more efficient
  $doc.delegate(".a-popover.a-dropdown a", "click", _selectItem);

  if (handlers) {
    // Keyboard navigation
    if (handlers.keyDown) {
      $doc.delegate(".a-dropdown li", "keydown", handlers.keyDown);
    }
    if (handlers.keyPress) {
      $doc.delegate(".a-dropdown li", "keypress", handlers.keyPress);
    }
  }
});
/* Done importing js/dropdowns/dropdown/common/dropdown_handlers_common.js */

/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_data.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util', 'a-popover-inline-strategy', 'a-popover-preload-strategy', 'a-popover-ajax-strategy').register('a-popover-data', function (A, util, inlineDataStrategy, preloadDataStrategy, ajaxDataStrategy) {
  var undefined;
  var $ = A.$;

  /**
   *  List of strategies ordered by priority
   *
   *  @public
   *  @type {array}
   */
  var STRATEGIES = [ajaxDataStrategy, preloadDataStrategy, inlineDataStrategy];

  /**
   *  Determine which strategy to use according to income popover attributes
   *  Since users does not specify which data strategy to use up front for history
   *    reason, this function helps guessing which strategy application wants to use
   *    by checking which attribute the popover contains.
   *
   *  @public
   *
   *  @param attributes  hash of attrs of the popover
   *  @return dataStrategyObject
   */

  function guessStrategyByAttrs(attributes) {
    for(var i=0, j=STRATEGIES.length; i<j; i++) {
      var strategy = STRATEGIES[i];
      if (strategy.isValidStrategy(attributes)){
        return strategy;
      }
    }
  }

  /**
   *  Get strategy object by strategy name
   *
   *  @public
   *
   *  @param name  name of the strategy
   *  @return {object}
   */

  function getStrategyByName(name){
    for(var i=0, j=STRATEGIES.length; i<j; i++) {
      var strategy = STRATEGIES[i];
      if (strategy.name === name){
        return strategy;
      }
    }
    return null;
  }

  return {
    guessStrategyByAttrs: guessStrategyByAttrs,
    getStrategyByName: getStrategyByName,
    showSpinner: util.showSpinner
  }
});
/////////////////////////
// END FILE js/mixins/popover_data.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_lightbox.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  A simple generic lightbox for dropdowns and modals
 */

'use strict';

P.when('A', 'a-popover-lightbox-markup', 'a-timing-analytics', 'prv:a-capabilities', 'ready')
    .register('a-popover-lightbox', function (A, markup, timingAnalytics, privateCapabilities) {
        /* Importing js/mixins/popover_lightbox_code.js */
  var $ = A.$;
  var htmlClass = document.documentElement.className;
  var IS_IE = htmlClass.indexOf("-ie") > -1;
  var IS_WIN_PHONE = privateCapabilities.isIE10Plus && A.capabilities.mobile;
  var IS_ANDROID_4 = (A.capabilities.androidVersion + "").indexOf("4.") === 0;
  var IS_UC_BROWSER = privateCapabilities.isUCBrowser;
  var LIGHTBOX_ID = markup.id;
  var LIGHTBOX_DIV = markup.div;
  var clicksKilled = false;
  var $body = $('body');

  // Parameters to control the polling interval and attempts for an iOS8 hacks
  var IOS8_SCROLLBACK_INTERVAL = 200;
  var IOS8_SCROLLBACK_ATTEMPTS = 5

  /**
   *  Lightbox lock levels
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1,
    LOCK_USER = 10,
    LOCK_UNLOCK = -1;

  /**
   *  Default duration of the fadein effect for lightbox
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LIGHTBOX_FADEIN_DURATION = 200;

  /**
   *  Default duration of the fadeout effect on hide
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LIGHTBOX_FADEOUT_DURATION = 250;

  /**
   *  Lightbox DOM object, will create on demand
   *
   *  @private
   *  @type {object}
   */
  var $lgtbox = null;

  /**
   *  We might need to kill the timer which fully hides the lightbox after touchend, so
   *  keep track of that here.
   *
   *  @private
   *  @type {boolean}
   */
  var clickThroughTimer = 0;

  /**
   *  This is a soft lock which prevents hiding the lightbox
   *
   *  @private
   *  @type {integer}
   */
  var _lock_level = LOCK_UNLOCK;

  /**
   *  A value to restore the scrollTop/scrollLeft if lockScroll messed with heights
   *  Useful especially for IE6
   *
   *  @private
   *  @type {integer}
   */

  var _scrollTop = -1;
  var _scrollLeft = -1;

  /**
   *  The popover instance floating above lightbox.
   *  If option.popover is included in the show() method, the z-index of the lightbox will be adjusted properly.
   *  Lightbox will close the floating popover when this is specified as well.
   */
  var _floatingPopover = null;

  /**
   *  Allow binding to an event and stopping it in its tracks.
   *
   *  @return {boolean} false
   */
  function _killClicks(event) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    return false;
  }

  /**
   *  Stop all clicks on the body during the capture phase.
   */
  function _stopClicks() {
    $body.bind('click', _killClicks);
      P.when('a-event-analytics').execute(function (ea) {
          ea.notifyJquery($body, 'click');
      });
    clicksKilled = true; // Prevent double clicks from causing issues.
  }

  /**
   *  Allow clicks to propogate down to the children of the body.
   */
  function _allowClicks() {
    $body.unbind('click', _killClicks);
    clicksKilled = false;
  }

  /**
   *  Show black lightbox
   *
   *  @public
   *  @param {object} options
   *                          {popover} popover  the popover instance that floats on top of the lightbox
   *                          {boolean} lockScroll  whether page scroll should be locked
   *                          {number} showDuration  lightbox fadein animation duration
   */

  function show(options) {
    $('#a-page').attr('aria-hidden', 'true');

    var $window = $(window);

    if (!$lgtbox) {
      // Lazy add lightbox dix
      $('body').append(LIGHTBOX_DIV);
      $lgtbox = $("#" + LIGHTBOX_ID);
    }

    options = options || {};

    // Prevent the user from closing the modal while it is animating
    _stopClicks();

    if (options.lockScroll) {
      // Store scroll top temporarily to restore later, only respect the first set
      if (_scrollTop === -1) {
        _scrollTop = $window.scrollTop();
        _scrollLeft = $window.scrollLeft();
      }

      // Set margin-right with !important to override the css class !important in site-wide css
      A.setCssImportant($("body"), "margin-right", A.scrollBarWidth() + "px");

      // Explicitly filter out windows phone here as applying overflow hidden causes
      // a page-level overscroll but the measured offset is just shifting for 1px
      if (!IS_WIN_PHONE) {
        // Prevent page from scrolling. Scrollbar in IE is in <html>, however, adding
        // overflow hidden to FF/chrome jumps the page to top. Therefore only apply
        // overflow hidden to IE
        if (IS_IE) {
          $("html, body").css("overflow", "hidden");
        } else {
          $("body").css("overflow", "hidden");
        }
      }
    }

    _floatingPopover = options.popover || null;
    var zindex = _floatingPopover ? _floatingPopover.$popover.css("z-index") - 2 : -1; //for some reason, -1 will cause page overscrolling in dropdown
    if (zindex > 0) {
      $lgtbox.css("z-index", zindex);
      // A Samsung S4 Android 4.4.2 stock browser refuses to repaint the z-index
      // change without a kick in the pants. The Interwebs suggested reading an
      // element size, and it does seem to work. Using $window since we already
      // have it. Limiting devices, to protect old buggy browsers. See sim/AUI-2519
      if (IS_ANDROID_4) {
         $window.width();
      }
    }

    // Add default duration
    if (typeof options.showDuration !== "number") {
      options.showDuration = LIGHTBOX_FADEIN_DURATION;
    }

    /*
      UC Browser has an issue with displaying popovers (modals, specifically).
      A current workaround is to apply overflow: auto to the modal which forces
      the browser to display it. This sniffs for the browser and applies the fix.

      More info:
      https://w.amazon.com/index.php/UC_Browser_Issues_%26_Resolutions
    */
    if(IS_UC_BROWSER) {
      _floatingPopover.$popover.css('overflow', 'auto');
    }

    if (options.showDuration > 0) {
      A.fadeIn($lgtbox, options.showDuration);
    } else {
      $lgtbox.css("display", "block");
    }

    A.delay(_allowClicks, options.showDuration + 300);
  }

  /**
   * Hide black lightbox
   *
   * @public
   * @param {object} options
   *                          {number} hideDuration  lightbox fadein animation duration
   *                          {boolean} lockScroll  whether page scroll should be loc
   */

  function hide(options) {
    var $window = $(window);

    // Cannot hide if the lightbox is locked
    if (_lock_level > LOCK_UNLOCK) {
      return;
    }

    // Require lightbox DOM
    if (!$lgtbox) {
      return;
    }

    options = options || {};

    // Prevent the user from closing the modal while it is animating
    _stopClicks();

    // Add default duration
    if (typeof options.hideDuration !== "number") {
      options.hideDuration = LIGHTBOX_FADEOUT_DURATION;
    }

    if (options.hideDuration > 0) {
      A.fadeOut($lgtbox, options.duration, "linear", function () {
        if (options.lockScroll) {
          // Enable page scrolling
          $("html, body").css("overflow", "");
          $("body").css("margin-right", "");

          // Restore scrollTop (especially for IE6)
          // Add A.delay as IE11 on tablet can only be scrolled when animation is completely done
          A.delay(function() {
            if (_scrollTop > 0) {
              $window.scrollTop(_scrollTop);
              _scrollTop = -1;
            }
            if (_scrollLeft > 0) {
              $window.scrollLeft(_scrollLeft);
              _scrollLeft = -1;
            }
          }, 100);
        }

        // Reset floating popover
        _floatingPopover = null;
      });
    } else {
      $lgtbox.css("display", "none");

      if (options.lockScroll) {
        // Enable page scrolling
        $("html, body").css("overflow", "");
        $("body").css("margin-right", "");

        // Restore scrollTop (especially for IE6)
        if (_scrollTop > 0) {
          $window.scrollTop(_scrollTop);
          _scrollTop = -1;
        }
      }

      // Reset floating popover
      _floatingPopover = null;
    }

    // There are occasions that we are changing the width and height of the
    //     lightbox, that might impact after document width/height calculation
    //     resetting the height/width here
    $lgtbox.css({
        "height": "",
        "width": ""
    });

    // Wait for a bit, then allow clicks to be generated again.
    A.delay(_allowClicks, options.hideDuration + 350);

    $('#a-page').removeAttr('aria-hidden');
  }

  /**
   *  Set current lock level, higher the more powerful
   *
   *  @public
   *  @param {integer} lockLevel
   *
   *  @return {object}  lightbox instance
   */

  function lock(lockLevel) {
    //assume a user lock if lock level is not set
    if (!lockLevel) {
      lockLevel = LOCK_USER;
    }
    if (_lock_level < lockLevel) {
      _lock_level = lockLevel;
    }
  }

  /**
   *  Remove lock if lockLevel is high enough
   *
   *  @public
   *  @param {integer} lockLevel
   *
   *  @return {object}  lightbox instance
   */

  function unlock(lockLevel) {
    //assume a user lock if lock level is not set
    if (!lockLevel) {
      lockLevel = LOCK_USER;
    }
    if (_lock_level <= lockLevel) {
      _lock_level = LOCK_UNLOCK;
    }
  }

  /**
   *  Does nothing when lightbox is clicked to avoid unintentional clicks
   */
  $(document).delegate("#" + LIGHTBOX_ID, "click " + A.action.start + " " + A.action.move, function (event) {
    event.preventDefault();
  });

  /**
   *  Handle closing the current popover floating on top of lightbox when lightbox/a-modal-scroller
   *  is clicked or tapped.
   */
  A.declarative('a-popover-floating-close', A.capabilities.touch ? A.action.end : "click", function (event) {
    // Only executes when the target immediately has the a-popover-floating-close action
    if (!clicksKilled && event.$target.data("action") && event.$target.data("action").indexOf("a-popover-floating-close") > -1) {
      // Only close the floating popover if it is completely shown
      if (_floatingPopover && _floatingPopover.isActive()) {
        /*
         *  Clicking or tapping especially on the modal scroller and/or lightbox is a strong
         *  indictation that the user wants to close the popover. Therefore we will unlock it in
         *  the highest lock level.
         */
        _floatingPopover.unlock().hide();
        event.$event.preventDefault();
      } else {
        // we've managed to get into a state where the lightbox is open but there's no popover
        // probably want to hide the lightbox
        hide();
      }
    }
  });

  /**
   * In iOS8, upon orientation change of dropdown/modal, the scrollTop of the window might scroll off the
   * intended positon and leaves a (large) portion of white in the screen with the dropdown/model shifted offscreen.
   * We are implementing this workaround to catch the timing when the orientation change animation is done and scroll
   * the page to align with the dropdown/modal.  The polling is needed, as the scroll will not happen until the
   * orientation change animation is done.
   */
  if (privateCapabilities.isiOS8) {
    A.on("a:popover:afterUpdatePosition", function(data){
      var popover = data.popover;
      var $lightboxDom = $('#'+LIGHTBOX_ID);
      var lightboxTop = $lightboxDom.length ? $lightboxDom.offset().top : -1;
      var $window = $(window);
      var counter;
      var trial;

      // Only start when the popover is active and it has ligthbox
      if(popover.isActive() && popover.attrs("lightboxOptions") && lightboxTop) {
        counter = 0;
        trial = setInterval(function() {
          // Apparently during the animation stage, getting $window.scrollTop will give us
          // our desired value without actually fulfilling it, therefore we are literally
          // setting scrollTop five times to ensure the right scrollTop is set.
          // I like iOS less...
          $window.scrollTop(lightboxTop);
          if(++counter > IOS8_SCROLLBACK_ATTEMPTS) {
            clearInterval(trial);
          }
        }, IOS8_SCROLLBACK_INTERVAL);
      }
    });
  }

  timingAnalytics.stopWidgetLogging('dropdown');
  return {
    show: show,
    hide: hide,
    lock: lock,
    unlock: unlock,
    LIGHTBOX_ID: LIGHTBOX_ID
  }
/* Done importing js/mixins/popover_lightbox_code.js */

    });
/////////////////////////
// END FILE js/mixins/popover_lightbox.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Util for AUI Popover
 */

'use strict';

P.when('A').register('a-popover-util', function (A) {
  var $ = A.$;
  var undefined;
  var SPINNER = '<div class="a-popover-loading-wrapper a-text-center"><div class="a-box a-color-base-background a-popover-loading"></div></div>';


  /**
   *  The class defined as a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  A regular expression used to test whether or not a string is numeric.
   *
   *  @private
   *  @type {RegExp}
   */
  var NUMERIC = /^-?\d+(?:\.\d+)?$/;

  /**
   *  Determines if the first DOM node is a child of the second.
   *
   *  @private
   *  @param {DOM node} $target
   *  @param {DOM node} $node
   *
   *  @return {boolean}
   */

  function _isChild($target, $node) {
    return $target.closest($node).length > 0;
  }

  /**
   *  Do a depth-first search of the popover tree for popovers which causes the supplied condition
   *  function to return true.
   *
   *  @public
   *  @param {object} node  The root popover for this search
   *  @param {function} condition  A function which accepts a popover and returns a boolean
   *
   *  @return {undefined|object} popover
   */

  function search(node, condition) {
    var i = node.children.length;
    while (i--) {
      var found = search(node.children[i], condition);
      if (found) {
        return found;
      }
    }

    if (condition(node)) {
      return node;
    }
  }

  /**
   *  Determines whether or not the provided event occured within a given popover
   *
   *  @public
   *  @param {object} event
   *  @param {object} popover
   *
   *  @return {boolean}
   */

  function occursWithinPopover(event, popover) {
    var $target = $(event.target);

    return _isChild($target, popover.$trigger) || _isChild($target, popover.$popover);
  }

  /**
   *  Trigger a properly namespaced popover event
   *
   *  @public
   *  @param {string} eventName
   *  @param {object} popover
   *
   *  trigger a:popover:<eventName>
   *  trigger a:popover:<eventName>:<popover.name>
   */

  function triggerEvent(eventName, popover) {
    A.trigger('a:popover:' + eventName, {
      'popover': popover
    });

    if (popover.name) {
      A.trigger('a:popover:' + eventName + ':' + popover.name, {
        'popover': popover
      });
    }
  }

  /**
   *  Check if the dom has declarative action of a popover, if yes, return its attributes
   *
   *  @public
   *  @param {object} dom
   *  @param {string} type  popover type
   *
   *  @return {object} hash of info from declarative action
   */

  function extractDeclarativeParams(dom, type) {
    var $dom = $(dom),
      $trigger = $dom.hasClass(DECLARATIVE_CLASS) ? $dom : $dom.find("." + DECLARATIVE_CLASS).eq(0),
      actionName = "a-" + type,
      actionData = $trigger.data('action'),
      validDeclarAction = (actionData && A.contains(actionData, actionName));

    if (validDeclarAction) {
      return {
        attributes: $trigger.data(actionName) || null,
        $trigger: $trigger
      }
    } else {
      return null;
    }
  }

  /**
   *  If a CSS parameter is a number or a numeric string, assume pixels and add "px"
   *  to the property.
   *
   *  @private
   *  @param {object} attr
   *
   *  @return {string}
   */
  function getProperty(attr) {
    if (A.isFiniteNumber(attr) || NUMERIC.test(attr)) {
      attr += "px";
    }
    return attr;
  }

  /**
   *  Take the popvoer attributes hash and pull out all the CSS attributes.
   *
   *  @public
   *  @param {object} hash
   *
   *  @return {object}
   */
  function getCSSHash(hash) {
    var css = {};
    A.each(["height", "width", "max-height", "max-width", "min-height", "min-width"], function (attr) {
      if (hash[attr]) {
        css[attr] = getProperty(hash[attr]);
      }
    });
    if (css.height && !css["max-height"]) {
      css["max-height"] = "none";
    }
    if (css.width && !css["max-width"]) {
      css["max-width"] = "none";
    }
    return css;
  }

  /**
   *  Clear content area to standardize the unload operation
   *
   *  @private
   *  @param {object} popover
   */

  function clearContent(popover) {
    var $content = popover.getContent();
    if ($content) {
      $content.empty();
    }
  }

  /**
   * Simply show the spinner logo
   *
   * @public
   * @param {object} popover  popover instance
   *
   * @return {object} popover instance
   */

  function showSpinner(popover) {
    popover.updateContent(SPINNER);
    popover.updatePosition();

    return popover;
  }

  /**
   *  helper function to parse string/boolean true/false value and return the corresponding boolean value
   *
   *  @public
   *  @param {string|boolean} val
   *  @param {boolean} defaultVal  Default value if val is not defined. Default is false.
   *
   *  @return {boolean} true/false
   */

  function getBool(val, defaultVal) {
    return (val !== undefined) ?
        (val === true || val === 'true') : defaultVal === true;
  }

  return {
    trigger: triggerEvent,
    extractDeclarativeParams: extractDeclarativeParams,
    eventOccursWithin: occursWithinPopover,
    search: search,
    getCSSHash: getCSSHash,
    clearContent: clearContent,
    showSpinner: showSpinner,
    getBool: getBool
  };
});
/////////////////////////
// END FILE js/mixins/popover_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/modal/common/modal_handlers_standard.js */
/**
 * Modal desktop event handlers
 *
 */

"use strict";

P.when('A', 'a-popover-base-factory', 'a-modal-factory', 'ready').register('a-modal-handlers', function (A, baseFactory, factory) {
    var undefined,
        $ = A.$,
        POPOVER_TYPE = "modal";

    /**
     * Show modal when click
     */
    A.declarative('a-modal', 'click', function (event) {
        factory.get(event.$declarativeParent).show();
        event.$event.preventDefault();
    });

    /**
     *  Does nothing when a-modal-scroller is clicked directly to avoid unintentional clicks
     */

    $(document).delegate(".a-modal-scroller", "click " + A.action.start + " " + A.action.move, function (event) {
        if (event.target === this) {
            event.preventDefault();
        }
    });
});
/* Done importing js/modal/common/modal_handlers_standard.js */

/////////////////////////
// END FILE js/modal/modal_handlers.js
/////////////////////////

// END ASSET AmazonUIPopover@ready-control-3.2.17177.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPopover@modal-control", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPopover@modal-control-3.2.17177.0
/////////////////////////
// BEGIN FILE js/modal_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Modal view - base class
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-animate').register('a-modal-view-base', function (A, util, animation) {
  var $ = A.$;

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

  /**
   * The duration of the fadein effect when showing a modal.
   *
   * @private
   * @constant
   * @type {integer}
   */
  var SHOW_FADEIN_DURATION = 500;

  /**
   * The duration of the fadeout effect when hiding a modal.
   *
   * @private
   * @constant
   * @type {integer}
   */
  var HIDE_FADEOUT_DURATION = 250;

  return {

    /**
     * Update the aria-busy attribute for the overlay's wrapper element
     *
     * @public
     * @param {boolean} busy
     */
    setAriaBusy: function(busy) {
      this.$popover.find('.a-popover-wrapper').attr("aria-busy", busy);
    },

    /**
     *  If a modal's contents need to be updated after it has been created, call this function
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-inner').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-inner').html("").append(content);
      }
    },

    /**
     *  Change the width and height of a popover
     *  Please make sure both the "off" and "on" cases are presented
     *
     *  @public
     *  @return {object}  DOM node
     */

    updateDimensions: function () {
      var popover = this;
      var $popover = popover.$popover;
      var cssHash = util.getCSSHash(popover.attrs());

      // If modal is draggable, give it firm width to avoid resizing when dragged
      // outside the window (caused by default width: auto)
      if (popover.draggable && (!cssHash.width || cssHash.width === 'auto')) {
        cssHash.width = $popover.width() + 'px';
      }

      $popover.css(cssHash);

      if (cssHash.height) {
        $popover.addClass("a-popover-modal-fixed-height");
      } else {
        $popover.removeClass("a-popover-modal-fixed-height");
      }

      if (popover.isActive()) {
        popover.updatePosition();
      }
      return popover;
    },

    /**
     *  Get content wrapper modal
     *
     *  @private
     *  @return {object}  DOM node
     */

    getContent: function () {
      return this.$popover ? this.$popover.find('.a-popover-inner') : null;
    },

    /**
     *  Show modal with a fadein effect
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    showMethod: function (triggerVisibilityChange) {
      var popover = this;
      var $popover = popover.$popover;

      // Manipulating a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
      $popover.css({
        "visibility": "visible"
      }).removeClass("a-popover-hidden");

      // No fadeIns for IE < 9
      // No animation for ajax since position change during css transition produces a awkward shift animation
      if (!IS_LT_IE9 && popover.attrs("currentDataStrategy") !== "ajax") {
        $popover.css({
          opacity: 0
        });

        animation.animate(popover, { opacity: 1 }, SHOW_FADEIN_DURATION, "linear", function() {
          triggerVisibilityChange.call(popover);
        });
      }
      else {
        triggerVisibilityChange.call(popover);
      }

      // Focus on popover for keyboard accessibility
      A.animationFrameDelay(function() {
        popover.focus();
      });

      // Temporary event to mitigate dependencies on side effect navigation
      if (popover.attrs("legacyNavigable")) {
        util.trigger('showNavigableLegacy', popover);
      }
    },

    /**
     *  Override base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideMethod: function (triggerVisibilityChange) {
      var popover = this;

      // Animating in IE < 9 is very slow when the DOM is large, so don't do that
      if (IS_LT_IE9) {
        popover.$popover.hide().css("visibility", "hidden").find(".a-lgtbox-vertical-scroll").removeClass("a-lgtbox-vertical-scroll");
        triggerVisibilityChange.call(popover);
      } else {
        animation.fadeOut(popover, HIDE_FADEOUT_DURATION, "linear", function() {
          triggerVisibilityChange.call(popover);
        });
      }

      // Temporary event to mitigate dependencies on side effect navigation
      if (popover.attrs("legacyNavigable")) {
        util.trigger('hideNavigableLegacy', popover);
      }
    }
  };
});
/////////////////////////
// END FILE js/modal_view_base.js
/////////////////////////
// END ASSET AmazonUIPopover@modal-control-3.2.17177.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBottomSheet", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBottomSheet-3.2.16588.0
/////////////////////////
// BEGIN FILE js/sheet.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// This file intentionally left blank
/////////////////////////
// END FILE js/sheet.js
/////////////////////////
// END ASSET AmazonUIBottomSheet-3.2.16588.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIDevbar", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIDevbar-1.0.332547.0
/////////////////////////
// BEGIN FILE js/constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.register('at-constants', function (A) {
  return {
    toolbarHeight: '150px',
    char: {
      checkmark: '&#10004',
      cross: '&#10008'
    }
  }
});
/////////////////////////
// END FILE js/constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/helpers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('A', 'at-constants').register('at-helpers', function (A, constants) {
  var $ = A.$;

  function evaluateDeepProperty(context, propertyStr) {
    var properties = propertyStr.split('.');
    var currProp = properties.shift();
    while (context && currProp) {
      context = context[currProp];
      currProp = properties.shift();
    }
    return context;
  }

  function getMissingProperties(context, propertyStrs) {
    var missingFeatures = [];
    for (var i = 0; i < propertyStrs.length; i++) {
      var propertyStr = propertyStrs[i];
      if (evaluateDeepProperty(context, propertyStr) === undefined) {
        missingFeatures.push(propertyStr);
      }
    }
    return missingFeatures;
  }

  function defaultProperty(properties, property, value) {
    if (!properties.hasOwnProperty(property)) {
      properties[property] = value;
    } else {
      properties[property] += ';' + value
    }
    return properties;
  }

  function appendSubmenu(container, submenu) {
    $('#at-submenu', container).append(submenu);
  }

  function appendContent(container, content) {
    $('#at-content', container).append(content);
  }

  function createLabel(properties) {
    return $('<label>', properties);
  }

  function createSpan(properties) {
    return $('<span>', properties);
  }

  function createButton(properties) {
    return $('<button>', properties).click(properties.callback);
  }

  function createMenuButton(properties) {
    return createButton(defaultProperty(properties, 'style', 'margin-bottom:3px;width:100%;'));
  }

  function createDiv(properties) {
    return $('<div>', properties);
  }

  function createInput(properties) {
    return $('<input>', defaultProperty(properties, 'style', 'margin-bottom:3px;width:100%;'));
  }

  function createTextarea(properties) {
    return $('<textarea>', properties);
  }

  function createCheckbox(checkBoxProperties, labelProperties, clickFn) {
    return createLabel(defaultProperty(labelProperties, 'style', 'font-weight:normal;'))
      .prepend($('<input>', defaultProperty(defaultProperty(checkBoxProperties, 'style', 'margin-right:5px;'), 'type', 'checkbox')).click(clickFn));
  }

  function createPill(key, value, forcedClazz) {
    var clazz;
    if ($.type(value) === 'boolean' || $.type(value) === 'undefined' || $.type(value) === 'null') {
      clazz = value ? 'ab-feature-pill-green' : 'ab-feature-pill-red';
      value = value ? constants.char.checkmark : constants.char.cross;
    } else {
      clazz = 'ab-feature-pill-blue';
    }
    clazz = forcedClazz ? forcedClazz : clazz;

    return $('<div>', {'class':'ab-feature-pill ' + clazz, 'attr': key.toLowerCase()})
    .append($('<span>', {'class':'ab-feature-pill-key', 'html': key}))
    .append($('<span>', {'class':'ab-feature-pill-value', 'html': value}));
  }

  function createList(listContent, properties) {
    properties = properties || {};
    var $ul = $('<ul>', defaultProperty(properties));
    $.map(listContent, function(content) {
      $ul.append($('<li>', {'class':'at-list-item'}).html(content));
    });
    return $ul;
  }

  function xpath(dom) {
    if (dom === document.documentElement) {
      return '/html';
    }

    var $dom = $(dom);
    var $siblings = $dom.parent().find('> ' + dom.tagName);
    var idx = $siblings.index($dom);
    if (idx === -1) {
      throw 'can not evaluate xpath of element `' + dom.tagName + '`';
    }
    // Surprisingly, duplicated element id happens a lot; don't trust it in xpath.
    return xpath(dom.parentNode) + '/' + dom.tagName + '[' + (idx + 1) + ']';
  }

  function getElementByXpath(path) {
    return document.evaluate(path, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
  }

  function evaluateSelector(dom) {
    var meta = [dom.tagName || ''];
    if (dom.className && dom.className.trim) {
      meta.push('.' + dom.className.trim().replace(/\s+/g, '.'));
    }
    if (dom.id) {
      meta.push('#' + dom.id);
    }
    return meta.join('');
  }

  function padLeft(nr, n, str) {
    try {
      return new Array(n - String(nr).length + 1).join(str || '0') + nr;
    } catch (e) {
      return 0;
    }
  }

  function repeatString(str, n) {
    return new Array(n + 1).join(str);
  }

  var AUI_BUILD_DATE = typeof window.AmazonUIPageJS !== 'undefined' ? window.AmazonUIPageJS.AUI_BUILD_DATE : 'no P';
  function getAUIBuildDate() {
    return AUI_BUILD_DATE;
  }

  var PAGE_TYPE = typeof window.uept !== 'undefined' ? window.uept.pageType + ':' + window.uept.subPageType : 'no uept';
  function getPageType() {
    return PAGE_TYPE;
  }

  return {
    getMissingProperties: getMissingProperties,
    createSpan: createSpan,
    createButton: createButton,
    createMenuButton: createMenuButton,
    createDiv: createDiv,
    createInput: createInput,
    createTextarea: createTextarea,
    createCheckbox: createCheckbox,
    createLabel: createLabel,
    createPill: createPill,
    createList: createList,
    appendSubmenu: appendSubmenu,
    appendContent: appendContent,
    xpath: xpath,
    getElementByXpath: getElementByXpath,
    evaluateSelector: evaluateSelector,
    padLeft: padLeft,
    repeatString: repeatString,
    getAUIBuildDate: getAUIBuildDate,
    getPageType: getPageType
  }
});
/////////////////////////
// END FILE js/helpers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_ACS.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('A', 'at-helpers', 'at-core', 'aom-metrics-tasks')
      .register('at-aom', function (A, helpers, core, metrics) {
  var $ = A.$;

  var taskRun;

  var $aomSubmenu = helpers.createDiv({'id':'at-submenu-aom-container','style':'display:none;'});

  function taskEnd(task) {
    hideReportConsole();
    taskRun = task;
  }

  function setupReload() {
    core.$content.children('div').hide();
    if ($('#at-reload-content').length === 0) {
      var $reloadContent = helpers.createDiv().addClass('at-subcontent')
        .append(helpers.createLabel({'html':'You must refresh the page to run this script'}))
        .append(helpers.createButton({'html':'Refresh Page'}).click(reloadPage));
      helpers.appendContent(core.$container, $reloadContent);
    }
    $('#at-reload-content').show();
  }

  function reloadPage() {
    location.reload();
  }

  function getContainerName(task) {
    return 'at-content-' + task + '-container';
  }

  function getOverrides(event) {
    var task = event.data.task;
    if (!taskRun) {
      A.on(metrics.runTaskIds(task), function(results) {
        console.log(JSON.stringify(results));
        A.$('.at-subcontent').hide();
        var $overridesSubmenu = helpers.createDiv({'id': getContainerName(task)}).addClass('at-scroll');
        var $overridesContent = helpers.createDiv()
          .append(helpers.createLabel({'html': "Overrides"})).addClass('at-overrides');

        // Loop through analysis
        var resultList = [];
        A.each(results, function(analysisVal, analysisName) {
            // Loop through metrics
            A.each(analysisVal, function(metricsVal, metricsName) {
                if(metricsVal.type === 'test') {
                    var resultContent = '<h4><a href="javascript:void(0);" class="a-declarative" data-action="rules-click">' + metricsVal.description + '</a></h4><div class="rules" style="display:none;">';
                    resultContent += parseOverrides(metricsVal.result, analysisName);
                    resultContent += '</div>';
                    resultList.push(resultContent);
                }
            });
        });
        $overridesContent.append(helpers.createList(resultList));
        $overridesSubmenu.append($overridesContent);
        helpers.appendContent(core.$container, $overridesSubmenu);
        taskEnd(task);
      });
    } else if (taskRun !== task) {
      setupReload();
    } else {
      $('#' + getContainerName(task)).show();
    }
  }

  function parseOverrides(overrides, analysisName) {
    var output = '';
    if(overrides) {
        if(analysisName.indexOf('css-override-analytics') > -1) {
            A.each(overrides, function(overrideResultByAsset) {
                output += '<div>CSS Overrides Source: <a target="_blank" href="https://code.amazon.com/packages/' + overrideResultByAsset.asset + '/trees/mainline">' + overrideResultByAsset.asset + '</a></div><ul>';
                A.each(overrideResultByAsset.usecases, function(rule) {
                    output += '<li>Overriding rule: <a href="javascript:void(0);" class="a-declarative" data-action="override-click">' + rule.cssRule + '</a><ol class="overrideDetails" style="display:none;">';
                    A.each(rule.targetElements, function(element) {
                        output += '<li class="a-declarative" data-action="element-click"><a href="javascript:void(0);">' + element.selector + '</a></li>';
                    });
                    output += '</ol></li>';
                });
                output += '</ul>';
            });
        } else {
            output = '<ul>';
            A.each(overrides, function(targetElement) {
                output += '<li class="a-declarative" data-action="element-click"><a href="javascript:void(0);">' + targetElement.selector + '</a></li>';
            });
           output += '</ul'; 
        }
    } else {
        output = "<p>No results</p>"
    }

    return output;
  }

  A.declarative('override-click', 'click', function(event){
    var $target = event.$currentTarget;
    var $overrideDetails = $target.next();
    if ($overrideDetails.css('display') === "none") {
      $('.overrideDetails').hide();
      $overrideDetails.show();
    } else {
      $overrideDetails.hide();
    }
  });
  
  A.declarative('rules-click', 'click', function(event){
    var $target = event.$currentTarget;
    var $rule = $target.parent().next();
    if ($rule.css('display') === "none") {
      $('.rules').hide();
      $rule.show();
    } else {
      $rule.hide();
    }
  });

  A.declarative('element-click', 'click', function(event){
    $('.overrideBox').removeClass('overrideBox');
    var $target = event.$currentTarget;
    var $targets = $($target.children()[0].innerText);
    var topPos = $target[0].offsetTop;
    $("#at-content-a-css-overriding-analytics-container").animate({ scrollTop: topPos }, "fast");
    $targets.addClass('overrideBox');
    $targets[0].scrollIntoView(false);
  });

  function hideReportConsole() {
    $("#metrics-report-console").hide();
  }

  $aomSubmenu.append(helpers.createMenuButton({'id':'at-submenu-aom-overrides', 'html': 'All Overrides'}).click({ task: ['aom-markup-analytics', 'aom-css-override-analytics'] },getOverrides))
      .append(helpers.createMenuButton({'id':'at-submenu-aom-overrides-spacing', 'html': 'Spacing Overrides'}).click({ task: ['aom-markup-analytics-spacing', 'aom-css-override-analytics-spacing'] }, getOverrides))
        .append(helpers.createMenuButton({'id':'at-submenu-aom-overrides-typeramp', 'html': 'Typeramp Overrides'}).click({ task: ['aom-markup-analytics-type-ramp', 'aom-css-override-analytics-type-ramp'] }, getOverrides));

  helpers.appendSubmenu(core.$container, $aomSubmenu);

});
/////////////////////////
// END FILE js/tool_ACS.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO: Move inline functions into declared functions.
 * TODO: Move logging to the bar.
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-events', function (A, constants, helpers, core) {
  var $ = A.$;

  var $eventSubmenu = helpers.createDiv({
    'id':'at-submenu-event-container',
    'style':'display:none'
  })
  .append(helpers.createInput({'id':'at-submenu-event-Name', 'placeholder':'Event Key'}))
  .append(helpers.createMenuButton({'id':'at-submenu-event-Listen', 'html': 'Listen', 'callback': function() {
    var val = $('#at-submenu-event-Name').val();
    A.on(val, function (){ console.log(val, arguments)});
  }}))
  .append(helpers.createMenuButton({'id':'at-submenu-event-Trigger', 'html': 'Trigger', 'callback': function() {
    var val = $('#at-submenu-event-Name').val();
    A.trigger(val);
  }}));

  helpers.appendSubmenu(core.$container, $eventSubmenu);

});
/////////////////////////
// END FILE js/tool_Events.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Features.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('jQuery', 'at-constants', 'at-helpers', 'at-core', 'a-detect').register('at-features', function ($, constants, helpers, core, detect) {
  function featureFilter (event) {
      var $pills = $featureContent.find('.ab-feature-pill');
      $pills.hide();
      $pills.filter('[attr*="'+event.target.value.toLowerCase()+'"]').show();
    }

  // TODO: Move to scss file
  var $featureContent = helpers.createDiv({
      'id':'at-content-feature-container',
      'style':'overflow-y:scroll;height:inherit;display:none;'
    });

  helpers.appendContent(core.$container, $featureContent);

  var featuresEnabled = 0, featuresDisabled = 0, featuresInformational = 0;
  $.each(detect.capabilities, function(key, value) {
    $featureContent.append(helpers.createPill(key, value));
    if ($.type(value) === 'boolean' || $.type(value) === 'undefined' || $.type(value) === 'null') {
      value ? featuresEnabled++ : featuresDisabled++;
    } else {
      featuresInformational++;
    }
  });

  var $featureSubmenu = helpers.createDiv({'id':'at-submenu-feature-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-feature-filter', 'placeholder':'Filter'}).keyup(featureFilter))
    .append(helpers.createPill('Enabled', featuresEnabled, 'ab-feature-pill-green'))
    .append(helpers.createPill('Disabled', featuresDisabled, 'ab-feature-pill-red'))
    .append(helpers.createPill('Informational', featuresInformational, 'ab-feature-pill-blue'));

  helpers.appendSubmenu(core.$container, $featureSubmenu);

});
/////////////////////////
// END FILE js/tool_Features.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Modules.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO: Move CSS to file and classes.
 * TODO: Implement P._namespace("AmazonUI").when("prv:p-debug").execute(dbg => console.log(dbg))
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-modules', function (A, constants, helpers, core) {
  var $ = A.$;

  var registeredModules = [];

  function createModulePill() {
    var val = $('#at-submenu-module-input').val();
    if ($.inArray(val, registeredModules) > -1 || !val) { return; }
    registeredModules.push(val);
    var pill = helpers.createPill(val, constants.char.cross, 'ab-feature-pill-red');
    P.when(val).execute(function() {
      pill.removeClass('ab-feature-pill-red').addClass('ab-feature-pill-green');
      pill.find('.ab-feature-pill-value').html(constants.char.checkmark);
    });
    $moduleContent.append(pill);
  }

  function clearModulePills() {
    registeredModules = [];
    $('#at-submenu-module-input').val('');
    $moduleContent.empty();
  }

  function registerModule() {
    var val = $('#at-submenu-module-input').val();
    P.register(val, A.NOOP);
  }

  var $moduleSubmenu = helpers.createDiv({'id':'at-submenu-module-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-module-input', 'placeholder':'Module name'}))
    .append(helpers.createMenuButton({'id':'at-submenu-module-check', 'html': 'Check'}).click(createModulePill))
    .append(helpers.createMenuButton({'id':'at-submenu-module-clear', 'html': 'Clear'}).click(clearModulePills))
    .append(helpers.createMenuButton({'id':'at-submenu-module-register', 'html': 'Register'}).click(registerModule));

  helpers.appendSubmenu(core.$container, $moduleSubmenu);

  var $moduleContent = helpers.createDiv({
    'id':'at-content-module-container',
    'style':'overflow-y:scroll;height:inherit;display:none;'
  });

  helpers.appendContent(core.$container, $moduleContent);


});
/////////////////////////
// END FILE js/tool_Modules.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_States.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO Implement Listener and lock
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-states', function (A, constants, helpers, core) {
  var $ = A.$;
  
  var stateListeners = {};

  function getState() {
    var val = $('#at-submenu-state-name', core.$container).val();
    var state = A.state(val);
    //console.log(state);
    $('#at-submenu-state-object', core.$container).val(JSON.stringify(state, undefined, 2));
  }

  function setState() {
    var key = $('#at-submenu-state-name', core.$container).val();
    var data = $('#at-submenu-state-object', core.$container).val();
    A.state.replace(key, JSON.parse(data));
  }

  function clearState() {
    $('#at-submenu-state-name', core.$container).val('');
    $('#at-submenu-state-object', core.$container).val('');
  }

  function refreshState() {
    console.log('State changed!');
  }

  function listenProp() {
  }

  function listenState() {
    var val = $('#at-submenu-state-name', core.$container).val();
    if (val) {
      var elements = $stateSubmenu.find('input:not([type="checkbox"]), button');
      var isChecked = $('#at-submenu-state-listen', core.$container).is(":checked");
      if(isChecked) {
        elements.prop('disabled', true);
        /*listenProp(val);
        A.state.bind(val, refreshState);*/
      } else {
        elements.prop('disabled', false);
      }
      
    }
  }

  var $stateSubmenu = helpers.createDiv({'id':'at-submenu-state-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-state-name', 'placeholder':'State Key'}))
    .append(helpers.createMenuButton({'id':'at-submenu-state-get', 'html': 'Get'}).click(getState))
    .append(helpers.createMenuButton({'id':'at-submenu-state-set', 'html': 'Set'}).click(setState))
    .append(helpers.createMenuButton({'id':'at-submenu-state-clear', 'html': 'Clear', }).click(clearState));
    //.append(helpers.createCheckbox({'id':'at-submenu-state-listen'}, {'html': 'Listen for Changes'}, listenState));

  helpers.appendSubmenu(core.$container, $stateSubmenu);

  var $stateContent = helpers.createDiv({
    'id':'at-content-state-container',
    'style':'height:100%;display:none;'
  }).append(helpers.createTextarea({
    'id':'at-submenu-state-object',
    'style':'box-sizing:border-box;width:100%;height:100%;'
  }));

  helpers.appendContent(core.$container, $stateContent);


});
/////////////////////////
// END FILE js/tool_States.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Doms.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('jQuery', 'at-helpers', 'at-core', 'at-dom-inspector').register('at-dom', function($, helpers, core, inspector) {
  var $submenu = helpers.createDiv({
      'id': 'at-submenu-dom-container',
      'style':'display:none'
  });

  var missingDocumentApis = helpers.getMissingProperties(document, ['evaluate']);
  if (missingDocumentApis.length) {
    $submenu
        .append(helpers.createSpan({
            'id':'at-submenu-dom-inspect-note',
            'html': 'This tool is not supported in your browser due to lack of following APIs:'
        }))
        .append(helpers.createList(
            $.map(missingDocumentApis, function (propertyStr) { return 'document.' + propertyStr; }),
            { 'id': 'at-submenu-dom-inspect-note-list' }
        ));
    helpers.appendSubmenu(core.$container, $submenu);
    return;
  }

  var isInitialized = false;

  var instructions = [
    'Move mouse to highlight element you want to inspect with red box.',
    'Click green rectangle to explore inner elements.',
    'Click red box to take a dom snapshot.',
    'Attach the output, shown in the right-hand side, while you file issues to AUI'
  ];

  $submenu
    .append(helpers.createMenuButton({'id':'at-submenu-dom-inspect-enable', 'html': 'Enable', 'callback': function() {
      if (!isInitialized) {
        isInitialized = true;
        inspector.init();
      }
      inspector.enable();
    }}))
    .append(helpers.createMenuButton({'id':'at-submenu-dom-inspect-disable', 'html': 'Disable', 'callback': function() {
      inspector.disable();
    }}))
    .append(helpers.createList(instructions, {
      'id': 'at-submenu-dom-inspect-instructions'
    }));

  helpers.appendSubmenu(core.$container, $submenu);


  var $content = helpers.createDiv({
    'id': 'at-content-dom-container',
    'style':'display:none;height:100%'
  }).append(helpers.createTextarea({
    'id':'at-submenu-dom-report',
    'style':'box-sizing:border-box;width:100%;height:100%'
  }));

  helpers.appendContent(core.$container, $content);
});

P.when('jQuery', 'at-helpers').register('at-dom-inspector', function($, helpers) {

  var enableInspector = false;

  var prev, curr, MARKER;

  var borderWidth = 10;

  function enable() {
    enableInspector = true;
  }

  function disable() {
    enableInspector = false;
    resetMark();
  }

  // ---------------------------------------------------------------------------

  function Element(level, literal, layout) {
    this.level = level;
    this.literal = literal;
    this.layout = layout;
  }

  function Context(dom) {
    this.dom = dom;
    this.stack = [];
  }
  Context.prototype = {
    PATTERN_A_CLASS: /(a-[\-a-zA-z]+)/g,
    parseAClasses: function parseAClasses(dom) {
      return [].slice.call(dom.className.match(this.PATTERN_A_CLASS) || []);
    },
    parseLiteral: function parseLiteral(dom) {
      var aClasses = this.parseAClasses(dom);
      return aClasses.length ? '.' + aClasses.join('.') : dom.nodeName;
    },
    parseLayout: function parseLayout(dom) {
      var cs = window.getComputedStyle(dom, null);
      return [
        helpers.padLeft(dom.clientWidth, 6, ' ') + ',' + helpers.padLeft(dom.clientHeight, 6, ' '),
        helpers.padLeft(cs.getPropertyValue('display'), 15, ' '),
        helpers.padLeft(cs.getPropertyValue('position'), 8, ' ')
      ].join(' ');
    },
    parseDom: function parseDom(dom, stack, depth) {
      var el = new Element(depth, this.parseLiteral(dom), this.parseLayout(dom));
      stack.push(el);
      var children = dom.children;
      for (var i = 0; i < children.length; i++) {
        this.parseDom(children[i], stack, depth + 1);
      }
    },
    parse: function parse() {
      this.parseDom(this.dom, this.stack, 0);
    },
    dump: function dump(lines) {
      for (var i = 0; i < this.stack.length; i++) {
        var el = this.stack[i];
        var line;
        line = el.layout + helpers.repeatString('  ', el.level) + el.literal;
        lines.push(line);
      }
      return lines;
    }
  };

  // ---------------------------------------------------------------------------

  function getBlockChildren(el) {
    var queue = [].slice.call(el.children);
    var blockChildren = [];
    while (queue.length) {
      var child = queue.shift();
      if (child.offsetWidth === 0 || child.offsetHeight === 0) {
        if (child.children.length) {
          queue = queue.concat([].slice.call(child.children));
        }
      } else {
        blockChildren.push(child);
      }
    }
    return blockChildren;
  }

  function addInnerMarkerFor(child, parent) {
    var parentBCR = parent.getBoundingClientRect();
    var childBCR = child.getBoundingClientRect();
    var childMarker = helpers.createDiv({'class':'at-dom-child-marker'}).get(0);

    childMarker.style.top = ((childBCR.top - parentBCR.top)) + 'px';
    childMarker.style.left = ((childBCR.left - parentBCR.left)) + 'px';
    childMarker.style.width = (child.offsetWidth) + 'px';
    childMarker.style.height = (child.offsetHeight) + 'px';
    childMarker.setAttribute('data-xpath', helpers.xpath(child));
    childMarker.style.zIndex = 8 * 1000000000;

    MARKER.appendChild(childMarker);
  }

  function markFor(el) {
    var bcr = el.getBoundingClientRect();
    // keep it attached for transition
    MARKER.style.top = (bcr.top - borderWidth) + 'px';
    MARKER.style.left = (bcr.left - borderWidth) + 'px';
    MARKER.style.width = (el.offsetWidth + borderWidth * 2) + 'px';
    MARKER.style.height = (el.offsetHeight + borderWidth * 2) + 'px';
    MARKER.style.opacity = 1;
    MARKER.style.zIndex = 9 * 1000000000;
  }

  function resetMark() {
    MARKER.style.opacity = 0;
    MARKER.style.zIndex = -1;
  }

  function resetInnerMarkersFor(parent) {
    MARKER.innerHTML = '';
    var children = getBlockChildren(parent);
    $.map(children, function (child) {
      addInnerMarkerFor(child, parent);
    });
  }

  function inspectStructure(dom) {
    var context = new Context(dom);
    context.parse();
    return context.dump([]);
  }

  function inspect() {
    var log = [];
    log.push(helpers.getAUIBuildDate());
    log.push(helpers.getPageType());
    log.push('');
    log.push(helpers.evaluateSelector(curr));
    log.push(helpers.xpath(curr));
    log = log.concat(inspectStructure(curr));
    log = log.join("\n");
    report(log);
    resetMark();
  }

  function report(log) {
    $('#at-submenu-dom-report').get(0).textContent  = log; // keep newlines
  }

  function mousemoveHandler(event) {
    if (!enableInspector) { return; }
    if (event.target === document.body ||
        (prev && prev === event.target)) {
      return;
    }

    if (event.target &&
        event.target !== MARKER &&
        event.target.id.indexOf('at-') !== 0 &&
        event.target.className.indexOf('at-') !== 0) {
      moveMarkerTo(event.target);
    }
  }

  function clickHandler(event) {
    var tar = event.target;
    if (tar.className.indexOf('at-dom-marker') !== -1) {
      inspect();
      window.scrollTo(0, 0);
    } else if (tar.className.indexOf('at-dom-child-marker') !== -1) {
      var xpath = tar.getAttribute('data-xpath');
      var child = helpers.getElementByXpath(xpath);
      moveMarkerTo(child);
    }
  }

  function moveMarkerTo(el) {
    if (prev) {
      resetMark(prev);
      prev = undefined;
    }
    curr = el;
    resetInnerMarkersFor(curr);
    markFor(curr);
    prev = curr;
  }

  function initDom() {
    MARKER = helpers.createDiv({'class':'at-dom-marker'}).get(0);
    document.body.appendChild(MARKER);
  }

  function initEvent() {
    $(document.body).mouseover(mousemoveHandler);

    $(MARKER).click(clickHandler);
  }

  function init() {
    initDom();
    initEvent();
  }

  return {
    init: init,
    enable: enable,
    disable: disable
  }
});
/////////////////////////
// END FILE js/tool_Doms.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/core.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

 P.when('A', 'a-analytics', 'at-constants', 'at-helpers').register('at-core', function (A, analytics, constants, helpers) {
  
  var $ = A.$;

  function incrementMetric(metricName) {
    if (window.ue) {
      window.ue.count(metricName, 1);
    }
  }

  // Only show devbar if the auiDevbar query parameter is true
  function showDevbar() {
    var devbarParam = getQueryParam('auiDevbar', window.location.href);
    return devbarParam === 'true' || devbarParam ==='1';
  }

  // from https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
  function getQueryParam(name, url) {
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) {
      return null;
    }
    if (!results[2]) {
      return '';
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
  }

  // If the AUI_VERSION_INSTRUMENTATION:T1 weblab is not on, the AOM scripts will not run
  // If it is off, give the option to turn the weblab on
  function isAomWeblabOn() {
    return document.cookie.match(/experiment=[^;]AUI_VERSION_INSTRUMENTATION:T1/);
  }

  function loadAomWeblab() {
    var url = window.location.href;
    window.location.href = 'http://www.amazon.com/gp/private/weblab/cookie.html?url=' + url + '&wc=AUI_VERSION_INSTRUMENTATION:T1';
  }

  function menuClick(event) {
    var val = event.target.value;
    $submenu.children('div').hide();
    $submenu.find('#at-submenu-'+val+'-container').show();
    $content.children('div').hide();
    $content.find('#at-content-'+val+'-container').show();
    incrementMetric('at-menu-clck-' + val);
    if (val === 'aom' && !isAomWeblabOn()) {
      setUpLoadWeblab();
    }
  }

  function setUpLoadWeblab() {
    var $addWeblabContent = helpers.createDiv().addClass('at-subcontent')
      .append(helpers.createLabel({'html':'AOM Scripts cannot run without the AOM weblab'}))
      .append(helpers.createMenuButton({'html':'Load AOM Weblab'}).click(loadAomWeblab));
    helpers.appendContent($container, $addWeblabContent);
  }

  /* Setup Container */
  var $container;
  var $content;

  if (showDevbar()) {
    analytics.increment('aom:devbar');
    
    $container = helpers.createDiv({ 'id':'at-container' });

    /* Create Content Container */
    $content = helpers.createDiv({ 'id':'at-content' });

    /* Setup Main Menu */
    var $menu = helpers.createDiv({ 'id':'at-menu' });

    $menu
    .append(helpers.createMenuButton({'id':'at-menu-aom', 'html':'AOM', 'value':'aom'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-event', 'html':'Events', 'value':'event'}).click(menuClick))
    //.append(helpers.createMenuButton({'id':'at-menu-declarative', 'html':'Declaratives', 'value':'declarative'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-state', 'html':'States', 'value':'state'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-module', 'html':'Modules', 'value':'module'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-feature', 'html':'Features', 'value':'feature'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-dom', 'html':'Doms', 'value':'dom'}).click(menuClick));

    var $submenu = helpers.createDiv({ 'id':'at-submenu' });


    $container
      .append($menu)
      .append($submenu)
      .append($content);

    /* Create the Containers */
    $('body').prepend($container);
    $('body').addClass('at-body-padding');
  }
  
  return {
    $container: $container,
    $content: $content
  }
});
/////////////////////////
// END FILE js/core.js
/////////////////////////

// END ASSET AmazonUIDevbar-1.0.332547.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUITruncate", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUITruncate-3.2.16591.0
/////////////////////////
// BEGIN FILE js/truncate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
P.when('A', 'a-component', 'prv:a-truncate-util').register('a-truncate', function (A, component, trim){
  'use strict';

  var $ = A.$;

  var TruncationElement = component.create({
    _componentName: 'truncate',
    init: function (selector, context) {
      this._super(selector, context);
      this._$full = this._$element.find('.a-truncate-full');
      this._$cut = this._$element.find('.a-truncate-cut');
      this._$fullText = this.getFullText();
      this._$offscreenTextHolder = createTruncationElement();
    },

    /*
    * Truncate component
    */ 
    update: function (options) {
      var cutTextOld = this._$cut.html();
      setTruncatedText(this);
      setIsUpdated(this);

      var payload = {
        truncateContainer: this._$element,
        truncateInstance: this
      };

      // Broadcast Events
      if(options && options.silent) {
        return;
      }
      
      var cutTextNew = this.getTruncatedText();
      if(cutTextOld !== cutTextNew) {
        A.trigger('a:truncate:updated', payload);

        var truncateName = this._$element.data('a-truncate-name');
        if(truncateName) {
          A.trigger('a:truncate:' + truncateName + ':updated', payload);
        }
      }
    },

    /*
    * Get non truncated text
    * @return {string}
    */
    getFullText: function () {
      return this._$full.html();
    },

    /*
    * Get truncated text
    * @return {string}
    */
    getTruncatedText: function () {
      if(this.getIsUpdated()){
        return this._$cut.html();
      }
      else {
        return calculateTruncatedText(this);
      }
    },

    /*
    * Check if update already called on target component
    * @return {boolean}
    */
    getIsUpdated: function () {
      return this._$element.is('[data-a-updated]');
    },

    /*
    * Get overflow marker to be used for truncation
    * @return {string}
    */
    getOverflowMarker: function () {
      return this._$element.data('a-overflow-marker') || '';
    },

    /*
    * Get special character list used for truncating specified characters from the 
    * end of truncation
    * @return {string}
    */
    getSpecialCharacterList: function () {
      return this._$element.data('a-special-character-list') || '';
    },

    /*
    * Get component's line height (set in Yada)
    * @return {string}
    */
    getLineHeight: function () {
      return this._$element[0].style.lineHeight;
    },

    /*
    * Get component's max height (set in Yada)
    * @return {string}
    */
    getMaxHeight: function () {
      return this._$element[0].style.maxHeight;
    },

    /*
    * Get if text fits in the given rows
    * @return {boolean}
    */
    getIfTextFits: function () {
      return this._$fullText === calculateTruncatedText(this);
    }
  });

  function getCalculatedMaxHeight(instance) {
    return Math.round(parseFloat(instance._$element.css('max-height')));
  }

  function setTruncatedText(instance) {
    var calculatedText = calculateTruncatedText(instance);
    if(instance._$fullText !== calculatedText) {
      instance._$cut.height(instance.getMaxHeight());
    }
    else {
      instance._$cut.height('auto');
    }
    instance._$cut.html(calculatedText);
  }

  function calculateTruncatedText(instance) {
    var truncationObject = {
      textToTruncate: instance._$fullText,
      maxHeight: getCalculatedMaxHeight(instance),
      overflowMarker: instance.getOverflowMarker(),
      specialCharacterList: instance.getSpecialCharacterList(),
      offscreenTextHolder: instance._$offscreenTextHolder
    };

    instance._$element.append(truncationObject.offscreenTextHolder);
    var clipText = getClipText(truncationObject);
    truncationObject.offscreenTextHolder.remove();
    return clipText;
  }

  function setIsUpdated(instance) {
    instance._$element.attr('data-a-updated', true);
    instance._$full.addClass('a-offscreen'); // implement unique offscreen?
    instance._$cut.removeClass('a-hidden');
  }

  function createTruncationElement() {
    return $('<span class="a-truncate-calc a-offscreen"/>');
  }

  function getOffscreenTextHolderHeight(text, offscreenTextHolder) {
    return parseFloat(offscreenTextHolder.html(text).css('height'));
  }

  function getClipText(truncationObject) {
    var textToTruncate = truncationObject.textToTruncate;
    var offscreenTextHolder = truncationObject.offscreenTextHolder;
    var maxHeight = truncationObject.maxHeight;
    var overflowMarker = truncationObject.overflowMarker;
    var specialCharacterList = truncationObject.specialCharacterList;

    if(getOffscreenTextHolderHeight(textToTruncate, offscreenTextHolder) <= maxHeight) {
      return textToTruncate;
    }

    var first = 0, last = textToTruncate.length;
    var mid, testString, clipText;
    while(last > first){
      mid = Math.floor((first + last)/2);

      testString = textToTruncate.substring(0, mid + 1) + overflowMarker;
      if(getOffscreenTextHolderHeight(testString, offscreenTextHolder) > maxHeight) {
        last = mid;
      }
      else {
        first = mid + 1;
      }
    }
    clipText = trim.trimSpecialChars(textToTruncate.substring(0, last), specialCharacterList);
    return clipText + overflowMarker;
  }

  // Updates one truncate element on the page that is tagged for needing an update
  var updateOne =  function () {
    var targetDomElement = $('.a-truncate[data-a-recalculate="true"]').first();
    var isNotEmpty = !!targetDomElement.length;
    if (isNotEmpty) {
      var targetElement = new TruncationElement(targetDomElement);
      targetElement.update();
      targetDomElement.attr('data-a-recalculate', false);
    }
    return isNotEmpty;
  };

  /* This utility takes a function as an argument which is run until the passed function
     returns false, yeilding the processor between each run.
     TODO: Move this utility to BaseJS - https://sim.amazon.com/issues/AUI-20685
  */
  function loopAndYield(fn) {
    var isLooping = false;
    function doLoop() {
      isLooping = fn();
      if(isLooping) {
        A.delay(doLoop, 0);
      }
    }
    return function() {
      if(!isLooping) {
        doLoop();
      }
    };
  }

  /* This acts as a single entry point so that the same instance of the function is called, thus ensuring only one loop is active at any point. 
    This way we avoid using global variables and keep the looping logic separate from the code that needs looping. 
  */
  var popAndUpdateOne = loopAndYield(updateOne);

  function autoUpdate() {
    $('.a-truncate:not([data-a-manual-update="true"])').attr('data-a-recalculate', true);
    popAndUpdateOne();
  }

  function checkWidthChanged(viewport, changed) {
    if (changed.width) {
      autoUpdate();
    }
  }

  A.on('ready orientationchange', autoUpdate);
  A.on('resize', checkWidthChanged);

  /*
  * Public factory methods
  */
  return {
    get: function (selector, context) {
      return new TruncationElement(selector, context);
    }
  };
});

P.declare('prv:a-truncate-util', {
  trimSpecialChars: function(truncatedString, specialCharacterList) {
    'use strict';
    var re = new RegExp('[' + specialCharacterList.replace(/[.\\+*?[^\]$(){}=!<>|:-]/g, '\\$&') + '\\s]+$');
    return truncatedString.replace(re, '');
  }
});
/////////////////////////
// END FILE js/truncate.js
/////////////////////////
// END ASSET AmazonUITruncate-3.2.16591.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICardUI", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUICardUI-3.2.16595.0
/////////////////////////
// BEGIN FILE js/cardui.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Cardui

'use strict';


P.when('A', 'a-component', 'prv:a-cardui-peek-toggle', 'prv:a-cardui-peek-expand').register('a-cardui', function(A, component, peekToggle, peekExpand) {
    
    var $ = A.$;

    var Cardui = component.create({
        _componentName: 'cardui',
        init: function (selector, context) {
            
            this._super(selector, context);

            // METADATA FOR SUB COMPONENTS
            this.metadata = {
                interactedOnce: false,
                describedByIds: this._$element.data('describedByIds'),
                cardExpanded: this.isExpanded(),
                cardName: this.getName()
            };
        },
        getCardType: function () {
            return getCardType(this._$element);
        },
        isExpanded: function () {
            // NO OP
        },
        getName: function () {
            return this._$element.attr('name');
        },
        getId: function () {
            return this._$element.attr('id');
        },
        toggle: function () {
            // NO OP
        }
    });

    function getCard(selector, context) {
        var Card;
        var cardType = getCardType(selector);
        switch(cardType) {
            case 'peekToggle':
                Card = Cardui.extend(peekToggle);
                break;
            case 'peekExpand':
                Card = Cardui.extend(peekExpand);
                break;
            default:
                Card = Cardui;
        }

        // Add instance to DOM
        var cardInstance = new Card(selector, context);
        $(selector).data('cardInstance', cardInstance);

        A.trigger('a:card:initialized', cardInstance);

        if($(selector).attr('id')) {
            A.trigger('a:card:' + $(selector).attr('id') + ':initialized', cardInstance);
        }
        
        return cardInstance;
    }

    function getCardType(domElement) {
        return $(domElement).data('a-card-type');
    }

    /*
    * Public factory methods
    */
    return {
        get: function(selector, context) {
            return $(selector).data('cardInstance') || getCard(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/cardui.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardui_content.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Card ui Content

"use strict";

P.when("A", "a-component").register("prv:a-cardui-content", function(A, component) {
    var $ = A.$;

    var CarduiContent = component.create({
        _componentName: "carduiContent",
        init: function(selector, context) {
            this._super(selector, context);
        },
        getHeight: function() {
            return this._$element[0].scrollHeight;
        },
        getMaxHeightDataAttribute: function(){
            return this._$element.data('a-max-height');
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function(selector, context) {
            return new CarduiContent(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/cardui_content.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardui_deck.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Cardui Deck

'use strict';

P.when('A', 'a-component', 'a-cardui').register('a-cardui-deck', function (A, component, cardui){
    var $ = A.$;

    // NAME GENERATION UTILITY
    var AUTO_NAME_STRING = "a-cardui-deck-autoname-";
    var deckCount = 0;

    var CarduiDeck = component.create({
        _componentName: 'carduiDeck',
        init: function (selector, context) {
            
            this._super(selector, context);

            var deckName = generateName(this._$element);

            this.metadata = {
                cardCount: 0,
                deckName: deckName,
                describedByIds: getDescribedByIDs(this._$element, deckName)
            };

            this.initializeAllCards();
        },
        initializeCard: function(selector, context) {
            return initCard(selector, this.metadata);
        },
        initializeAllCards: function() {
            var deckInstance = this;
            $(this._$element).find('.a-cardui').each(function() {
                return initCard(this, deckInstance.metadata);
            });
        },
        addCards: function(options) {
            var deckInstance = this;

            // check if ajax object exists and url is set
            if(!(options && options.url)) {
                P.error("ajax options object or url is not defined.");
            }

            var $target;
            var selector = options.targetSelector;
            var $deckContainer = deckInstance._$element;
            // check if container is provided by client,
            // if provided, then check if it is within the deck: if yes, reset $target; if no, report error;
            // if not provided, use deck containder as the default.
            if(selector) {
                // if target node is within the deck node, reset $target.
                var $potentialTarget = $(selector);
                if ($potentialTarget.closest($deckContainer).length) {
                    $target = $potentialTarget;
                }
                else {
                    P.error("container is outside the deck", "ERROR", "addCards");
                }
            }
            else {
                $target = $deckContainer;
            }

            // call ajax via url
            A.get(options.url, {
                cache: false,
                success: function(data) {
                    // if the request succeeds, append data to container and trigger events.
                    $target.append(data);
                    deckInstance.initializeAllCards();

                    A.trigger("a:deck:new-cards-added");

                    if($(deckInstance._$element).attr('id')) {
                        A.trigger("a:deck:" + $(deckInstance._$element).attr('id') + ":new-cards-added");
                    }
                },
                failure: function(xhr, status, errorThrown) {
                    A.trigger("a:deck:cards-added-fail", {
                        xhr: xhr,
                        status: status,
                        errorThrown: errorThrown
                    });

                    if($(deckInstance._$element).attr('id')) {
                        A.trigger("a:deck:" + $(deckInstance._$element).attr('id') + ":cards-added-fail", {
                            xhr: xhr,
                            status: status,
                            errorThrown: errorThrown
                        });
                    }
                }
            });
        }
    });

    function generateName(ele) {
        var newName = AUTO_NAME_STRING + deckCount++;
        $(ele).attr('name', newName);
        return newName;
    }

    function getDescribedByIDs(deck, name) {
        var describedByCollapsed = name + "-teaser-describedby-collapsed";
        var describedByExpanded = name + "-teaser-describedby-expanded";
        $(deck).find('.a-teaser-describedby-collapsed').attr('id', describedByCollapsed);
        $(deck).find('.a-teaser-describedby-expanded').attr('id', describedByExpanded);
        return {collapsed: describedByCollapsed, expanded: describedByExpanded};
    }

    function initCard(cardDOM, metadata) {
        // GENERATE AUTO NAMES ON CARD
        if(!$(cardDOM).data('cardInstance')) {
            $(cardDOM).attr('name', metadata.deckName + "-card" + metadata.cardCount++);
            $(cardDOM).data("describedByIds", metadata.describedByIds);  
        }

        // CREATE CARD INSTANCE
        return cardui.get(cardDOM);
    }

    function getDeck(selector, context) {
        var instance = new CarduiDeck(selector, context);
        $(selector).data('deckInstance', instance);
        return instance;
    }

    function initializeDeck() {
        $('.a-cardui-deck').each(function() {
            getDeck(this);
        });
    }

    A.on('ready', initializeDeck);

    /*
    * Public factory methods
    */
    return {
        get: function(selector, context) {
            return $(selector).data('deckInstance') || getDeck(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/cardui_deck.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardui_expand_control_footer.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Cardui Expand Control Footer

'use strict';

P.when('A', 'a-component', 'prv:a-see-more', 'prv:a-expander-icon', 'p-detect').register('prv:a-cardui-expand-control-footer', function (A, component, seeMore, expanderIcon, detect) { // jshint ignore:line

    var $ = A.$;

    var FADE_DURATION = 200;

    var ExpandControl = component.create({
        _componentName: 'carduiExpandControlFooter',

        init: function (selector, context) {
            this._super(selector, context);

            // GET SUB COMPONENT INSTANCES
            this._$expanderIcon = getExpanderIcon(this);
            this._$seeMore = getSeeMore(this);
            this._$button = this._$element.find('span[role="button"]');
        },
        toggleExpansion: function (cardMetaData) {
            var footerInstance = this;

            if (detect.capabilities.transition && cardMetaData.interactedOnce) {
                A.fadeOut(footerInstance._$element, FADE_DURATION, 'linear', function () {
                    toggleSubComponents(footerInstance, cardMetaData);
                    A.fadeIn(footerInstance._$element, FADE_DURATION);
                });
            } else {
                toggleSubComponents(footerInstance, cardMetaData);
            }
        },
        getName: function () {
            return this._$element.attr('name');
        },
        getId: function () {
            return this._$element.attr('id');
        },
        addTrigger: function (cardName) {
            // CLICK EVENT
            this._$element.click(function() {
                A.trigger('a:card:' + cardName + ':toggle', this);
            });

            // KEYBOARD ENTER / SPACE EVENT
            this._$element.keypress(function(event) {
                var keycodes = A.constants.keycodes;
                var key = event.which;
                if (key === keycodes.ENTER || key === keycodes.SPACE) {
                    A.trigger('a:card:' + cardName + ':toggle', this);
                }
            });
        }
    });

    function toggleSubComponents (context, cardMetaData) {
        context._$seeMore.toggleSeeMore(cardMetaData.cardExpanded);
        context._$expanderIcon.toggleExpanderIcon(cardMetaData.cardExpanded);
    }

    function getSeeMore(footerInstance) {
        return seeMore.get(footerInstance._$element.find('.a-see-more'));
    }
    function getExpanderIcon(footerInstance) {
        return expanderIcon.get(footerInstance._$element.find('.a-expander-icon'));
    }

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new ExpandControl(selector, context);
        }
    };

});
/////////////////////////
// END FILE js/cardui_expand_control_footer.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardui_expand_control_title.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Cardui Expand Control Title

'use strict';

P.when('A', 'a-component').register('prv:a-cardui-expand-control-title', function (A, component){
    
    var $ = A.$;

    var ExpandControl = component.create({
        _componentName: 'carduiExpandControlTitle',

        init: function (selector, context) {
            this._super(selector, context);

            // GRAB INSTANCES FOR SUB COMPONENTS
            this._$button = this._$element.find('span[role="button"]');
            this._$header = this._$element.find('h3');
        },
        getName: function () {
            return this._$element.attr('name');
        },
        getId: function () {
            return this._$element.attr('id');
        },
        addTrigger: function (cardName) {
            
            // CLICK EVENT
            this._$element.click(function() {
                A.trigger('a:card:' + cardName + ':toggle', this);
            });
            
            // KEYBOARD ENTER / SPACE EVENT
            this._$element.keypress(function(event) {
                var keycodes = A.constants.keycodes;
                var key = event.which;
                if (key === keycodes.ENTER || key === keycodes.SPACE) {
                    A.trigger('a:card:' + cardName + ':toggle', this);
                }
            });
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new ExpandControl(selector, context);
        }
    };
 
});
/////////////////////////
// END FILE js/cardui_expand_control_title.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardui_teaser.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Cardui Teaser  

'use strict';

P.when('A', 'a-component').register('prv:a-cardui-teaser', function (A, component){
    var $ = A.$;

    var CarduiTeaser = component.create({
        _componentName: 'carduiTeaser',
        init: function (selector, context) {
            this._super(selector, context);
        },
        getHeight: function() {
            return this._$element[0].scrollHeight;
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new CarduiTeaser(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/cardui_teaser.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/expander_icon.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Expander Icon

'use strict';

P.when('A', 'a-component').register('prv:a-expander-icon', function (A, component){
    
    var $ = A.$;

    var ExpanderIcon = component.create({
        _componentName: 'expanderIcon',
        init: function (selector, context) {
            this._super(selector, context);
            this._$icon = this._$element.find('.a-css-icon');
        },
        toggleExpanderIcon: function (flag) {
            var currIcon = flag ? 'a-css-icon-expand' : 'a-css-icon-collapse';
            var targetIcon = flag ? 'a-css-icon-collapse' : 'a-css-icon-expand';
            this._$icon.addClass('a-css-icon-draw');
            this._$icon.removeClass(currIcon).addClass(targetIcon);
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new ExpanderIcon(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/expander_icon.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/reactive_container.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Reactive Container

'use strict';

P.when('A', 'a-component', 'prv:a-cardui-scroll-viewport').register('a-reactive-container', function (A, component, viewportScroll) {

    var $ = A.$;

    var ReactiveContainer = component.create({
        _componentName: 'reactiveContainer',
        init: function (selector, context) {
            this._super(selector, context);

            // DEFINES IF ALL CARDS ARE MEASURED AND DRAWN. RESETS ON ORENTATION CHANGE
            this._$measured = false;
            this._$element.addClass('a-reactive-container-transition');
        },
        setHeight: function(ht) {
            this._$element.css('height', ht + 'px');

            // VIEWPORT SCROLLING ONLY ON INTERACTION AND NOT ORIENTATION CHANGE
            if(this._$measured) {
                viewportScroll.adjustScroll(this, parseFloat(ht));
            }
            else {
                this._$measured = true;
            }
        },
        resetInitialization: function() {
            this._$measured = false;
        },
        getHeight: function() {
            return this._$element.css('height');
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new ReactiveContainer(selector, context);
        }
    };

});
/////////////////////////
// END FILE js/reactive_container.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/see_more.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// See More 

'use strict';

P.when('A', 'a-component').register('prv:a-see-more', function (A, component){

    var $ = A.$;

    var SeeMore = component.create({
        _componentName: 'seeMore',
        init: function (selector, context) {
            this._super(selector, context);
            this._$seeMoreText = this._$element.find('.a-see-more-text');
            this._$seeLessText = this._$element.find('.a-see-less-text');
        },
        toggleSeeMore: function (flag) {
            if(flag) {
                this._$seeMoreText.hide();
                this._$seeLessText.show();
            }
            else {
                this._$seeMoreText.show();
                this._$seeLessText.hide();
            }
        }
    });

    /*
    * Public factory methods
    */
    return {
        get: function (selector, context) {
            return new SeeMore(selector, context);
        }
    };
});
/////////////////////////
// END FILE js/see_more.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/util/cardui_scroll_viewport.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Do not scroll on desktop

'use strict';

P.when('A').register('prv:a-cardui-scroll-viewport', function(A) {

    return {
        adjustScroll: function() {}
    };
});
/////////////////////////
// END FILE js/util/cardui_scroll_viewport.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/util/cardui_type_utility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';
/* jshint ignore:start */
P.when('A', 'prv:a-cardui-expand-control-title', 'prv:a-cardui-expand-control-footer', 'prv:a-cardui-teaser', 'prv:a-cardui-content', 'prv:a-reactive-container').register('prv:a-cardui-type-utility', function(A, header, footer, teaser, content, reactiveContainer) {

    var $ = A.$;

    function getExpandControlTitle(carduiInstance) {
        return header.get(carduiInstance._$element.find('.a-cardui-expand-control-title'));
    }

    function getExpandControlFooter(carduiInstance) {
        return footer.get(carduiInstance._$element.find('.a-cardui-expand-control-footer'));
    }

    function getTeaser(carduiInstance) {
        return teaser.get(carduiInstance._$element.find('.a-cardui-teaser'));
    }

    function getContent(carduiInstance) {
        return content.get(carduiInstance._$element.find('.a-cardui-content'));
    }

    function getReactiveContainer(carduiInstance) {
        var rcDom = carduiInstance._$element.find('.a-reactive-container');
        return rcDom.length > 0 ? reactiveContainer.get(rcDom) : null;
    }

    function getEventName(carduiInstance) {
        return 'a:card:' + carduiInstance.getName() + ':toggle';
    }

    function setName(ele, prefix) {
        var name = prefix + "-control";
        $(ele).attr('name', name);
        return name;
    }

    return {
        getExpandControlTitle: getExpandControlTitle,
        getExpandControlFooter: getExpandControlFooter,
        getTeaser: getTeaser,
        getContent: getContent,
        getReactiveContainer: getReactiveContainer,
        getEventName: getEventName
    };
});
/* jshint ignore:end */
/////////////////////////
// END FILE js/util/cardui_type_utility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardType/peek_expand.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('A', 'prv:a-cardui-type-utility').register('prv:a-cardui-peek-expand', function(A, cardTypeUtility) {

    var $ = A.$;
    var FOCUS_CHANGE_DELAY = 50;

    function setAriaAttrs(carduiInstance) {
        var header = carduiInstance._$header;
        var footer = carduiInstance._$footer;
        var cardMetaData = carduiInstance.metadata;

        // For accessibility reasons, re-focus on the header after card content-swap for screen reading continuity. Don't change focus when called on load.
        if(cardMetaData.interactedOnce) {
            A.delay(function() {
                var scrollTop = $(document).scrollTop();
                header._$header.focus();
                $('html,body').scrollTop(scrollTop);
            }, FOCUS_CHANGE_DELAY);
        }

        // Since peek expand content is always accessible to screen readers, there's no reason to bother the user with the status of the expansion, or the fact that there's an expander control at all

        //FOOTER
        footer._$element.attr('aria-hidden', true);
    }

    function handleEvents(carduiInstance) {
        // GENERATES EVENT NAMES TO LISTEN TO
        var event = cardTypeUtility.getEventName(carduiInstance);

        // CATCH CLICK / KEYBOARD EVENTS FROM EXPANDER
        A.on(event, function(triggerElement) {
            // FIRST INTERACTION
            if(!carduiInstance.metadata.interactedOnce) {
                carduiInstance.metadata.interactedOnce = true;
                
                /* PART OF THE INITIAL SETUP IS DELAYED UNTIL FIRST INTERACTION TO OVERCOME MISCALCUALTIONS DUE TO LAZILY LOADED CONTENT
                */
                lazyInitialization(carduiInstance);
            }

            toggleDataExpanded(carduiInstance, !carduiInstance.isExpanded());

            // CALL TOGGLE ON SUB COMPONENTS WITH UPDATED STATE
            toggleSubComponents(carduiInstance);

            var payload = {
                carduiInstance: carduiInstance,
                triggerElement: triggerElement
            };

            A.trigger('a:card:toggled', payload);

            if(carduiInstance.getId()) {
                A.trigger('a:card:' + carduiInstance.getId() + ':toggled', payload);
            }
        });
    }

    function updateReactiveContainerHeight(carduiInstance) {
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;
        var reactiveContainer = carduiInstance._$reactiveContainer;
        var cardMetaData = carduiInstance.metadata;

        if(content.getMaxHeightDataAttribute()) {
            var maxHt;
            var contentHt = content.getHeight();

            if(contentHt <= content.getMaxHeightDataAttribute()) {
                carduiInstance._$element.attr('data-a-card-type', 'basic');
                carduiInstance._$element.find(".a-cardui-footer").addClass('a-hidden');
                maxHt = contentHt;
                reactiveContainer.setHeight(maxHt);
            }
            else {
                carduiInstance._$element.attr('data-a-card-type','peekExpand');
                carduiInstance._$element.find(".a-cardui-footer").removeClass('a-hidden');
                maxHt = content.getMaxHeightDataAttribute();
                reactiveContainer.setHeight(cardMetaData.cardExpanded ? content.getHeight() : maxHt);
            }
        }
        else {
            reactiveContainer.setHeight(cardMetaData.cardExpanded? teaser.getHeight() + content.getHeight() : teaser.getHeight());
        }
    }

    function toggleDataExpanded(carduiInstance, flag) {
        carduiInstance._$element.attr('data-a-expanded', flag);
        carduiInstance.metadata.cardExpanded = flag;
    }

    function toggleSubComponents(carduiInstance) {
        carduiInstance._$footer.toggleExpansion(carduiInstance.metadata);
        updateReactiveContainerHeight(carduiInstance);
        setAriaAttrs(carduiInstance);
    }

    function onOrientationChange(carduiInstance) {
        carduiInstance._$reactiveContainer.resetInitialization();
        updateReactiveContainerHeight(carduiInstance);
    }

    function lazyInitialization(carduiInstance) {
        /* Below classes / attributes define the state of container on load and helps prevent jump in content. We remove these classes and rely on js calculations post 1st interaction. This way we ensure:
        a. smooth transitions for interactions post initialization and 
        b. resolve miscalculation due to lazy loaded content
        */
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;

        teaser._$element.removeClass('a-cardui-uninitialized');
        content._$element.removeClass("a-cardui-uninitialized");
        content._$element.css('max-height', 'none');

        /* SETTING HEIGHT (X) ON REACTIVE CONTAINER HERE TO ENABLE TRANSITION FROM X --> Y, WHERE Y IS TARGET HEIGHT ON TOGGLE
        */
        updateReactiveContainerHeight(carduiInstance);
    }

    return {
        init: function(selector, context) {
            this._super(selector, context);

            //Check that content won't fit in collapsed card. If it does, this can be a basic card with no expansion
            this._$content = cardTypeUtility.getContent(this);
            this._$reactiveContainer = cardTypeUtility.getReactiveContainer(this);
            this._$footer = cardTypeUtility.getExpandControlFooter(this);

            var carduiInstance = this;

            // REFRESH CALCULATIONS ON ORIENTATION CHANGE
            A.on('orientationchange', function() {
                onOrientationChange(carduiInstance);
            });

            // GRAB SUB COMPONENTS FOR INTERACTIVE CARDS
            this._$header = cardTypeUtility.getExpandControlTitle(this);
            this._$teaser = cardTypeUtility.getTeaser(this);

            // ADD TRIGGERS
            this._$header.addTrigger(this.metadata.cardName);
            this._$footer.addTrigger(this.metadata.cardName);

            // THIS IS FOR INITIAL SETUP OF INTERACTIVE CARD
            // CARD INTERACTED ONCE = FALSE
            // WE ARE DOING MOST OF THE INITIALIZATION POST 1ST CLICK TO OVERCOME ISSUES CAUSED BY LAZY LOADED CONTENT
            this._$footer.toggleExpansion(this.metadata);
            
            // INITIAL ACCESSIBILITY SETUP
            setAriaAttrs(this);

            // ADD EVENT HANDLERS FOR INTERACTIVE CARD
            handleEvents(this);

            if (this._$content.getHeight() <= this._$content.getMaxHeightDataAttribute()) {
                this._$reactiveContainer.setHeight(this._$content.getHeight());
                this._$element.attr('data-a-card-type', 'basic');
                this._$element.find(".a-cardui-footer").addClass('a-hidden');
            }
        },
        isExpanded: function () {
            return this._$element.attr('data-a-expanded') === 'true';
        },
        toggle: function (triggerElement) {
            A.trigger('a:card:' + this.getName() + ':toggle', triggerElement);
        }
    };
});
/////////////////////////
// END FILE js/cardType/peek_expand.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/cardType/peek_toggle.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('A', 'prv:a-cardui-type-utility').register('prv:a-cardui-peek-toggle', function(A, cardTypeUtility) {

    var $ = A.$;
    var FOCUS_CHANGE_DELAY = 50;
    var CARD_ABSOLUTE_POSITION_CLASS = 'a-cardui-absolute-position';

    function setAriaAttrs(carduiInstance) {
        var header = carduiInstance._$header;
        var footer = carduiInstance._$footer;
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;
        var cardMetaData = carduiInstance.metadata;

        // For accessibility reasons, re-focus on the header after card content-swap for screen reading continuity. Don't change focus when called on load.
        if(cardMetaData.interactedOnce) {
            A.delay(function() {
                var scrollTop = $(document).scrollTop();
                header._$header.focus();
                $('html,body').scrollTop(scrollTop);
            }, FOCUS_CHANGE_DELAY);
        }

        // Described by labels and expanded states are only necessary for peek toggle cards as peek expand cards' content is fully accessible by screen readers without interaction necessary

        // HEADER
        header._$button.attr('aria-expanded', cardMetaData.cardExpanded);
        header._$header.attr('aria-describedby', cardMetaData.cardExpanded ? cardMetaData.describedByIds.expanded : cardMetaData.describedByIds.collapsed);

        //FOOTER
        footer._$button.attr('aria-expanded', cardMetaData.cardExpanded);
        footer._$element.attr('aria-describedby', cardMetaData.cardExpanded ? cardMetaData.describedByIds.expanded : cardMetaData.describedByIds.collapsed);

        // TOGGLE CONTENT VISIBIITY FROM SCREEN READER ONLY FOR PEEK TOGGLE.

        //TEASER
        teaser._$element.attr('aria-hidden', cardMetaData.cardExpanded);

        //CONTENT
        content._$element.attr('aria-hidden', !cardMetaData.cardExpanded);
    }

    function handleEvents(carduiInstance) {
        // GENERATES EVENT NAMES TO LISTEN TO
        var event = cardTypeUtility.getEventName(carduiInstance);

        // CATCH CLICK / KEYBOARD EVENTS FROM EXPANDER
        A.on(event, function (triggerElement) {
            //FIRST INTERACTION
            if(!carduiInstance.metadata.interactedOnce) {
                carduiInstance.metadata.interactedOnce = true;

                /* PART OF THE INITIAL SETUP IS DELAYED UNTIL FIRST INTERACTION TO OVERCOME MISCALCUALTIONS DUE TO LAZILY LOADED CONTENT
                */
                lazyInitialization(carduiInstance);
            }

            toggleDataExpanded(carduiInstance, !carduiInstance.isExpanded());

            // CALL TOGGLE ON SUB COMPONENTS WITH UPDATED STATE
            toggleSubComponents(carduiInstance);

            var payload = {
                carduiInstance: carduiInstance,
                triggerElement: triggerElement
            };

            A.trigger('a:card:toggled', payload);

            if(carduiInstance.getId()) {
                A.trigger('a:card:' + carduiInstance.getId() + ':toggled', payload);
            }
        });
    }

    function updateReactiveContainerHeight(carduiInstance) {
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;
        var reactiveContainer = carduiInstance._$reactiveContainer;
        var cardMetaData = carduiInstance.metadata;
        if(cardMetaData.cardExpanded) {
            reactiveContainer.setHeight(content.getHeight());
        }
        else {
            reactiveContainer.setHeight(teaser.getHeight());
        }
    }

    function toggleDataExpanded(carduiInstance, flag) {
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;
        carduiInstance._$element.attr('data-a-expanded', flag);
        carduiInstance.metadata.cardExpanded = flag;

        if(flag) {
            teaser._$element.addClass(CARD_ABSOLUTE_POSITION_CLASS);
            content._$element.removeClass(CARD_ABSOLUTE_POSITION_CLASS);
        }
        else {
            content._$element.addClass(CARD_ABSOLUTE_POSITION_CLASS);
            teaser._$element.removeClass(CARD_ABSOLUTE_POSITION_CLASS);
        }
    }

    function toggleSubComponents(carduiInstance) {
        carduiInstance._$footer.toggleExpansion(carduiInstance.metadata);
        if(carduiInstance._$reactiveContainer) {
            updateReactiveContainerHeight(carduiInstance);
        }
        setAriaAttrs(carduiInstance);
    }

    function onOrientationChange(carduiInstance) {

        // DONT DO ANYTHING UNTIL FIRST CLICK
        if(carduiInstance.metadata.interactedOnce) {
            // THIS IS TO AVOID VIEWPORT SCROLL ON ORIENTATION CHANGE WHEN HEIGHT UPDATE IS PERFORMED
            carduiInstance._$reactiveContainer.resetInitialization();
            updateReactiveContainerHeight(carduiInstance);
        }
    }

    function lazyInitialization(carduiInstance) {
        /* Below classes / attributes define the state of container on load and helps prevent jump in content. We remove these classes and rely on js calculations post 1st interaction. This way we ensure:
        a. smooth transitions for interactions post initialization and 
        b. resolve miscalculation due to lazy loaded content
        */
        var teaser = carduiInstance._$teaser;
        var content = carduiInstance._$content;

        teaser._$element.removeClass('a-cardui-uninitialized');
        content._$element.removeClass("a-cardui-uninitialized");

        /* SETTING HEIGHT (X) ON REACTIVE CONTAINER HERE TO ENABLE TRANSITION FROM X --> Y, WHERE Y IS TARGET HEIGHT ON TOGGLE
        */
        if(carduiInstance._$reactiveContainer) {
            updateReactiveContainerHeight(carduiInstance);
        }
    }

    return {
        init: function(selector, context) {
            this._super(selector, context);

            // GRAB SUB COMPONENTS FOR INTERACTIVE CARDS
            this._$header = cardTypeUtility.getExpandControlTitle(this);
            this._$content = cardTypeUtility.getContent(this);
            this._$footer = cardTypeUtility.getExpandControlFooter(this);
            this._$teaser = cardTypeUtility.getTeaser(this);
            this._$reactiveContainer = cardTypeUtility.getReactiveContainer(this);

            // ADD TRIGGERS
            this._$header.addTrigger(this.metadata.cardName);
            this._$footer.addTrigger(this.metadata.cardName);

            // THIS IS FOR INITIAL SETUP OF INTERACTIVE CARD
            // CARD INTERACTED ONCE = FALSE
            // WE ARE DOING MOST OF THE INITIALIZATION POST 1ST CLICK TO OVERCOME ISSUES CAUSED BY LAZY LOADED CONTENT
            this._$footer.toggleExpansion(this.metadata);

            // INITIAL ACCESSIBILITY SETUP
            setAriaAttrs(this);

            // ADD EVENT HANDLERS FOR INTERACTIVE CARD
            handleEvents(this);

            var carduiInstance = this;

            // REFRESH CALCULATIONS ON ORIENTATION CHANGE
            if(carduiInstance._$reactiveContainer) {
                A.on('orientationchange', function() {
                    onOrientationChange(carduiInstance);
                });
            }
        },
        isExpanded: function () {
            return this._$element.attr('data-a-expanded') === 'true';
        },
        toggle: function (triggerElement) {
            A.trigger('a:card:' + this.getName() + ':toggle', triggerElement);
        }
    };
});
/////////////////////////
// END FILE js/cardType/peek_toggle.js
/////////////////////////

// END ASSET AmazonUICardUI-3.2.16595.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICompatJS", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUICompatJS-3.0.296981.0
/////////////////////////
// BEGIN FILE js/a_ios_bugs.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/a_ios_bugs.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_orientation_change.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/a_orientation_change.js
/////////////////////////

// END ASSET AmazonUICompatJS-3.0.296981.0
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUI", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUI-3.2.17893.0
/////////////////////////
// BEGIN FILE @version_injector.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
window.pcv = window.pcv || {};
window.pcv["AmazonUI"] = "b3291c366771c20626e793ecbe90828abd480600";
/////////////////////////
// END FILE @version_injector.js
/////////////////////////
// END ASSET AmazonUI-3.2.17893.0
}));
////////////////////////////////////////////
/* ******** */
